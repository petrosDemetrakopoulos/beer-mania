------- FILE beer_mania.bas.asm LEVEL 1 PASS 2
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE beer_mania.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE beer_mania.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 01	   pfscore    =	1
      5  5000 ????
      6  5000 ????	       00 eb	   _Ch0_Duration4 =	x
      7  5000 ????
      8  5000 ????	       00 ea	   _Ch0_Duration3 =	w
      9  5000 ????
     10  5000 ????	       00 e9	   _Ch0_Duration2 =	v
     11  5000 ????
     12  5000 ????	       00 e4	   _Ch0_Duration1 =	q
     13  5000 ????
     14  5000 ????	       00 e0	   _Ch0_Sound =	m
     15  5000 ????
     16  5000 ????	       00 e1	   rand16     =	n
     17  5000 ????
     18  5000 ????	       00 d6	   bmp_player0_index =	c
     19  5000 ????
     20  5000 ????	       00 d7	   missed     =	d
     21  5000 ????
     22  5000 ????	       00 4b	   logo_height =	75
     23  5000 ????
     24  5000 ????	       00 1c	   logo_color =	$1C
     25  5000 ????
     26  5000 ????	       00 d5	   addvalue   =	b
     27  5000 ????
     28  5000 ????	       00 d4	   frame      =	a
     29  5000 ????
     30  5000 ????	       00 ec	   _Bit2_Game_Control =	y
     31  5000 ????
     32  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     33  5000 ????
     34  5000 ????	       00 2b	   vblank_time =	43
     35  5000 ????	       00 25	   overscan_time =	37
     36  5000 ????	       00 01	   PFcolors   =	1
     37  5000 ????	       00 01	   no_blank_lines =	1
     38  5000 ????	       00 01	   player1colors =	1
     39  5000 ????	       00 03	   bs_mask    =	3
     40  5000 ????	       00 10	   bankswitch =	16
     41  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
------- FILE 2600basic.h
      7  5000 ????
      8  5000 ????	       00 80	   player0x   =	$80
      9  5000 ????	       00 81	   player1x   =	$81
     10  5000 ????	       00 82	   missile0x  =	$82
     11  5000 ????	       00 83	   missile1x  =	$83
     12  5000 ????	       00 84	   ballx      =	$84
     13  5000 ????
     14  5000 ????	       00 85	   objecty    =	$85
     15  5000 ????	       00 85	   player0y   =	$85
     16  5000 ????	       00 86	   player1y   =	$86
     17  5000 ????	       00 87	   missile1height =	$87
     18  5000 ????	       00 88	   missile1y  =	$88
     19  5000 ????	       00 89	   bally      =	$89
     20  5000 ????
     21  5000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  5000 ????
     23  5000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  5000 ????	       00 8a	   player0pointerlo =	$8A
     25  5000 ????	       00 8b	   player0pointerhi =	$8B
     26  5000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  5000 ????	       00 8c	   player1pointerlo =	$8C
     28  5000 ????	       00 8d	   player1pointerhi =	$8D
     29  5000 ????
     30  5000 ????	       00 8e	   player0height =	$8E
     31  5000 ????	       00 8f	   player1height =	$8F
     32  5000 ????	       00 90	   missile0height =	$90
     33  5000 ????	       00 91	   missile0y  =	$91
     34  5000 ????	       00 92	   ballheight =	$92
     35  5000 ????
     36  5000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  5000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  5000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  5000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  5000 ????
     41  5000 ????	       00 93	   score      =	$93	; $93-$95
     42  5000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  5000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  5000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  5000 ????	       00 9e	   temp3      =	$9E
     46  5000 ????	       00 9f	   temp4      =	$9F
     47  5000 ????	       00 a0	   temp5      =	$A0
     48  5000 ????	       00 a1	   temp6      =	$A1
     49  5000 ????
     50  5000 ????	       00 a2	   rand       =	$A2
     51  5000 ????	       00 a3	   scorecolor =	$A3
     52  5000 ????
     53  5000 ????	       00 a4	   var0       =	$A4
     54  5000 ????	       00 a5	   var1       =	$A5
     55  5000 ????	       00 a6	   var2       =	$A6
     56  5000 ????	       00 a7	   var3       =	$A7
     57  5000 ????	       00 a8	   var4       =	$A8
     58  5000 ????	       00 a9	   var5       =	$A9
     59  5000 ????	       00 aa	   var6       =	$AA
     60  5000 ????	       00 ab	   var7       =	$AB
     61  5000 ????	       00 ac	   var8       =	$AC
     62  5000 ????	       00 ad	   var9       =	$AD
     63  5000 ????	       00 ae	   var10      =	$AE
     64  5000 ????	       00 af	   var11      =	$AF
     65  5000 ????	       00 b0	   var12      =	$B0
     66  5000 ????	       00 b1	   var13      =	$B1
     67  5000 ????	       00 b2	   var14      =	$B2
     68  5000 ????	       00 b3	   var15      =	$B3
     69  5000 ????	       00 b4	   var16      =	$B4
     70  5000 ????	       00 b5	   var17      =	$B5
     71  5000 ????	       00 b6	   var18      =	$B6
     72  5000 ????	       00 b7	   var19      =	$B7
     73  5000 ????	       00 b8	   var20      =	$B8
     74  5000 ????	       00 b9	   var21      =	$B9
     75  5000 ????	       00 ba	   var22      =	$BA
     76  5000 ????	       00 bb	   var23      =	$BB
     77  5000 ????	       00 bc	   var24      =	$BC
     78  5000 ????	       00 bd	   var25      =	$BD
     79  5000 ????	       00 be	   var26      =	$BE
     80  5000 ????	       00 bf	   var27      =	$BF
     81  5000 ????	       00 c0	   var28      =	$C0
     82  5000 ????	       00 c1	   var29      =	$C1
     83  5000 ????	       00 c2	   var30      =	$C2
     84  5000 ????	       00 c3	   var31      =	$C3
     85  5000 ????	       00 c4	   var32      =	$C4
     86  5000 ????	       00 c5	   var33      =	$C5
     87  5000 ????	       00 c6	   var34      =	$C6
     88  5000 ????	       00 c7	   var35      =	$C7
     89  5000 ????	       00 c8	   var36      =	$C8
     90  5000 ????	       00 c9	   var37      =	$C9
     91  5000 ????	       00 ca	   var38      =	$CA
     92  5000 ????	       00 cb	   var39      =	$CB
     93  5000 ????	       00 cc	   var40      =	$CC
     94  5000 ????	       00 cd	   var41      =	$CD
     95  5000 ????	       00 ce	   var42      =	$CE
     96  5000 ????	       00 cf	   var43      =	$CF
     97  5000 ????	       00 d0	   var44      =	$D0
     98  5000 ????	       00 d1	   var45      =	$D1
     99  5000 ????	       00 d2	   var46      =	$D2
    100  5000 ????	       00 d3	   var47      =	$D3
    101  5000 ????
    102  5000 ????	       00 d4	   A	      =	$d4
    103  5000 ????	       00 d4	   a	      =	$d4
    104  5000 ????	       00 d5	   B	      =	$d5
    105  5000 ????	       00 d5	   b	      =	$d5
    106  5000 ????	       00 d6	   C	      =	$d6
    107  5000 ????	       00 d6	   c	      =	$d6
    108  5000 ????	       00 d7	   D	      =	$d7
    109  5000 ????	       00 d7	   d	      =	$d7
    110  5000 ????	       00 d8	   E	      =	$d8
    111  5000 ????	       00 d8	   e	      =	$d8
    112  5000 ????	       00 d9	   F	      =	$d9
    113  5000 ????	       00 d9	   f	      =	$d9
    114  5000 ????	       00 da	   G	      =	$da
    115  5000 ????	       00 da	   g	      =	$da
    116  5000 ????	       00 db	   H	      =	$db
    117  5000 ????	       00 db	   h	      =	$db
    118  5000 ????	       00 dc	   I	      =	$dc
    119  5000 ????	       00 dc	   i	      =	$dc
    120  5000 ????	       00 dd	   J	      =	$dd
    121  5000 ????	       00 dd	   j	      =	$dd
    122  5000 ????	       00 de	   K	      =	$de
    123  5000 ????	       00 de	   k	      =	$de
    124  5000 ????	       00 df	   L	      =	$df
    125  5000 ????	       00 df	   l	      =	$df
    126  5000 ????	       00 e0	   M	      =	$e0
    127  5000 ????	       00 e0	   m	      =	$e0
    128  5000 ????	       00 e1	   N	      =	$e1
    129  5000 ????	       00 e1	   n	      =	$e1
    130  5000 ????	       00 e2	   O	      =	$e2
    131  5000 ????	       00 e2	   o	      =	$e2
    132  5000 ????	       00 e3	   P	      =	$e3
    133  5000 ????	       00 e3	   p	      =	$e3
    134  5000 ????	       00 e4	   Q	      =	$e4
    135  5000 ????	       00 e4	   q	      =	$e4
    136  5000 ????	       00 e5	   R	      =	$e5
    137  5000 ????	       00 e5	   r	      =	$e5
    138  5000 ????	       00 e6	   S	      =	$e6
    139  5000 ????	       00 e6	   s	      =	$e6
    140  5000 ????	       00 e7	   T	      =	$e7
    141  5000 ????	       00 e7	   t	      =	$e7
    142  5000 ????	       00 e8	   U	      =	$e8
    143  5000 ????	       00 e8	   u	      =	$e8
    144  5000 ????	       00 e9	   V	      =	$e9
    145  5000 ????	       00 e9	   v	      =	$e9
    146  5000 ????	       00 ea	   W	      =	$ea
    147  5000 ????	       00 ea	   w	      =	$ea
    148  5000 ????	       00 eb	   X	      =	$eb
    149  5000 ????	       00 eb	   x	      =	$eb
    150  5000 ????	       00 ec	   Y	      =	$ec
    151  5000 ????	       00 ec	   y	      =	$ec
    152  5000 ????	       00 ed	   Z	      =	$ed
    153  5000 ????	       00 ed	   z	      =	$ed
    154  5000 ????
    155  5000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  5000 ????	       00 ef	   playfieldpos =	$ef
    157  5000 ????
    158  5000 ????						; available for other uses, or if unused, provide more stack space
    159  5000 ????
    160  5000 ????	       00 f0	   aux1       =	$f0
    161  5000 ????	       00 f1	   aux2       =	$f1
    162  5000 ????	       00 f2	   aux3       =	$f2
    163  5000 ????	       00 f3	   aux4       =	$f3
    164  5000 ????	       00 f4	   aux5       =	$f4
    165  5000 ????	       00 f5	   aux6       =	$f5
    166  5000 ????
    167  5000 ????						; playfield color/height pointers
    168  5000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  5000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  5000 ????						; the above pointers are the same because if color and height are both used together,
    171  5000 ????						; they must used absolute indexed and cannot use pointers
    172  5000 ????
    173  5000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  5000 ????						; upper 3 bits of $f2 contain the number of lives
    175  5000 ????	       00 f4	   lifecolor  =	$f4
    176  5000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  5000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  5000 ????
    179  5000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  5000 ????	       00 f3	   pfscore2   =	$f3
    181  5000 ????	       00 f4	   pfscorecolor =	$f4
    182  5000 ????
    183  5000 ????	       00 f6	   stack1     =	$f6
    184  5000 ????	       00 f7	   stack2     =	$f7
    185  5000 ????	       00 f8	   stack3     =	$f8
    186  5000 ????	       00 f9	   stack4     =	$f9
    187  5000 ????						; the stack bytes above may be used in the kernel
    188  5000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  5000 ????
    190  5000 ????				      MAC	return
    191  5000 ????				      ifnconst	bankswitch
    192  5000 ????				      rts
    193  5000 ????				      else
    194  5000 ????				      jmp	BS_return
    195  5000 ????				      endif
    196  5000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  5000 ????
    198  5000 ????			  -	      ifconst	superchip
    199  5000 ????			  -playfieldbase =	$10D0
    200  5000 ????			  -	      include	superchip.h
    201  5000 ????				      else
    202  5000 ????	       00 a4	   playfieldbase =	$A4
    203  5000 ????				      endif
    204  5000 ????
    205  5000 ????				      ifnconst	pfhalfwidth
    206  5000 ????	       00 04	   pfwidth    =	4
    207  5000 ????	       00 0e	   PF1L       =	PF1
    208  5000 ????	       00 0f	   PF2L       =	PF2
    209  5000 ????	       00 0e	   PF1R       =	PF1
    210  5000 ????	       00 0f	   PF2R       =	PF2
    211  5000 ????	       00 00	   pfadjust   =	0
    212  5000 ????			  -	      else
    213  5000 ????			  -pfwidth    =	2
    214  5000 ????			  -	      ifconst	pfcenter
    215  5000 ????			  -PF1L       =	$3F	; no effect
    216  5000 ????			  -PF2L       =	PF2
    217  5000 ????			  -PF1R       =	$3F
    218  5000 ????			  -PF2R       =	PF2	; no effect
    219  5000 ????			  -pfadjust   =	1
    220  5000 ????			  -	      else
    221  5000 ????			  -PF1L       =	PF1
    222  5000 ????			  -PF2L       =	PF2
    223  5000 ????			  -PF1R       =	$3F	; no effect
    224  5000 ????			  -PF2R       =	$3F	; no effect
    225  5000 ????			  -pfadjust   =	0
    226  5000 ????			  -	      endif
    227  5000 ????				      endif
    228  5000 ????
    229  5000 ????						; define playfield start based on height
    230  5000 ????				      ifnconst	pfres
    231  5000 ????	       00 a4	   playfield  =	playfieldbase
    232  5000 ????			  -	      else
    233  5000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  5000 ????				      endif
------- FILE beer_mania.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 01	   pfscore    =	1
      5  5000 ????
      6  5000 ????	       00 eb	   _Ch0_Duration4 =	x
      7  5000 ????
      8  5000 ????	       00 ea	   _Ch0_Duration3 =	w
      9  5000 ????
     10  5000 ????	       00 e9	   _Ch0_Duration2 =	v
     11  5000 ????
     12  5000 ????	       00 e4	   _Ch0_Duration1 =	q
     13  5000 ????
     14  5000 ????	       00 e0	   _Ch0_Sound =	m
     15  5000 ????
     16  5000 ????	       00 e1	   rand16     =	n
     17  5000 ????
     18  5000 ????	       00 d6	   bmp_player0_index =	c
     19  5000 ????
     20  5000 ????	       00 d7	   missed     =	d
     21  5000 ????
     22  5000 ????	       00 4b	   logo_height =	75
     23  5000 ????
     24  5000 ????	       00 1c	   logo_color =	$1C
     25  5000 ????
     26  5000 ????	       00 d5	   addvalue   =	b
     27  5000 ????
     28  5000 ????	       00 d4	   frame      =	a
     29  5000 ????
     30  5000 ????	       00 ec	   _Bit2_Game_Control =	y
     31  5000 ????
     32  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     33  5000 ????
     34  5000 ????	       00 2b	   vblank_time =	43
     35  5000 ????	       00 25	   overscan_time =	37
     36  5000 ????	       00 01	   PFcolors   =	1
     37  5000 ????	       00 01	   no_blank_lines =	1
     38  5000 ????	       00 01	   player1colors =	1
     39  5000 ????	       00 03	   bs_mask    =	3
     40  5000 ????	       00 10	   bankswitch =	16
     41  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
------- FILE beer_mania.bas.asm
      8  5000 ????				      ifconst	bankswitch
      9  5000 ????			  -	      if	bankswitch == 8
     10  5000 ????			  -	      ORG	$1000
     11  5000 ????			  -	      RORG	$D000
     12  5000 ????				      endif
     13  5000 ????				      if	bankswitch == 16
     14  1000					      ORG	$1000
     15  1000					      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .L00 		;  set romsize 16k
     36  1000
     37  1000				   .L01 		;  set kernel_options player1colors pfcolors no_blank_lines
     38  1000
     39  1000				   .L02 		;  set optimization inlinerand
     40  1000
     41  1000				   .
     42  1000							;
     43  1000
     44  1000				   .
     45  1000							;
     46  1000
     47  1000				   .L03 		;  set tv ntsc
     48  1000
     49  1000				   .
     50  1000							;
     51  1000
     52  1000				   .
     53  1000							;
     54  1000
     55  1000				   .L04 		;  pfclear
     56  1000
     57  1000		       a9 00		      LDA	#0
     58  1002		       85 ee		      sta	temp7
     59  1004		       a9 90		      lda	#>(ret_point1-1)
     60  1006		       48		      pha
     61  1007		       a9 19		      lda	#<(ret_point1-1)
     62  1009		       48		      pha
     63  100a		       a9 f2		      lda	#>(pfclear-1)
     64  100c		       48		      pha
     65  100d		       a9 8f		      lda	#<(pfclear-1)
     66  100f		       48		      pha
     67  1010		       a5 ee		      lda	temp7
     68  1012		       48		      pha
     69  1013		       8a		      txa
     70  1014		       48		      pha
     71  1015		       a2 04		      ldx	#4
     72  1017		       4c eb ff 	      jmp	BS_jsr
     73  101a				   ret_point1
     74  101a				   .
     75  101a							;
     76  101a
     77  101a				   .
     78  101a							;
     79  101a
     80  101a				   .L05 		;  AUDV0  =  0  :  AUDV1  =  0
     81  101a
     82  101a		       a9 00		      LDA	#0
     83  101c		       85 19		      STA	AUDV0
     84  101e		       85 1a		      STA	AUDV1
     85  1020				   .
     86  1020							;
     87  1020
     88  1020				   .
     89  1020							;
     90  1020
     91  1020				   .L06 		;  dim _Bit0_Reset_Restrainer	=  y
     92  1020
     93  1020				   .L07 		;  dim _Bit2_Game_Control  =  y
     94  1020
     95  1020				   .
     96  1020							;
     97  1020
     98  1020				   .
     99  1020							;
    100  1020
    101  1020				   .L08 		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    102  1020
    103  1020		       a9 00		      LDA	#0
    104  1022		       85 d4		      STA	a
    105  1024		       85 d5		      STA	b
    106  1026		       85 d6		      STA	c
    107  1028		       85 d7		      STA	d
    108  102a		       85 d8		      STA	e
    109  102c		       85 d9		      STA	f
    110  102e		       85 da		      STA	g
    111  1030		       85 db		      STA	h
    112  1032		       85 dc		      STA	i
    113  1034				   .L09 		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    114  1034
    115  1034		       a9 00		      LDA	#0
    116  1036		       85 dd		      STA	j
    117  1038		       85 de		      STA	k
    118  103a		       85 df		      STA	l
    119  103c		       85 e0		      STA	m
    120  103e		       85 e1		      STA	n
    121  1040		       85 e2		      STA	o
    122  1042		       85 e3		      STA	p
    123  1044		       85 e4		      STA	q
    124  1046		       85 e5		      STA	r
    125  1048				   .L010		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0  :	z  =  0
    126  1048
    127  1048		       a9 00		      LDA	#0
    128  104a		       85 e6		      STA	s
    129  104c		       85 e7		      STA	t
    130  104e		       85 e8		      STA	u
    131  1050		       85 e9		      STA	v
    132  1052		       85 ea		      STA	w
    133  1054		       85 eb		      STA	x
    134  1056		       85 ec		      STA	y
    135  1058		       85 ed		      STA	z
    136  105a				   .L011		;  var0  =  0	:  var1  =  0  :  var2	=  0  :  var3  =  0  :	var4  =  0
    137  105a
    138  105a		       a9 00		      LDA	#0
    139  105c		       85 a4		      STA	var0
    140  105e		       85 a5		      STA	var1
    141  1060		       85 a6		      STA	var2
    142  1062		       85 a7		      STA	var3
    143  1064		       85 a8		      STA	var4
    144  1066				   .L012		;  var5  =  0	:  var6  =  0  :  var7	=  0  :  var8  =  0
    145  1066
    146  1066		       a9 00		      LDA	#0
    147  1068		       85 a9		      STA	var5
    148  106a		       85 aa		      STA	var6
    149  106c		       85 ab		      STA	var7
    150  106e		       85 ac		      STA	var8
    151  1070				   .
    152  1070							;
    153  1070
    154  1070				   .L013		;  dim frame = a
    155  1070
    156  1070				   .L014		;  dim addvalue = b
    157  1070
    158  1070				   .L015		;  const logo_color = $1C
    159  1070
    160  1070				   .L016		;  const logo_height = 75
    161  1070
    162  1070				   .L017		;  dim missed = d
    163  1070
    164  1070				   .L018		;  rem ** we define this because player 0 has multiple frames...
    165  1070
    166  1070				   .L019		;  dim bmp_player0_index = c
    167  1070
    168  1070				   .L020		;  dim rand16 = n
    169  1070
    170  1070				   .
    171  1070							;
    172  1070
    173  1070				   .L021		;  dim _Ch0_Sound  =  m
    174  1070
    175  1070				   .L022		;  dim _Ch0_Duration1	=  q
    176  1070
    177  1070				   .L023		;  dim _Ch0_Duration2	=  v
    178  1070
    179  1070				   .L024		;  dim _Ch0_Duration3	=  w
    180  1070
    181  1070				   .L025		;  dim _Ch0_Duration4	=  x
    182  1070
    183  1070				   .
    184  1070							;
    185  1070
    186  1070				   .L026		;  const pfscore  =  1
    187  1070
    188  1070				   .L027		;  pfscore1  =  %10101010
    189  1070
    190  1070		       a9 aa		      LDA	#%10101010
    191  1072		       85 f2		      STA	pfscore1
    192  1074				   .L028		;  COLUBK  =  $CE
    193  1074
    194  1074		       a9 ce		      LDA	#$CE
    195  1076		       85 09		      STA	COLUBK
    196  1078				   .
    197  1078							;
    198  1078
    199  1078				   .L029		;  scorecolor = $B4
    200  1078
    201  1078		       a9 b4		      LDA	#$B4
    202  107a		       85 a3		      STA	scorecolor
    203  107c				   .
    204  107c							;
    205  107c
    206  107c				   .titlepage
    207  107c							; titlepage
    208  107c
    209  107c				   .L030		;  gosub titledrawscreen bank2
    210  107c
    211  107c		       85 ee		      sta	temp7
    212  107e		       a9 90		      lda	#>(ret_point2-1)
    213  1080		       48		      pha
    214  1081		       a9 93		      lda	#<(ret_point2-1)
    215  1083		       48		      pha
    216  1084		       a9 b0		      lda	#>(.titledrawscreen-1)
    217  1086		       48		      pha
    218  1087		       a9 05		      lda	#<(.titledrawscreen-1)
    219  1089		       48		      pha
    220  108a		       a5 ee		      lda	temp7
    221  108c		       48		      pha
    222  108d		       8a		      txa
    223  108e		       48		      pha
    224  108f		       a2 02		      ldx	#2
    225  1091		       4c eb ff 	      jmp	BS_jsr
    226  1094				   ret_point2
    227  1094				   .
    228  1094							;
    229  1094
    230  1094				   .L031		;  if joy0fire  ||  switchreset then player0y = 200 : goto gamestart
    231  1094
    232  1094		       24 0c		      bit	INPT4
    233  1096		       30 03		      BMI	.skipL031
    234  1098				   .condpart0
    235  1098		       4c a2 90 	      jmp	.condpart1
    236  109b				   .skipL031
    237  109b		       a9 01		      lda	#1
    238  109d		       2c 82 02 	      bit	SWCHB
    239  10a0		       d0 07		      BNE	.skip0OR
    240  10a2				   .condpart1
    241  10a2		       a9 c8		      LDA	#200
    242  10a4		       85 85		      STA	player0y
    243  10a6		       4c ac 90 	      jmp	.gamestart
    244  10a9
    245  10a9				   .skip0OR
    246  10a9				   .L032		;  goto titlepage
    247  10a9
    248  10a9		       4c 7c 90 	      jmp	.titlepage
    249  10ac
    250  10ac				   .
    251  10ac							;
    252  10ac
    253  10ac				   .L033		;  rem *** Our fake game start. If you move the joystick it goes back to the
    254  10ac
    255  10ac				   .L034		;  rem *** title screen.
    256  10ac
    257  10ac				   .gamestart
    258  10ac							; gamestart
    259  10ac
    260  10ac				   .
    261  10ac							;
    262  10ac
    263  10ac				   .L035		;  _Bit2_Game_Control{2}  =  0
    264  10ac
    265  10ac		       a5 ec		      LDA	_Bit2_Game_Control
    266  10ae		       29 fb		      AND	#251
    267  10b0		       85 ec		      STA	_Bit2_Game_Control
    268  10b2				   .L036		;  _Ch0_Sound	=  0
    269  10b2
    270  10b2		       a9 00		      LDA	#0
    271  10b4		       85 e0		      STA	_Ch0_Sound
    272  10b6				   .L037		;  player0x  =  50
    273  10b6
    274  10b6		       a9 32		      LDA	#50
    275  10b8		       85 80		      STA	player0x
    276  10ba				   .L038		;  player0y  =  80
    277  10ba
    278  10ba		       a9 50		      LDA	#80
    279  10bc		       85 85		      STA	player0y
    280  10be				   .
    281  10be							;
    282  10be
    283  10be				   .L039		;  player1x  =  20
    284  10be
    285  10be		       a9 14		      LDA	#20
    286  10c0		       85 81		      STA	player1x
    287  10c2				   .L040		;  player1y  =  20
    288  10c2
    289  10c2		       a9 14		      LDA	#20
    290  10c4		       85 86		      STA	player1y
    291  10c6				   .
    292  10c6							;
    293  10c6
    294  10c6				   .L041		;  playfield:
    295  10c6
    296  10c6				  -	      ifconst	pfres
    297  10c6				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    298  10c6					      else
    299  10c6		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    300  10c8					      endif
    301  10c8		       4c f7 90 	      jmp	pflabel0
    302  10cb				   PF_data0
    303  10cb		       ff ff		      .byte.b	%11111111, %11111111
    304  10cd					      if	(pfwidth>2)
    305  10cd		       ff ff		      .byte.b	%11111111, %11111111
    306  10cf					      endif
    307  10cf		       ff ff		      .byte.b	%11111111, %11111111
    308  10d1					      if	(pfwidth>2)
    309  10d1		       ff ff		      .byte.b	%11111111, %11111111
    310  10d3					      endif
    311  10d3		       ff ff		      .byte.b	%11111111, %11111111
    312  10d5					      if	(pfwidth>2)
    313  10d5		       ff ff		      .byte.b	%11111111, %11111111
    314  10d7					      endif
    315  10d7		       ff ff		      .byte.b	%11111111, %11111111
    316  10d9					      if	(pfwidth>2)
    317  10d9		       ff ff		      .byte.b	%11111111, %11111111
    318  10db					      endif
    319  10db		       ff ff		      .byte.b	%11111111, %11111111
    320  10dd					      if	(pfwidth>2)
    321  10dd		       ff ff		      .byte.b	%11111111, %11111111
    322  10df					      endif
    323  10df		       ff ff		      .byte.b	%11111111, %11111111
    324  10e1					      if	(pfwidth>2)
    325  10e1		       ff ff		      .byte.b	%11111111, %11111111
    326  10e3					      endif
    327  10e3		       ff ff		      .byte.b	%11111111, %11111111
    328  10e5					      if	(pfwidth>2)
    329  10e5		       ff ff		      .byte.b	%11111111, %11111111
    330  10e7					      endif
    331  10e7		       ff ff		      .byte.b	%11111111, %11111111
    332  10e9					      if	(pfwidth>2)
    333  10e9		       ff ff		      .byte.b	%11111111, %11111111
    334  10eb					      endif
    335  10eb		       ff ff		      .byte.b	%11111111, %11111111
    336  10ed					      if	(pfwidth>2)
    337  10ed		       ff ff		      .byte.b	%11111111, %11111111
    338  10ef					      endif
    339  10ef		       ff ff		      .byte.b	%11111111, %11111111
    340  10f1					      if	(pfwidth>2)
    341  10f1		       ff ff		      .byte.b	%11111111, %11111111
    342  10f3					      endif
    343  10f3		       ff ff		      .byte.b	%11111111, %11111111
    344  10f5					      if	(pfwidth>2)
    345  10f5		       ff ff		      .byte.b	%11111111, %11111111
    346  10f7					      endif
    347  10f7				   pflabel0
    348  10f7		       bd cb 90 	      lda	PF_data0,x
    349  10fa		       95 a4		      sta	playfield,x
    350  10fc		       ca		      dex
    351  10fd		       10 f8		      bpl	pflabel0
    352  10ff				   .
    353  10ff							;
    354  10ff
    355  10ff				   .L042		;  pfcolors:
    356  10ff
    357  10ff		       a9 9e		      lda	# $9E
    358  1101		       85 08		      sta	COLUPF
    359  1103				  -	      ifconst	pfres
    360  1103				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
    361  1103					      else
    362  1103		       a9 f5		      lda	#>(pfcolorlabel13-84)
    363  1105					      endif
    364  1105		       85 f1		      sta	pfcolortable+1
    365  1107				  -	      ifconst	pfres
    366  1107				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
    367  1107					      else
    368  1107		       a9 04		      lda	#<(pfcolorlabel13-84)
    369  1109					      endif
    370  1109		       85 f0		      sta	pfcolortable
    371  110b				   .
    372  110b							;
    373  110b
    374  110b				   .L043		;  player0:
    375  110b
    376  110b		       a2 80		      LDX	#<playerL043_0
    377  110d		       86 8a		      STX	player0pointerlo
    378  110f		       a9 f5		      LDA	#>playerL043_0
    379  1111		       85 8b		      STA	player0pointerhi
    380  1113		       a9 09		      LDA	#9
    381  1115		       85 8e		      STA	player0height
    382  1117				   .
    383  1117							;
    384  1117
    385  1117				   .L044		;  player1:
    386  1117
    387  1117		       a2 8a		      LDX	#<playerL044_1
    388  1119		       86 8c		      STX	player1pointerlo
    389  111b		       a9 f5		      LDA	#>playerL044_1
    390  111d		       85 8d		      STA	player1pointerhi
    391  111f		       a9 09		      LDA	#9
    392  1121		       85 8f		      STA	player1height
    393  1123				   .
    394  1123							;
    395  1123
    396  1123				   .L045		;  player0color:
    397  1123
    398  1123		       a2 94		      LDX	#<playercolorL045_0
    399  1125		       86 90		      STX	player0color
    400  1127		       a9 f5		      LDA	#>playercolorL045_0
    401  1129		       85 91		      STA	player0color+1
    402  112b				   .
    403  112b							;
    404  112b
    405  112b				   .L046		;  player1color:
    406  112b
    407  112b		       a2 9f		      LDX	#<playercolorL046_1
    408  112d		       86 87		      STX	player1color
    409  112f		       a9 f5		      LDA	#>playercolorL046_1
    410  1131		       85 88		      STA	player1color+1
    411  1133				   .
    412  1133							;
    413  1133
    414  1133				   .gameloop
    415  1133							; gameloop
    416  1133
    417  1133				   .L047		;  f = f + 1
    418  1133
    419  1133		       e6 d9		      INC	f
    420  1135				   .
    421  1135							;
    422  1135
    423  1135				   .L048		;  if f  =  10 then player0:
    424  1135
    425  1135		       a5 d9		      LDA	f
    426  1137		       c9 0a		      CMP	#10
    427  1139		       d0 0c		      BNE	.skipL048
    428  113b				   .condpart2
    429  113b		       a2 a9		      LDX	#<player2then_0
    430  113d		       86 8a		      STX	player0pointerlo
    431  113f		       a9 f5		      LDA	#>player2then_0
    432  1141		       85 8b		      STA	player0pointerhi
    433  1143		       a9 09		      LDA	#9
    434  1145		       85 8e		      STA	player0height
    435  1147				   .skipL048
    436  1147				   .L049		;  if f  =  10 then player0color:
    437  1147
    438  1147		       a5 d9		      LDA	f
    439  1149		       c9 0a		      CMP	#10
    440  114b		       d0 08		      BNE	.skipL049
    441  114d				   .condpart3
    442  114d		       a2 b3		      LDX	#<playercolor3then_0
    443  114f		       86 90		      STX	player0color
    444  1151		       a9 f5		      LDA	#>playercolor3then_0
    445  1153		       85 91		      STA	player0color+1
    446  1155				   .skipL049
    447  1155				   .L050		;  if f  =  20 then player0:
    448  1155
    449  1155		       a5 d9		      LDA	f
    450  1157		       c9 14		      CMP	#20
    451  1159		       d0 0c		      BNE	.skipL050
    452  115b				   .condpart4
    453  115b		       a2 bd		      LDX	#<player4then_0
    454  115d		       86 8a		      STX	player0pointerlo
    455  115f		       a9 f5		      LDA	#>player4then_0
    456  1161		       85 8b		      STA	player0pointerhi
    457  1163		       a9 09		      LDA	#9
    458  1165		       85 8e		      STA	player0height
    459  1167				   .skipL050
    460  1167				   .L051		;  if f  =  20 then player0color:
    461  1167
    462  1167		       a5 d9		      LDA	f
    463  1169		       c9 14		      CMP	#20
    464  116b		       d0 08		      BNE	.skipL051
    465  116d				   .condpart5
    466  116d		       a2 c7		      LDX	#<playercolor5then_0
    467  116f		       86 90		      STX	player0color
    468  1171		       a9 f5		      LDA	#>playercolor5then_0
    469  1173		       85 91		      STA	player0color+1
    470  1175				   .skipL051
    471  1175				   .
    472  1175							;
    473  1175
    474  1175				   .L052		;  if f  =  30 then player0:
    475  1175
    476  1175		       a5 d9		      LDA	f
    477  1177		       c9 1e		      CMP	#30
    478  1179		       d0 0c		      BNE	.skipL052
    479  117b				   .condpart6
    480  117b		       a2 d1		      LDX	#<player6then_0
    481  117d		       86 8a		      STX	player0pointerlo
    482  117f		       a9 f5		      LDA	#>player6then_0
    483  1181		       85 8b		      STA	player0pointerhi
    484  1183		       a9 09		      LDA	#9
    485  1185		       85 8e		      STA	player0height
    486  1187				   .skipL052
    487  1187				   .
    488  1187							;
    489  1187
    490  1187				   .L053		;  player1y  =  player1y  +  1
    491  1187
    492  1187		       e6 86		      INC	player1y
    493  1189				   .L054		;  if f = 30 then f = 0
    494  1189
    495  1189		       a5 d9		      LDA	f
    496  118b		       c9 1e		      CMP	#30
    497  118d		       d0 04		      BNE	.skipL054
    498  118f				   .condpart7
    499  118f		       a9 00		      LDA	#0
    500  1191		       85 d9		      STA	f
    501  1193				   .skipL054
    502  1193				   .
    503  1193							;
    504  1193
    505  1193				   .L055		;  if joy0right then REFP0  =	0
    506  1193
    507  1193		       2c 80 02 	      bit	SWCHA
    508  1196		       30 04		      BMI	.skipL055
    509  1198				   .condpart8
    510  1198		       a9 00		      LDA	#0
    511  119a		       85 0b		      STA	REFP0
    512  119c				   .skipL055
    513  119c				   .L056		;  if joy0left then REFP0  =  8
    514  119c
    515  119c		       2c 80 02 	      bit	SWCHA
    516  119f		       70 04		      BVS	.skipL056
    517  11a1				   .condpart9
    518  11a1		       a9 08		      LDA	#8
    519  11a3		       85 0b		      STA	REFP0
    520  11a5				   .skipL056
    521  11a5				   .
    522  11a5							;
    523  11a5
    524  11a5				   .L057		;  drawscreen
    525  11a5
    526  11a5		       85 ee		      sta	temp7
    527  11a7		       a9 91		      lda	#>(ret_point3-1)
    528  11a9		       48		      pha
    529  11aa		       a9 bc		      lda	#<(ret_point3-1)
    530  11ac		       48		      pha
    531  11ad		       a9 f4		      lda	#>(drawscreen-1)
    532  11af		       48		      pha
    533  11b0		       a9 3b		      lda	#<(drawscreen-1)
    534  11b2		       48		      pha
    535  11b3		       a5 ee		      lda	temp7
    536  11b5		       48		      pha
    537  11b6		       8a		      txa
    538  11b7		       48		      pha
    539  11b8		       a2 04		      ldx	#4
    540  11ba		       4c eb ff 	      jmp	BS_jsr
    541  11bd				   ret_point3
    542  11bd				   .
    543  11bd							;
    544  11bd
    545  11bd				   .L058		;  if joy0right then player0x	=  player0x  +	1
    546  11bd
    547  11bd		       2c 80 02 	      bit	SWCHA
    548  11c0		       30 02		      BMI	.skipL058
    549  11c2				   .condpart10
    550  11c2		       e6 80		      INC	player0x
    551  11c4				   .skipL058
    552  11c4				   .L059		;  if joy0left then player0x  =  player0x  -  1
    553  11c4
    554  11c4		       2c 80 02 	      bit	SWCHA
    555  11c7		       70 02		      BVS	.skipL059
    556  11c9				   .condpart11
    557  11c9		       c6 80		      DEC	player0x
    558  11cb				   .skipL059
    559  11cb				   .L060		;  if joy0up then player0y  =	player0y  -  1
    560  11cb
    561  11cb		       a9 10		      lda	#$10
    562  11cd		       2c 80 02 	      bit	SWCHA
    563  11d0		       d0 02		      BNE	.skipL060
    564  11d2				   .condpart12
    565  11d2		       c6 85		      DEC	player0y
    566  11d4				   .skipL060
    567  11d4				   .L061		;  if joy0down then player0y  =  player0y  +  1
    568  11d4
    569  11d4		       a9 20		      lda	#$20
    570  11d6		       2c 80 02 	      bit	SWCHA
    571  11d9		       d0 02		      BNE	.skipL061
    572  11db				   .condpart13
    573  11db		       e6 85		      INC	player0y
    574  11dd				   .skipL061
    575  11dd				   .L062		;  if player0y  >=  80 then player0y  =  80
    576  11dd
    577  11dd		       a5 85		      LDA	player0y
    578  11df		       c9 50		      CMP	#80
    579  11e1		       90 04		      BCC	.skipL062
    580  11e3				   .condpart14
    581  11e3		       a9 50		      LDA	#80
    582  11e5		       85 85		      STA	player0y
    583  11e7				   .skipL062
    584  11e7				   .L063		;  if player0x  <= 1 then player0x  =	1
    585  11e7
    586  11e7		       a9 01		      LDA	#1
    587  11e9		       c5 80		      CMP	player0x
    588  11eb		       90 04		      BCC	.skipL063
    589  11ed				   .condpart15
    590  11ed		       a9 01		      LDA	#1
    591  11ef		       85 80		      STA	player0x
    592  11f1				   .skipL063
    593  11f1				   .L064		;  if player0x  >=  123 then player0x	=  123
    594  11f1
    595  11f1		       a5 80		      LDA	player0x
    596  11f3		       c9 7b		      CMP	#123
    597  11f5		       90 04		      BCC	.skipL064
    598  11f7				   .condpart16
    599  11f7		       a9 7b		      LDA	#123
    600  11f9		       85 80		      STA	player0x
    601  11fb				   .skipL064
    602  11fb				   .
    603  11fb							;
    604  11fb
    605  11fb				   .L065		;  if collision(player0,player1) then score  =  score	+  10  :  player1y  =  20  :  player1x	=  rand16 & 127  :  goto play_hit_sound
    606  11fb
    607  11fb		       24 07		      bit	CXPPMM
    608  11fd		       10 2d		      BPL	.skipL065
    609  11ff				   .condpart17
    610  11ff		       f8		      SED
    611  1200		       18		      CLC
    612  1201		       a5 95		      LDA	score+2
    613  1203		       69 10		      ADC	#$10
    614  1205		       85 95		      STA	score+2
    615  1207		       a5 94		      LDA	score+1
    616  1209		       69 00		      ADC	#$00
    617  120b		       85 94		      STA	score+1
    618  120d		       a5 93		      LDA	score
    619  120f		       69 00		      ADC	#$00
    620  1211		       85 93		      STA	score
    621  1213		       d8		      CLD
    622  1214		       a9 14		      LDA	#20
    623  1216		       85 86		      STA	player1y
    624  1218		       a5 a2		      lda	rand
    625  121a		       4a		      lsr
    626  121b					      ifconst	rand16
    627  121b		       26 e1		      rol	rand16
    628  121d					      endif
    629  121d		       90 02		      bcc	*+4
    630  121f		       49 b4		      eor	#$B4
    631  1221		       85 a2		      sta	rand
    632  1223					      ifconst	rand16
    633  1223		       45 e1		      eor	rand16
    634  1225					      endif
    635  1225		       29 7f		      AND	#127
    636  1227		       85 81		      STA	player1x
    637  1229		       4c 71 92 	      jmp	.play_hit_sound
    638  122c
    639  122c				   .skipL065
    640  122c				   .L066		;  if player1y  =  80	&&  !collision(player0,player1) then missed  =	missed	+  1  :  player1y  =  20  :  player1x  =  rand16 & 127 :  pfscore1  =  pfscore1 / 4 :  goto play_miss_sound
    641  122c
    642  122c		       a5 86		      LDA	player1y
    643  122e		       c9 50		      CMP	#80
    644  1230		       d0 24		      BNE	.skipL066
    645  1232				   .condpart18
    646  1232		       24 07		      bit	CXPPMM
    647  1234		       30 20		      BMI	.skip18then
    648  1236				   .condpart19
    649  1236		       e6 d7		      INC	missed
    650  1238		       a9 14		      LDA	#20
    651  123a		       85 86		      STA	player1y
    652  123c		       a5 a2		      lda	rand
    653  123e		       4a		      lsr
    654  123f					      ifconst	rand16
    655  123f		       26 e1		      rol	rand16
    656  1241					      endif
    657  1241		       90 02		      bcc	*+4
    658  1243		       49 b4		      eor	#$B4
    659  1245		       85 a2		      sta	rand
    660  1247					      ifconst	rand16
    661  1247		       45 e1		      eor	rand16
    662  1249					      endif
    663  1249		       29 7f		      AND	#127
    664  124b		       85 81		      STA	player1x
    665  124d		       a5 f2		      LDA	pfscore1
    666  124f		       4a		      lsr
    667  1250		       4a		      lsr
    668  1251		       85 f2		      STA	pfscore1
    669  1253		       4c 9d 92 	      jmp	.play_miss_sound
    670  1256
    671  1256				   .skip18then
    672  1256				   .skipL066
    673  1256				   .L067		;  if missed  =  4 then goto __Game_Over_Setup bank3
    674  1256
    675  1256		       a5 d7		      LDA	missed
    676  1258		       c9 04		      CMP	#4
    677  125a		       d0 12		      BNE	.skipL067
    678  125c				   .condpart20
    679  125c		       85 ee		      sta	temp7
    680  125e		       a9 cf		      lda	#>(.__Game_Over_Setup-1)
    681  1260		       48		      pha
    682  1261		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
    683  1263		       48		      pha
    684  1264		       a5 ee		      lda	temp7
    685  1266		       48		      pha
    686  1267		       8a		      txa
    687  1268		       48		      pha
    688  1269		       a2 03		      ldx	#3
    689  126b		       4c eb ff 	      jmp	BS_jsr
    690  126e				   .skipL067
    691  126e				   .
    692  126e							;
    693  126e
    694  126e				   .L068		;  goto gameloop
    695  126e
    696  126e		       4c 33 91 	      jmp	.gameloop
    697  1271
    698  1271				   .
    699  1271							;
    700  1271
    701  1271				   .play_hit_sound
    702  1271							; play_hit_sound
    703  1271
    704  1271				   .L069		;  if !_Ch0_Sound then _Ch0_Sound  =  1  :  _Ch0_Duration1  =	255  :	_Ch0_Duration2	=  255	:  _Ch0_Duration3  =  255  :  _Ch0_Duration4  =  255
    705  1271
    706  1271		       a5 e0		      LDA	_Ch0_Sound
    707  1273		       d0 0e		      BNE	.skipL069
    708  1275				   .condpart21
    709  1275		       a9 01		      LDA	#1
    710  1277		       85 e0		      STA	_Ch0_Sound
    711  1279		       a9 ff		      LDA	#255
    712  127b		       85 e4		      STA	_Ch0_Duration1
    713  127d		       85 e9		      STA	_Ch0_Duration2
    714  127f		       85 ea		      STA	_Ch0_Duration3
    715  1281		       85 eb		      STA	_Ch0_Duration4
    716  1283				   .skipL069
    717  1283				   .L070		;  AUDC0  =  4  :  AUDV0  =  15  :  AUDF0  =  24
    718  1283
    719  1283		       a9 04		      LDA	#4
    720  1285		       85 15		      STA	AUDC0
    721  1287		       a9 0f		      LDA	#15
    722  1289		       85 19		      STA	AUDV0
    723  128b		       a9 18		      LDA	#24
    724  128d		       85 17		      STA	AUDF0
    725  128f				   .L071		;  _Ch0_Duration1  =  _Ch0_Duration1  -  1
    726  128f
    727  128f		       c6 e4		      DEC	_Ch0_Duration1
    728  1291				   .L072		;  if _Ch0_Duration1  =  0 then goto minus_dur2
    729  1291
    730  1291		       a5 e4		      LDA	_Ch0_Duration1
    731  1293		       c9 00		      CMP	#0
    732  1295		       d0 03		      BNE	.skipL072
    733  1297				   .condpart22
    734  1297		       4c c9 92 	      jmp	.minus_dur2
    735  129a
    736  129a				   .skipL072
    737  129a				   .L073		;  goto play_hit_sound
    738  129a
    739  129a		       4c 71 92 	      jmp	.play_hit_sound
    740  129d
    741  129d				   .
    742  129d							;
    743  129d
    744  129d				   .play_miss_sound
    745  129d							; play_miss_sound
    746  129d
    747  129d				   .L074		;  if !_Ch0_Sound then _Ch0_Sound  =  1  :  _Ch0_Duration1  =	255  :	_Ch0_Duration2	=  255	:  _Ch0_Duration3  =  255 :  _Ch0_Duration4  =	255
    748  129d
    749  129d		       a5 e0		      LDA	_Ch0_Sound
    750  129f		       d0 0e		      BNE	.skipL074
    751  12a1				   .condpart23
    752  12a1		       a9 01		      LDA	#1
    753  12a3		       85 e0		      STA	_Ch0_Sound
    754  12a5		       a9 ff		      LDA	#255
    755  12a7		       85 e4		      STA	_Ch0_Duration1
    756  12a9		       85 e9		      STA	_Ch0_Duration2
    757  12ab		       85 ea		      STA	_Ch0_Duration3
    758  12ad		       85 eb		      STA	_Ch0_Duration4
    759  12af				   .skipL074
    760  12af				   .L075		;  AUDC0  =  12  :  AUDV0  =  15  :  AUDF0  =	26
    761  12af
    762  12af		       a9 0c		      LDA	#12
    763  12b1		       85 15		      STA	AUDC0
    764  12b3		       a9 0f		      LDA	#15
    765  12b5		       85 19		      STA	AUDV0
    766  12b7		       a9 1a		      LDA	#26
    767  12b9		       85 17		      STA	AUDF0
    768  12bb				   .L076		;  _Ch0_Duration1  =  _Ch0_Duration1  -  1
    769  12bb
    770  12bb		       c6 e4		      DEC	_Ch0_Duration1
    771  12bd				   .L077		;  if _Ch0_Duration1  =  0 then goto minus_dur2
    772  12bd
    773  12bd		       a5 e4		      LDA	_Ch0_Duration1
    774  12bf		       c9 00		      CMP	#0
    775  12c1		       d0 03		      BNE	.skipL077
    776  12c3				   .condpart24
    777  12c3		       4c c9 92 	      jmp	.minus_dur2
    778  12c6
    779  12c6				   .skipL077
    780  12c6				   .L078		;  goto play_miss_sound
    781  12c6
    782  12c6		       4c 9d 92 	      jmp	.play_miss_sound
    783  12c9
    784  12c9				   .
    785  12c9							;
    786  12c9
    787  12c9				   .minus_dur2
    788  12c9							; minus_dur2
    789  12c9
    790  12c9				   .L079		;  _Ch0_Duration2  =  _Ch0_Duration2  -  1
    791  12c9
    792  12c9		       c6 e9		      DEC	_Ch0_Duration2
    793  12cb				   .L080		;  if _Ch0_Duration2  =  0 then goto minus_dur3
    794  12cb
    795  12cb		       a5 e9		      LDA	_Ch0_Duration2
    796  12cd		       c9 00		      CMP	#0
    797  12cf		       d0 03		      BNE	.skipL080
    798  12d1				   .condpart25
    799  12d1		       4c d7 92 	      jmp	.minus_dur3
    800  12d4
    801  12d4				   .skipL080
    802  12d4				   .L081		;  goto minus_dur2
    803  12d4
    804  12d4		       4c c9 92 	      jmp	.minus_dur2
    805  12d7
    806  12d7				   .
    807  12d7							;
    808  12d7
    809  12d7				   .minus_dur3
    810  12d7							; minus_dur3
    811  12d7
    812  12d7				   .L082		;  _Ch0_Duration3  =  _Ch0_Duration3  -  1
    813  12d7
    814  12d7		       c6 ea		      DEC	_Ch0_Duration3
    815  12d9				   .L083		;  if _Ch0_Duration3  =  0 then goto minus_dur4
    816  12d9
    817  12d9		       a5 ea		      LDA	_Ch0_Duration3
    818  12db		       c9 00		      CMP	#0
    819  12dd		       d0 03		      BNE	.skipL083
    820  12df				   .condpart26
    821  12df		       4c e5 92 	      jmp	.minus_dur4
    822  12e2
    823  12e2				   .skipL083
    824  12e2				   .L084		;  goto minus_dur3
    825  12e2
    826  12e2		       4c d7 92 	      jmp	.minus_dur3
    827  12e5
    828  12e5				   .
    829  12e5							;
    830  12e5
    831  12e5				   .minus_dur4
    832  12e5							; minus_dur4
    833  12e5
    834  12e5				   .L085		;  _Ch0_Duration4  =  _Ch0_Duration4  -  1
    835  12e5
    836  12e5		       c6 eb		      DEC	_Ch0_Duration4
    837  12e7				   .L086		;  if _Ch0_Duration4  =  0 then goto __Clear_Ch_0
    838  12e7
    839  12e7		       a5 eb		      LDA	_Ch0_Duration4
    840  12e9		       c9 00		      CMP	#0
    841  12eb		       d0 03		      BNE	.skipL086
    842  12ed				   .condpart27
    843  12ed		       4c f3 92 	      jmp	.__Clear_Ch_0
    844  12f0
    845  12f0				   .skipL086
    846  12f0				   .L087		;  goto minus_dur4
    847  12f0
    848  12f0		       4c e5 92 	      jmp	.minus_dur4
    849  12f3
    850  12f3				   .
    851  12f3							;
    852  12f3
    853  12f3				   .__Clear_Ch_0
    854  12f3							; __Clear_Ch_0
    855  12f3
    856  12f3				   .L088		;  _Ch0_Sound	=  0  :  AUDV0	=  0
    857  12f3
    858  12f3		       a9 00		      LDA	#0
    859  12f5		       85 e0		      STA	_Ch0_Sound
    860  12f7		       85 19		      STA	AUDV0
    861  12f9				   .L089		;  goto gameloop
    862  12f9
    863  12f9		       4c 33 91 	      jmp	.gameloop
    864  12fc
    865  12fc				   .
    866  12fc							;
    867  12fc
    868  12fc				   .L090		;  bank 2
    869  12fc
    870  12fc					      if	ECHO1
      3288 bytes of ROM space left in bank 1
    871  12fc					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
    872  12fc					      endif
    873  12fc		       00 01	   ECHO1      =	1
    874  1fd4					      ORG	$1FF4-bscode_length
    875  1fd4					      RORG	$9FF4-bscode_length
    876  1fd4		       a2 ff	   start_bank1 ldx	#$ff
    877  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
    878  1fd6				  -	      stx	FASTFETCH
    879  1fd6					      endif
    880  1fd6		       9a		      txs
    881  1fd7				  -	      if	bankswitch == 64
    882  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
    883  1fd7					      else
    884  1fd7		       a9 f2		      lda	#>(start-1)
    885  1fd9					      endif
    886  1fd9		       48		      pha
    887  1fda		       a9 51		      lda	#<(start-1)
    888  1fdc		       48		      pha
    889  1fdd		       48		      pha
    890  1fde		       8a		      txa
    891  1fdf		       48		      pha
    892  1fe0		       ba		      tsx
    893  1fe1					      if	bankswitch != 64
    894  1fe1		       b5 04		      lda	4,x	; get high byte of return address
    895  1fe3		       2a		      rol
    896  1fe4		       2a		      rol
    897  1fe5		       2a		      rol
    898  1fe6		       2a		      rol
    899  1fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
    900  1fe9		       aa		      tax
    901  1fea		       e8		      inx
    902  1feb				  -	      else
    903  1feb				  -	      lda	4,x	; get high byte of return address
    904  1feb				  -	      tay
    905  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
    906  1feb				  -	      sta	4,x
    907  1feb				  -	      tya
    908  1feb				  -	      lsr
    909  1feb				  -	      lsr
    910  1feb				  -	      lsr
    911  1feb				  -	      lsr
    912  1feb				  -	      tax
    913  1feb				  -	      inx
    914  1feb					      endif
    915  1feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
    916  1fee		       68		      pla
    917  1fef		       aa		      tax
    918  1ff0		       68		      pla
    919  1ff1		       60		      rts
    920  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
    921  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
    922  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
    923  1ff2					      endif
    924  1ffc					      ORG	$1FFC
    925  1ffc					      RORG	$9FFC
    926  1ffc		       d4 9f		      .word.w	(start_bank1 & $ffff)
    927  1ffe		       d4 9f		      .word.w	(start_bank1 & $ffff)
    928  2000					      ORG	$2000
    929  2000					      RORG	$B000
    930  2000				   .L091		;  _Bit0_Reset_Restrainer{0}  =  1
    931  2000
    932  2000		       a5 ec		      LDA	_Bit0_Reset_Restrainer
    933  2002		       09 01		      ORA	#1
    934  2004		       85 ec		      STA	_Bit0_Reset_Restrainer
    935  2006				   .L092		;  asm
    936  2006
------- FILE titlescreen/asm/titlescreen.asm LEVEL 2 PASS 2
      0  2006					      include	"titlescreen/asm/titlescreen.asm"
      1  2006
------- FILE titlescreen/asm/layoutmacros.asm LEVEL 3 PASS 2
      0  2006					      include	"titlescreen/asm/layoutmacros.asm"
      1  2006
      2  2006							; the macro's used in the "titlescreen_layout.asm" file
      3  2006
      4  2006					      MAC	draw_96x2_1
      5  2006				   mk_96x2_1_on =	1
      6  2006					      jsr	draw_bmp_96x2_1
      7  2006					      ENDM
      8  2006
      9  2006					      MAC	draw_96x2_2
     10  2006				   mk_96x2_2_on =	1
     11  2006					      jsr	draw_bmp_96x2_2
     12  2006					      ENDM
     13  2006
     14  2006					      MAC	draw_96x2_3
     15  2006				   mk_96x2_3_on =	1
     16  2006					      jsr	draw_bmp_96x2_3
     17  2006					      ENDM
     18  2006
     19  2006					      MAC	draw_96x2_4
     20  2006				   mk_96x2_4_on =	1
     21  2006					      jsr	draw_bmp_96x2_4
     22  2006					      ENDM
     23  2006
     24  2006					      MAC	draw_96x2_5
     25  2006				   mk_96x2_5_on =	1
     26  2006					      jsr	draw_bmp_96x2_5
     27  2006					      ENDM
     28  2006
     29  2006					      MAC	draw_96x2_6
     30  2006				   mk_96x2_6_on =	1
     31  2006					      jsr	draw_bmp_96x2_6
     32  2006					      ENDM
     33  2006
     34  2006					      MAC	draw_96x2_7
     35  2006				   mk_96x2_7_on =	1
     36  2006					      jsr	draw_bmp_96x2_7
     37  2006					      ENDM
     38  2006
     39  2006					      MAC	draw_96x2_8
     40  2006				   mk_96x2_8_on =	1
     41  2006					      jsr	draw_bmp_96x2_8
     42  2006					      ENDM
     43  2006
     44  2006					      MAC	draw_48x1_1
     45  2006				   mk_48x1_X_on =	1
     46  2006				   mk_48x1_1_on =	1
     47  2006					      jsr	draw_bmp_48x1_1
     48  2006					      ENDM
     49  2006
     50  2006					      MAC	draw_48x1_2
     51  2006				   mk_48x1_X_on =	1
     52  2006				   mk_48x1_2_on =	1
     53  2006					      jsr	draw_bmp_48x1_2
     54  2006					      ENDM
     55  2006
     56  2006					      MAC	draw_48x1_3
     57  2006				   mk_48x1_X_on =	1
     58  2006				   mk_48x1_3_on =	1
     59  2006					      jsr	draw_bmp_48x1_3
     60  2006					      ENDM
     61  2006
     62  2006					      MAC	draw_48x1_4
     63  2006				   mk_48x1_X_on =	1
     64  2006				   mk_48x1_4_on =	1
     65  2006					      jsr	draw_bmp_48x1_4
     66  2006					      ENDM
     67  2006
     68  2006					      MAC	draw_48x1_5
     69  2006				   mk_48x1_X_on =	1
     70  2006				   mk_48x1_5_on =	1
     71  2006					      jsr	draw_bmp_48x1_5
     72  2006					      ENDM
     73  2006
     74  2006					      MAC	draw_48x1_6
     75  2006				   mk_48x1_X_on =	1
     76  2006				   mk_48x1_6_on =	1
     77  2006					      jsr	draw_bmp_48x1_6
     78  2006					      ENDM
     79  2006
     80  2006					      MAC	draw_48x1_7
     81  2006				   mk_48x1_X_on =	1
     82  2006				   mk_48x1_7_on =	1
     83  2006					      jsr	draw_bmp_48x1_7
     84  2006					      ENDM
     85  2006
     86  2006					      MAC	draw_48x1_8
     87  2006				   mk_48x1_X_on =	1
     88  2006				   mk_48x1_8_on =	1
     89  2006					      jsr	draw_bmp_48x1_8
     90  2006					      ENDM
     91  2006
     92  2006
     93  2006					      MAC	draw_48x2_1
     94  2006				   mk_48x2_X_on =	1
     95  2006				   mk_48x2_1_on =	1
     96  2006					      jsr	draw_bmp_48x2_1
     97  2006					      ENDM
     98  2006
     99  2006					      MAC	draw_48x2_2
    100  2006				   mk_48x2_X_on =	1
    101  2006				   mk_48x2_2_on =	1
    102  2006					      jsr	draw_bmp_48x2_2
    103  2006					      ENDM
    104  2006
    105  2006					      MAC	draw_48x2_3
    106  2006				   mk_48x2_X_on =	1
    107  2006				   mk_48x2_3_on =	1
    108  2006					      jsr	draw_bmp_48x2_3
    109  2006					      ENDM
    110  2006
    111  2006					      MAC	draw_48x2_4
    112  2006				   mk_48x2_X_on =	1
    113  2006				   mk_48x2_4_on =	1
    114  2006					      jsr	draw_bmp_48x2_4
    115  2006					      ENDM
    116  2006
    117  2006					      MAC	draw_48x2_5
    118  2006				   mk_48x2_X_on =	1
    119  2006				   mk_48x2_5_on =	1
    120  2006					      jsr	draw_bmp_48x2_5
    121  2006					      ENDM
    122  2006
    123  2006					      MAC	draw_48x2_6
    124  2006				   mk_48x2_X_on =	1
    125  2006				   mk_48x2_6_on =	1
    126  2006					      jsr	draw_bmp_48x2_6
    127  2006					      ENDM
    128  2006
    129  2006					      MAC	draw_48x2_7
    130  2006				   mk_48x2_X_on =	1
    131  2006				   mk_48x2_7_on =	1
    132  2006					      jsr	draw_bmp_48x2_7
    133  2006					      ENDM
    134  2006
    135  2006					      MAC	draw_48x2_8
    136  2006				   mk_48x2_X_on =	1
    137  2006				   mk_48x2_8_on =	1
    138  2006					      jsr	draw_bmp_48x2_8
    139  2006					      ENDM
    140  2006
    141  2006					      MAC	draw_player
    142  2006				   mk_player_on =	1
    143  2006					      jsr	draw_player_display
    144  2006					      ENDM
    145  2006
    146  2006					      MAC	draw_score
    147  2006				   mk_score_on =	1
    148  2006				   mk_48x1_X_on =	1
    149  2006					      jsr	draw_score_display
    150  2006					      ENDM
    151  2006
    152  2006					      MAC	draw_gameselect
    153  2006				   mk_gameselect_on =	1
    154  2006				   mk_48x1_X_on =	1
    155  2006					      jsr	draw_gameselect_display
    156  2006					      ENDM
    157  2006
    158  2006					      MAC	draw_space
    159  2006					      ldy	#{1}
    160  2006				   .loop
    161  2006					      sta	WSYNC
    162  2006					      dey
    163  2006					      bne	.loop
    164  2006					      ENDM
    165  2006
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/asm/dpcfix.asm LEVEL 3 PASS 2
      0  2006					      include	"titlescreen/asm/dpcfix.asm"
      1  2006							; reassign variables that DPC+ doesn't have
      2  2006
      3  2006				  -	      ifnconst	aux2
      4  2006				  -aux2       =	player2x
      5  2006					      endif
      6  2006				  -	      ifnconst	aux4
      7  2006				  -aux4       =	player4x
      8  2006					      endif
      9  2006				  -	      ifnconst	aux5
     10  2006				  -aux5       =	player5x
     11  2006					      endif
     12  2006				  -	      ifnconst	aux6
     13  2006				  -aux6       =	player6x
     14  2006					      endif
     15  2006
     16  2006				  -	      ifnconst	player0pointer
     17  2006				  -player0pointer =	player2y
     18  2006					      endif
     19  2006				  -	      ifnconst	player1pointer
     20  2006				  -player1pointer =	player2height	; to player3height
     21  2006					      endif
     22  2006				  -	      ifnconst	player1color
     23  2006				  -player1color =	player4height	; to player5height
     24  2006					      endif
     25  2006				  -	      ifnconst	scorepointers
     26  2006				  -scorepointers =	player6height	; to NUSIZ8
     27  2006					      endif
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/titlescreen_layout.asm LEVEL 3 PASS 2
      0  2006					      include	"titlescreen/titlescreen_layout.asm"
      1  2006					      MAC	titlescreenlayout
      2  2006					      draw_96x2_2
      3  2006					      draw_space	25
      4  2006					      draw_96x2_3
      5  2006					      ENDM
      6  2006
------- FILE titlescreen/asm/titlescreen.asm
      5  2006
      6  2006				   .titledrawscreen
      7  2006				   title_eat_overscan
      8  2006							;bB runs in overscan. Wait for the overscan to run out...
      9  2006		       18		      clc
     10  2007		       ad 84 02 	      lda	INTIM
     11  200a		       30 fa		      bmi	title_eat_overscan
     12  200c		       4c 0f b0 	      jmp	title_do_vertical_sync
     13  200f
     14  200f				   title_do_vertical_sync
     15  200f		       a9 02		      lda	#2
     16  2011		       85 02		      sta	WSYNC	;one line with VSYNC
     17  2013		       85 00		      sta	VSYNC	;enable VSYNC
     18  2015		       85 02		      sta	WSYNC	;one line with VSYNC
     19  2017		       85 02		      sta	WSYNC	;one line with VSYNC
     20  2019		       a9 00		      lda	#0
     21  201b		       85 02		      sta	WSYNC	;one line with VSYNC
     22  201d		       85 00		      sta	VSYNC	;turn off VSYNC
     23  201f
     24  201f							;lda #42+128
     25  201f				  -	      ifnconst	vblank_time
     26  201f				  -	      lda	#42+128
     27  201f					      else
     28  201f		       a9 ab		      lda	#vblank_time+128
     29  2021					      endif
     30  2021
     31  2021		       8d 96 02 	      sta	TIM64T
     32  2024
     33  2024		       00 82	   titleframe =	missile0x
     34  2024		       e6 82		      inc	titleframe	; increment the frame counter
     35  2026
     36  2026				  -	      ifconst	.title_vblank
     37  2026				  -	      jsr	.title_vblank
     38  2026					      endif
     39  2026
     40  2026				   title_vblank_loop
     41  2026		       ad 84 02 	      lda	INTIM
     42  2029		       30 fb		      bmi	title_vblank_loop
     43  202b		       a9 00		      lda	#0
     44  202d		       85 02		      sta	WSYNC
     45  202f		       85 01		      sta	VBLANK
     46  2031		       85 1d		      sta	ENAM0
     47  2033		       85 1f		      sta	ENABL
     48  2035
     49  2035				   title_playfield
     50  2035
     51  2035							; ======== BEGIN of the custom kernel!!!!! All of the work is done in the playfield.
     52  2035
     53  2035		       a9 e6		      lda	#230
     54  2037		       8d 96 02 	      sta	TIM64T
     55  203a
     56  203a		       a9 01		      lda	#1
     57  203c		       85 0a		      sta	CTRLPF
     58  203e		       18		      clc
     59  203f
     60  203f		       a9 00		      lda	#0
     61  2041		       85 0b		      sta	REFP0
     62  2043		       85 0c		      sta	REFP1
     63  2045		       85 02		      sta	WSYNC
     64  2047		       ad 84 b0 	      lda	titlescreencolor
     65  204a		       85 09		      sta	COLUBK
     66  204c
      0  204c					      titlescreenlayout
      0  204c					      draw_96x2_2
      1  204c		       00 01	   mk_96x2_2_on =	1
      2  204c		       20 85 b0 	      jsr	draw_bmp_96x2_2
      0  204f					      draw_space	25
      1  204f		       a0 19		      ldy	#25
      2  2051				   .loop
      3  2051		       85 02		      sta	WSYNC
      4  2053		       88		      dey
      5  2054		       d0 fb		      bne	.loop
      0  2056					      draw_96x2_3
      1  2056		       00 01	   mk_96x2_3_on =	1
      2  2056		       20 71 b2 	      jsr	draw_bmp_96x2_3
     68  2059
     69  2059		       4c 71 b4 	      jmp	PFWAIT	; kernel is done. Finish off the screen
     70  205c
------- FILE titlescreen/asm/position48.asm LEVEL 3 PASS 2
      0  205c					      include	"titlescreen/asm/position48.asm"
      1  205c
      2  205c				   position48
      3  205c
      4  205c							;postion P0 and P1
      5  205c
      6  205c		       85 02		      sta	WSYNC
      7  205e
      8  205e		       a9 90		      lda	#$90	;2
      9  2060		       85 20		      sta	HMP0	;3
     10  2062		       a9 a0		      lda	#$A0	;2
     11  2064		       85 21		      sta	HMP1	;3
     12  2066
     13  2066		       e6 9c		      inc	temp1
     14  2068		       c6 9c		      dec	temp1
     15  206a		       e6 9c		      inc	temp1
     16  206c		       c6 9c		      dec	temp1
     17  206e		       e6 9c		      inc	temp1
      0  2070					      sleep	2
      1  2070				   .CYCLES    SET	2
      2  2070
      3  2070				  -	      IF	.CYCLES < 2
      4  2070				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2070				  -	      ERR
      6  2070					      ENDIF
      7  2070
      8  2070				  -	      IF	.CYCLES & 1
      9  2070				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2070				  -	      nop	0
     11  2070				  -	      ELSE
     12  2070				  -	      bit	VSYNC
     13  2070				  -	      ENDIF
     14  2070				  -.CYCLES    SET	.CYCLES - 3
     15  2070					      ENDIF
     16  2070
     17  2070					      REPEAT	.CYCLES / 2
     18  2070		       ea		      nop
     19  2071					      REPEND
     19  2071		       85 10		      sta	RESP0	;  +3
     20  2073		       85 11		      sta	RESP1	;  +3
     21  2075		       c6 9c		      dec	temp1	;  +5
     22  2077		       e6 9c		      inc	temp1	;  +5
     23  2079		       c6 9c		      dec	temp1	;  +5
     24  207b		       e6 9c		      inc	temp1	;  +5
     25  207d		       c6 9c		      dec	temp1	;  +5
      0  207f					      sleep	3
      1  207f				   .CYCLES    SET	3
      2  207f
      3  207f				  -	      IF	.CYCLES < 2
      4  207f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  207f				  -	      ERR
      6  207f					      ENDIF
      7  207f
      8  207f					      IF	.CYCLES & 1
      9  207f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  207f		       04 00		      nop	0
     11  2081				  -	      ELSE
     12  2081				  -	      bit	VSYNC
     13  2081					      ENDIF
     14  2081				   .CYCLES    SET	.CYCLES - 3
     15  2081					      ENDIF
     16  2081
     17  2081				  -	      REPEAT	.CYCLES / 2
     18  2081				  -	      nop
     19  2081					      REPEND
     27  2081		       85 2a		      sta	HMOVE	; +76
     28  2083		       60		      RTS
     29  2084
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/titlescreen_color.asm LEVEL 3 PASS 2
      0  2084					      include	"titlescreen/titlescreen_color.asm"
      1  2084
      2  2084							; This is where the titlescreen background color gets set. 
      3  2084							; You can also do a "dim titlescreencolor=[letter]" in bB
      4  2084							; if you want to change the color on the fly.
      5  2084
      6  2084				  -	      ifnconst	titlescreencolor
      7  2084				  -titlescreencolor
      8  2084					      endif
      9  2084		       00		      .byte.b	$00
     10  2085
------- FILE titlescreen/asm/titlescreen.asm
     73  2085
     74  2085				  -	      ifconst	mk_48x1_1_on
     75  2085				  -	      include	"titlescreen/asm/48x1_1_kernel.asm"
     76  2085					      endif		;mk_48x1_1_on
     77  2085
     78  2085				  -	      ifconst	mk_48x1_2_on
     79  2085				  -	      include	"titlescreen/asm/48x1_2_kernel.asm"
     80  2085					      endif		;mk_48x1_2_on
     81  2085
     82  2085				  -	      ifconst	mk_48x1_3_on
     83  2085				  -	      include	"titlescreen/asm/48x1_3_kernel.asm"
     84  2085					      endif		;mk_48x1_3_on
     85  2085
     86  2085				  -	      ifconst	mk_48x1_4_on
     87  2085				  -	      include	"titlescreen/asm/48x1_4_kernel.asm"
     88  2085					      endif		;mk_48x1_4_on
     89  2085
     90  2085				  -	      ifconst	mk_48x1_5_on
     91  2085				  -	      include	"titlescreen/asm/48x1_5_kernel.asm"
     92  2085					      endif		;mk_48x1_5_on
     93  2085
     94  2085				  -	      ifconst	mk_48x1_6_on
     95  2085				  -	      include	"titlescreen/asm/48x1_6_kernel.asm"
     96  2085					      endif		;mk_48x1_6_on
     97  2085
     98  2085				  -	      ifconst	mk_48x1_7_on
     99  2085				  -	      include	"titlescreen/asm/48x1_7_kernel.asm"
    100  2085					      endif		;mk_48x1_7_on
    101  2085
    102  2085				  -	      ifconst	mk_48x1_8_on
    103  2085				  -	      include	"titlescreen/asm/48x1_8_kernel.asm"
    104  2085					      endif		;mk_48x1_8_on
    105  2085
    106  2085				  -	      ifconst	mk_48x2_1_on
    107  2085				  -	      include	"titlescreen/asm/48x2_1_kernel.asm"
    108  2085					      endif		;mk_48x2_1_on
    109  2085
    110  2085				  -	      ifconst	mk_48x2_2_on
    111  2085				  -	      include	"titlescreen/asm/48x2_2_kernel.asm"
    112  2085					      endif		;mk_48x2_2_on
    113  2085
    114  2085				  -	      ifconst	mk_48x2_3_on
    115  2085				  -	      include	"titlescreen/asm/48x2_3_kernel.asm"
    116  2085					      endif		;mk_48x2_3_on
    117  2085
    118  2085				  -	      ifconst	mk_48x2_4_on
    119  2085				  -	      include	"titlescreen/asm/48x2_4_kernel.asm"
    120  2085					      endif		;mk_48x2_4_on
    121  2085
    122  2085				  -	      ifconst	mk_48x2_5_on
    123  2085				  -	      include	"titlescreen/asm/48x2_5_kernel.asm"
    124  2085					      endif		;mk_48x2_5_on
    125  2085
    126  2085				  -	      ifconst	mk_48x2_6_on
    127  2085				  -	      include	"titlescreen/asm/48x2_6_kernel.asm"
    128  2085					      endif		;mk_48x2_6_on
    129  2085
    130  2085				  -	      ifconst	mk_48x2_7_on
    131  2085				  -	      include	"titlescreen/asm/48x2_7_kernel.asm"
    132  2085					      endif		;mk_48x2_7_on
    133  2085
    134  2085				  -	      ifconst	mk_48x2_8_on
    135  2085				  -	      include	"titlescreen/asm/48x2_8_kernel.asm"
    136  2085					      endif		;mk_48x2_8_on
    137  2085
    138  2085				  -	      ifconst	mk_48x1_X_on
    139  2085				  -	      include	"titlescreen/asm/48x1_X_kernel.asm"
    140  2085					      endif		;mk_48x1_X_on
    141  2085
    142  2085				  -	      ifconst	mk_48x2_X_on
    143  2085				  -	      include	"titlescreen/asm/48x2_X_kernel.asm"
    144  2085					      endif		;mk_48x2_X_on
    145  2085
    146  2085
    147  2085				  -	      ifconst	mk_96x2_1_on
    148  2085				  -	      include	"titlescreen/asm/96x2_1_kernel.asm"
    149  2085					      endif		;mk_96x2_1_on
    150  2085
    151  2085					      ifconst	mk_96x2_2_on
------- FILE titlescreen/asm/96x2_2_kernel.asm LEVEL 3 PASS 2
      0  2085					      include	"titlescreen/asm/96x2_2_kernel.asm"
      1  2085				   draw_bmp_96x2_2
      2  2085
      3  2085				  -	      ifconst	bmp_96x2_2_index
      4  2085				  -	      lda	#(bmp_96x2_2_height-1)
      5  2085				  -	      sec
      6  2085				  -	      sbc	bmp_96x2_2_index
      7  2085				  -	      tay
      8  2085				  -	      sbc	#bmp_96x2_2_window
      9  2085				  -	      sta	temp1
     10  2085					      else
     11  2085		       a0 27		      ldy	#(bmp_96x2_2_window-1)
     12  2087		       a9 ff		      lda	#255
     13  2089		       85 9c		      sta	temp1
     14  208b					      endif
     15  208b
     16  208b		       a9 03		      lda	#3
     17  208d		       85 04		      sta	NUSIZ0	;3=Player and Missile are drawn twice 32 clocks apart
     18  208f		       85 05		      sta	NUSIZ1	;3=Player and Missile are drawn twice 32 clocks apart
     19  2091		       a9 00		      lda	#0
     20  2093
     21  2093		       b9 87 b4 	      lda	bmp_96x2_2_colors,y	;4
     22  2096				  -	      ifconst	bmp_96x2_2_fade
     23  2096				  -	      and	bmp_96x2_2_fade
     24  2096					      endif
     25  2096		       85 06		      sta	COLUP0	;3
     26  2098		       85 07		      sta	COLUP1	;3
     27  209a		       85 2b		      sta	HMCLR	;3
     28  209c
     29  209c		       a5 82		      lda	titleframe
     30  209e		       29 01		      and	#1
     31  20a0		       f0 03		      beq	jmp_pf96x2_2_frame0
     32  20a2		       4c 70 b1 	      jmp	pf96x2_2_frame1
     33  20a5				   jmp_pf96x2_2_frame0
     34  20a5		       4c a8 b0 	      jmp	pf96x2_2_frame0
     35  20a8
     36  20a8				   pf96x2_2_frame0
     37  20a8							;postion P0 and P1
     38  20a8		       85 02		      sta	WSYNC
     39  20aa		       a9 e0		      lda	#%11100000
     40  20ac		       85 20		      sta	HMP0
     41  20ae		       a9 10		      lda	#%00010000
     42  20b0		       85 21		      sta	HMP1
     43  20b2		       85 02		      sta	WSYNC
      0  20b4					      sleep	28
      1  20b4				   .CYCLES    SET	28
      2  20b4
      3  20b4				  -	      IF	.CYCLES < 2
      4  20b4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20b4				  -	      ERR
      6  20b4					      ENDIF
      7  20b4
      8  20b4				  -	      IF	.CYCLES & 1
      9  20b4				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20b4				  -	      nop	0
     11  20b4				  -	      ELSE
     12  20b4				  -	      bit	VSYNC
     13  20b4				  -	      ENDIF
     14  20b4				  -.CYCLES    SET	.CYCLES - 3
     15  20b4					      ENDIF
     16  20b4
     17  20b4					      REPEAT	.CYCLES / 2
     18  20b4		       ea		      nop
     17  20b4					      REPEND
     18  20b5		       ea		      nop
     17  20b5					      REPEND
     18  20b6		       ea		      nop
     17  20b6					      REPEND
     18  20b7		       ea		      nop
     17  20b7					      REPEND
     18  20b8		       ea		      nop
     17  20b8					      REPEND
     18  20b9		       ea		      nop
     17  20b9					      REPEND
     18  20ba		       ea		      nop
     17  20ba					      REPEND
     18  20bb		       ea		      nop
     17  20bb					      REPEND
     18  20bc		       ea		      nop
     17  20bc					      REPEND
     18  20bd		       ea		      nop
     17  20bd					      REPEND
     18  20be		       ea		      nop
     17  20be					      REPEND
     18  20bf		       ea		      nop
     17  20bf					      REPEND
     18  20c0		       ea		      nop
     17  20c0					      REPEND
     18  20c1		       ea		      nop
     19  20c2					      REPEND
     45  20c2		       85 10		      sta	RESP0
      0  20c4					      sleep	14
      1  20c4				   .CYCLES    SET	14
      2  20c4
      3  20c4				  -	      IF	.CYCLES < 2
      4  20c4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20c4				  -	      ERR
      6  20c4					      ENDIF
      7  20c4
      8  20c4				  -	      IF	.CYCLES & 1
      9  20c4				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20c4				  -	      nop	0
     11  20c4				  -	      ELSE
     12  20c4				  -	      bit	VSYNC
     13  20c4				  -	      ENDIF
     14  20c4				  -.CYCLES    SET	.CYCLES - 3
     15  20c4					      ENDIF
     16  20c4
     17  20c4					      REPEAT	.CYCLES / 2
     18  20c4		       ea		      nop
     17  20c4					      REPEND
     18  20c5		       ea		      nop
     17  20c5					      REPEND
     18  20c6		       ea		      nop
     17  20c6					      REPEND
     18  20c7		       ea		      nop
     17  20c7					      REPEND
     18  20c8		       ea		      nop
     17  20c8					      REPEND
     18  20c9		       ea		      nop
     17  20c9					      REPEND
     18  20ca		       ea		      nop
     19  20cb					      REPEND
     47  20cb		       85 11		      sta	RESP1
     48  20cd		       85 02		      sta	WSYNC
     49  20cf		       85 2a		      sta	HMOVE
     50  20d1
     51  20d1		       85 02		      sta	WSYNC
     52  20d3		       85 2b		      sta	HMCLR
     53  20d5		       85 02		      sta	WSYNC
     54  20d7
      0  20d7					      sleep	4
      1  20d7				   .CYCLES    SET	4
      2  20d7
      3  20d7				  -	      IF	.CYCLES < 2
      4  20d7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20d7				  -	      ERR
      6  20d7					      ENDIF
      7  20d7
      8  20d7				  -	      IF	.CYCLES & 1
      9  20d7				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20d7				  -	      nop	0
     11  20d7				  -	      ELSE
     12  20d7				  -	      bit	VSYNC
     13  20d7				  -	      ENDIF
     14  20d7				  -.CYCLES    SET	.CYCLES - 3
     15  20d7					      ENDIF
     16  20d7
     17  20d7					      REPEAT	.CYCLES / 2
     18  20d7		       ea		      nop
     17  20d7					      REPEND
     18  20d8		       ea		      nop
     19  20d9					      REPEND
     56  20d9		       4c 00 b1 	      jmp	pfline_96x2_2_frame0
     57  20dc							;align so our branch doesn't unexpectedly cross a page...
     58  20dc					      if	>. != >[.+$70]
     59  2100		       00 00 00 00*	      align	256
     60  2100					      endif
     61  2100
     62  2100				   pfline_96x2_2_frame0
     63  2100		       a9 80		      lda	#$80	;2
     64  2102		       85 20		      sta	HMP0	;3
     65  2104		       85 21		      sta	HMP1	;3
     66  2106
     67  2106		       b9 a0 b5 	      lda	bmp_96x2_2_06,y	;4
     68  2109		       85 1c		      sta	GRP1	;3
     69  210b
     70  210b		       b9 af b4 	      lda	bmp_96x2_2_00,y
     71  210e		       85 1b		      sta	GRP0
     72  2110		       b9 00 b5 	      lda	bmp_96x2_2_02,y
     73  2113		       85 1b		      sta	GRP0
     74  2115		       b9 50 b5 	      lda	bmp_96x2_2_04,y
     75  2118		       85 1b		      sta	GRP0
     76  211a
      0  211a					      sleep	2
      1  211a				   .CYCLES    SET	2
      2  211a
      3  211a				  -	      IF	.CYCLES < 2
      4  211a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  211a				  -	      ERR
      6  211a					      ENDIF
      7  211a
      8  211a				  -	      IF	.CYCLES & 1
      9  211a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  211a				  -	      nop	0
     11  211a				  -	      ELSE
     12  211a				  -	      bit	VSYNC
     13  211a				  -	      ENDIF
     14  211a				  -.CYCLES    SET	.CYCLES - 3
     15  211a					      ENDIF
     16  211a
     17  211a					      REPEAT	.CYCLES / 2
     18  211a		       ea		      nop
     19  211b					      REPEND
     78  211b
     79  211b		       b9 00 b6 	      lda	bmp_96x2_2_08,y
     80  211e		       85 1c		      sta	GRP1
     81  2120		       b9 50 b6 	      lda	bmp_96x2_2_10,y
     82  2123		       85 1c		      sta	GRP1
     83  2125
     84  2125		       b9 d7 b4 	      lda	bmp_96x2_2_01,y
     85  2128		       85 1b		      sta	GRP0
     86  212a
      0  212a					      sleep	8
      1  212a				   .CYCLES    SET	8
      2  212a
      3  212a				  -	      IF	.CYCLES < 2
      4  212a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  212a				  -	      ERR
      6  212a					      ENDIF
      7  212a
      8  212a				  -	      IF	.CYCLES & 1
      9  212a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  212a				  -	      nop	0
     11  212a				  -	      ELSE
     12  212a				  -	      bit	VSYNC
     13  212a				  -	      ENDIF
     14  212a				  -.CYCLES    SET	.CYCLES - 3
     15  212a					      ENDIF
     16  212a
     17  212a					      REPEAT	.CYCLES / 2
     18  212a		       ea		      nop
     17  212a					      REPEND
     18  212b		       ea		      nop
     17  212b					      REPEND
     18  212c		       ea		      nop
     17  212c					      REPEND
     18  212d		       ea		      nop
     19  212e					      REPEND
     88  212e
     89  212e							;sta WSYNC	;=0
     90  212e		       85 2a		      sta	HMOVE	;3 - NORMAL HMOVE
     91  2130
     92  2130		       b9 86 b4 	      lda	bmp_96x2_2_colors-1,y	;4 - get the title color early and store it for later
     93  2133				  -	      ifconst	bmp_96x2_2_fade
     94  2133				  -	      and	bmp_96x2_2_fade
     95  2133					      else
      0  2133					      sleep	3
      1  2133				   .CYCLES    SET	3
      2  2133
      3  2133				  -	      IF	.CYCLES < 2
      4  2133				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2133				  -	      ERR
      6  2133					      ENDIF
      7  2133
      8  2133					      IF	.CYCLES & 1
      9  2133					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2133		       04 00		      nop	0
     11  2135				  -	      ELSE
     12  2135				  -	      bit	VSYNC
     13  2135					      ENDIF
     14  2135				   .CYCLES    SET	.CYCLES - 3
     15  2135					      ENDIF
     16  2135
     17  2135				  -	      REPEAT	.CYCLES / 2
     18  2135				  -	      nop
     19  2135					      REPEND
     97  2135					      endif
     98  2135		       aa		      tax
     99  2136
    100  2136		       a9 00		      lda	#0	;2
    101  2138		       85 20		      sta	HMP0	;3
    102  213a		       85 21		      sta	HMP1	;3
    103  213c
      0  213c					      sleep	7
      1  213c				   .CYCLES    SET	7
      2  213c
      3  213c				  -	      IF	.CYCLES < 2
      4  213c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  213c				  -	      ERR
      6  213c					      ENDIF
      7  213c
      8  213c					      IF	.CYCLES & 1
      9  213c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  213c		       04 00		      nop	0
     11  213e				  -	      ELSE
     12  213e				  -	      bit	VSYNC
     13  213e					      ENDIF
     14  213e				   .CYCLES    SET	.CYCLES - 3
     15  213e					      ENDIF
     16  213e
     17  213e					      REPEAT	.CYCLES / 2
     18  213e		       ea		      nop
     17  213e					      REPEND
     18  213f		       ea		      nop
     19  2140					      REPEND
    105  2140
    106  2140		       b9 c8 b5 	      lda	bmp_96x2_2_07,y
    107  2143		       85 1c		      sta	GRP1
    108  2145
    109  2145		       b9 28 b5 	      lda	bmp_96x2_2_03,y	;5
    110  2148		       85 1b		      sta	GRP0	;3 =  8
    111  214a		       b9 78 b5 	      lda	bmp_96x2_2_05,y	;5
    112  214d		       85 1b		      sta	GRP0	;3 =  8
    113  214f
      0  214f					      sleep	2
      1  214f				   .CYCLES    SET	2
      2  214f
      3  214f				  -	      IF	.CYCLES < 2
      4  214f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  214f				  -	      ERR
      6  214f					      ENDIF
      7  214f
      8  214f				  -	      IF	.CYCLES & 1
      9  214f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  214f				  -	      nop	0
     11  214f				  -	      ELSE
     12  214f				  -	      bit	VSYNC
     13  214f				  -	      ENDIF
     14  214f				  -.CYCLES    SET	.CYCLES - 3
     15  214f					      ENDIF
     16  214f
     17  214f					      REPEAT	.CYCLES / 2
     18  214f		       ea		      nop
     19  2150					      REPEND
    115  2150
    116  2150		       b9 28 b6 	      lda	bmp_96x2_2_09,y	;5
    117  2153		       85 1c		      sta	GRP1	;3 =  8
    118  2155		       b9 78 b6 	      lda	bmp_96x2_2_11,y	;5
    119  2158		       85 1c		      sta	GRP1	;3 =  8
    120  215a
      0  215a					      sleep	2
      1  215a				   .CYCLES    SET	2
      2  215a
      3  215a				  -	      IF	.CYCLES < 2
      4  215a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215a				  -	      ERR
      6  215a					      ENDIF
      7  215a
      8  215a				  -	      IF	.CYCLES & 1
      9  215a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215a				  -	      nop	0
     11  215a				  -	      ELSE
     12  215a				  -	      bit	VSYNC
     13  215a				  -	      ENDIF
     14  215a				  -.CYCLES    SET	.CYCLES - 3
     15  215a					      ENDIF
     16  215a
     17  215a					      REPEAT	.CYCLES / 2
     18  215a		       ea		      nop
     19  215b					      REPEND
    122  215b		       86 07		      stx	COLUP1
    123  215d		       86 06		      stx	COLUP0
    124  215f
    125  215f
    126  215f		       85 2a		      sta	HMOVE	;3 - CYCLE 74 HMOVE
      0  2161					      sleep	2
      1  2161				   .CYCLES    SET	2
      2  2161
      3  2161				  -	      IF	.CYCLES < 2
      4  2161				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2161				  -	      ERR
      6  2161					      ENDIF
      7  2161
      8  2161				  -	      IF	.CYCLES & 1
      9  2161				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2161				  -	      nop	0
     11  2161				  -	      ELSE
     12  2161				  -	      bit	VSYNC
     13  2161				  -	      ENDIF
     14  2161				  -.CYCLES    SET	.CYCLES - 3
     15  2161					      ENDIF
     16  2161
     17  2161					      REPEAT	.CYCLES / 2
     18  2161		       ea		      nop
     19  2162					      REPEND
    128  2162		       88		      dey
    129  2163
    130  2163		       c4 9c		      cpy	temp1	;3
    131  2165		       d0 99		      bne	pfline_96x2_2_frame0	;2/3
    132  2167
    133  2167				   pf96x2_2_0codeend
    134  2167							;echo "critical code #1 in 96x2_2 is ",(pf96x2_2_0codeend-pfline_96x2_2_frame0), " bytes long."
    135  2167
    136  2167		       a9 00		      lda	#0
    137  2169		       85 1b		      sta	GRP0
    138  216b		       85 1c		      sta	GRP1
    139  216d		       4c 6e b2 	      jmp	pfdone_96x2_2
    140  2170
    141  2170
    142  2170				   pf96x2_2_frame1
    143  2170
    144  2170							;postion P0 and P1
    145  2170		       85 02		      sta	WSYNC
    146  2172		       a9 20		      lda	#%00100000
    147  2174		       85 20		      sta	HMP0
    148  2176		       a9 00		      lda	#0
    149  2178		       a9 f0		      lda	#%11110000
    150  217a		       85 21		      sta	HMP1
    151  217c		       85 02		      sta	WSYNC
      0  217e					      sleep	32
      1  217e				   .CYCLES    SET	32
      2  217e
      3  217e				  -	      IF	.CYCLES < 2
      4  217e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217e				  -	      ERR
      6  217e					      ENDIF
      7  217e
      8  217e				  -	      IF	.CYCLES & 1
      9  217e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217e				  -	      nop	0
     11  217e				  -	      ELSE
     12  217e				  -	      bit	VSYNC
     13  217e				  -	      ENDIF
     14  217e				  -.CYCLES    SET	.CYCLES - 3
     15  217e					      ENDIF
     16  217e
     17  217e					      REPEAT	.CYCLES / 2
     18  217e		       ea		      nop
     17  217e					      REPEND
     18  217f		       ea		      nop
     17  217f					      REPEND
     18  2180		       ea		      nop
     17  2180					      REPEND
     18  2181		       ea		      nop
     17  2181					      REPEND
     18  2182		       ea		      nop
     17  2182					      REPEND
     18  2183		       ea		      nop
     17  2183					      REPEND
     18  2184		       ea		      nop
     17  2184					      REPEND
     18  2185		       ea		      nop
     17  2185					      REPEND
     18  2186		       ea		      nop
     17  2186					      REPEND
     18  2187		       ea		      nop
     17  2187					      REPEND
     18  2188		       ea		      nop
     17  2188					      REPEND
     18  2189		       ea		      nop
     17  2189					      REPEND
     18  218a		       ea		      nop
     17  218a					      REPEND
     18  218b		       ea		      nop
     17  218b					      REPEND
     18  218c		       ea		      nop
     17  218c					      REPEND
     18  218d		       ea		      nop
     19  218e					      REPEND
    153  218e		       85 10		      sta	RESP0
      0  2190					      sleep	12
      1  2190				   .CYCLES    SET	12
      2  2190
      3  2190				  -	      IF	.CYCLES < 2
      4  2190				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2190				  -	      ERR
      6  2190					      ENDIF
      7  2190
      8  2190				  -	      IF	.CYCLES & 1
      9  2190				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2190				  -	      nop	0
     11  2190				  -	      ELSE
     12  2190				  -	      bit	VSYNC
     13  2190				  -	      ENDIF
     14  2190				  -.CYCLES    SET	.CYCLES - 3
     15  2190					      ENDIF
     16  2190
     17  2190					      REPEAT	.CYCLES / 2
     18  2190		       ea		      nop
     17  2190					      REPEND
     18  2191		       ea		      nop
     17  2191					      REPEND
     18  2192		       ea		      nop
     17  2192					      REPEND
     18  2193		       ea		      nop
     17  2193					      REPEND
     18  2194		       ea		      nop
     17  2194					      REPEND
     18  2195		       ea		      nop
     19  2196					      REPEND
    155  2196		       85 11		      sta	RESP1
    156  2198		       85 02		      sta	WSYNC
    157  219a		       85 2a		      sta	HMOVE
    158  219c
    159  219c		       85 02		      sta	WSYNC
    160  219e		       85 2b		      sta	HMCLR
    161  21a0
    162  21a0
    163  21a0
    164  21a0		       85 02		      sta	WSYNC
      0  21a2					      sleep	3
      1  21a2				   .CYCLES    SET	3
      2  21a2
      3  21a2				  -	      IF	.CYCLES < 2
      4  21a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21a2				  -	      ERR
      6  21a2					      ENDIF
      7  21a2
      8  21a2					      IF	.CYCLES & 1
      9  21a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  21a2		       04 00		      nop	0
     11  21a4				  -	      ELSE
     12  21a4				  -	      bit	VSYNC
     13  21a4					      ENDIF
     14  21a4				   .CYCLES    SET	.CYCLES - 3
     15  21a4					      ENDIF
     16  21a4
     17  21a4				  -	      REPEAT	.CYCLES / 2
     18  21a4				  -	      nop
     19  21a4					      REPEND
    166  21a4		       4c 00 b2 	      jmp	pfline_96x2_2_frame1
    167  21a7
    168  21a7							;align so our branch doesn't unexpectedly cross a page...
    169  21a7					      if	>. != >[.+$70]
    170  2200		       00 00 00 00*	      align	256
    171  2200					      endif
    172  2200
    173  2200				   pfline_96x2_2_frame1
    174  2200
    175  2200		       85 2a		      sta	HMOVE
    176  2202
    177  2202		       b9 c8 b5 	      lda	bmp_96x2_2_07,y	;4
    178  2205		       85 1c		      sta	GRP1	;3
    179  2207
    180  2207		       a9 00		      lda	#$0	;2
    181  2209		       85 20		      sta	HMP0	;3
    182  220b		       85 21		      sta	HMP1	;3
    183  220d
    184  220d		       b9 d7 b4 	      lda	bmp_96x2_2_01,y
    185  2210		       8d 1b 00 	      sta.w	GRP0
    186  2213		       b9 28 b5 	      lda	bmp_96x2_2_03,y
    187  2216		       85 1b		      sta	GRP0
    188  2218		       b9 78 b5 	      lda	bmp_96x2_2_05,y
    189  221b		       85 1b		      sta	GRP0
    190  221d
      0  221d					      sleep	2
      1  221d				   .CYCLES    SET	2
      2  221d
      3  221d				  -	      IF	.CYCLES < 2
      4  221d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  221d				  -	      ERR
      6  221d					      ENDIF
      7  221d
      8  221d				  -	      IF	.CYCLES & 1
      9  221d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  221d				  -	      nop	0
     11  221d				  -	      ELSE
     12  221d				  -	      bit	VSYNC
     13  221d				  -	      ENDIF
     14  221d				  -.CYCLES    SET	.CYCLES - 3
     15  221d					      ENDIF
     16  221d
     17  221d					      REPEAT	.CYCLES / 2
     18  221d		       ea		      nop
     19  221e					      REPEND
    192  221e
    193  221e		       b9 28 b6 	      lda	bmp_96x2_2_09,y
    194  2221		       85 1c		      sta	GRP1
    195  2223		       b9 78 b6 	      lda	bmp_96x2_2_11,y
    196  2226		       85 1c		      sta	GRP1
    197  2228
    198  2228		       b9 af b4 	      lda	bmp_96x2_2_00,y
    199  222b		       85 1b		      sta	GRP0
    200  222d
    201  222d		       8d 2a 00 	      sta.w	HMOVE	;3 - cycle 74
    202  2230
    203  2230							;sta WSYNC	;=0 -----------------------------------------
    204  2230
    205  2230		       b9 a0 b5 	      lda	bmp_96x2_2_06,y
    206  2233		       85 1c		      sta	GRP1
    207  2235
      0  2235					      sleep	8
      1  2235				   .CYCLES    SET	8
      2  2235
      3  2235				  -	      IF	.CYCLES < 2
      4  2235				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2235				  -	      ERR
      6  2235					      ENDIF
      7  2235
      8  2235				  -	      IF	.CYCLES & 1
      9  2235				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2235				  -	      nop	0
     11  2235				  -	      ELSE
     12  2235				  -	      bit	VSYNC
     13  2235				  -	      ENDIF
     14  2235				  -.CYCLES    SET	.CYCLES - 3
     15  2235					      ENDIF
     16  2235
     17  2235					      REPEAT	.CYCLES / 2
     18  2235		       ea		      nop
     17  2235					      REPEND
     18  2236		       ea		      nop
     17  2236					      REPEND
     18  2237		       ea		      nop
     17  2237					      REPEND
     18  2238		       ea		      nop
     19  2239					      REPEND
    209  2239
    210  2239		       b9 86 b4 	      lda	bmp_96x2_2_colors-1,y	;get the title color early and store it for later
    211  223c		       aa		      tax		;2
    212  223d
      0  223d					      sleep	3
      1  223d				   .CYCLES    SET	3
      2  223d
      3  223d				  -	      IF	.CYCLES < 2
      4  223d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  223d				  -	      ERR
      6  223d					      ENDIF
      7  223d
      8  223d					      IF	.CYCLES & 1
      9  223d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  223d		       04 00		      nop	0
     11  223f				  -	      ELSE
     12  223f				  -	      bit	VSYNC
     13  223f					      ENDIF
     14  223f				   .CYCLES    SET	.CYCLES - 3
     15  223f					      ENDIF
     16  223f
     17  223f				  -	      REPEAT	.CYCLES / 2
     18  223f				  -	      nop
     19  223f					      REPEND
    214  223f
    215  223f		       a9 80		      lda	#$80	;2
    216  2241		       85 20		      sta	HMP0	;3
    217  2243		       85 21		      sta	HMP1	;3
    218  2245
    219  2245
    220  2245		       b9 00 b5 	      lda	bmp_96x2_2_02,y	;5
    221  2248		       85 1b		      sta	GRP0	;3 =  8
    222  224a
    223  224a		       b9 50 b5 	      lda	bmp_96x2_2_04,y	;5
    224  224d		       85 1b		      sta	GRP0	;3 =  8
    225  224f
      0  224f					      sleep	2
      1  224f				   .CYCLES    SET	2
      2  224f
      3  224f				  -	      IF	.CYCLES < 2
      4  224f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  224f				  -	      ERR
      6  224f					      ENDIF
      7  224f
      8  224f				  -	      IF	.CYCLES & 1
      9  224f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  224f				  -	      nop	0
     11  224f				  -	      ELSE
     12  224f				  -	      bit	VSYNC
     13  224f				  -	      ENDIF
     14  224f				  -.CYCLES    SET	.CYCLES - 3
     15  224f					      ENDIF
     16  224f
     17  224f					      REPEAT	.CYCLES / 2
     18  224f		       ea		      nop
     19  2250					      REPEND
    227  2250
    228  2250		       b9 00 b6 	      lda	bmp_96x2_2_08,y	;5
    229  2253		       85 1c		      sta	GRP1	;3 =  8
    230  2255
    231  2255		       b9 50 b6 	      lda	bmp_96x2_2_10,y	;5
    232  2258		       85 1c		      sta	GRP1	;3 =  8
    233  225a
      0  225a					      sleep	4
      1  225a				   .CYCLES    SET	4
      2  225a
      3  225a				  -	      IF	.CYCLES < 2
      4  225a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  225a				  -	      ERR
      6  225a					      ENDIF
      7  225a
      8  225a				  -	      IF	.CYCLES & 1
      9  225a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  225a				  -	      nop	0
     11  225a				  -	      ELSE
     12  225a				  -	      bit	VSYNC
     13  225a				  -	      ENDIF
     14  225a				  -.CYCLES    SET	.CYCLES - 3
     15  225a					      ENDIF
     16  225a
     17  225a					      REPEAT	.CYCLES / 2
     18  225a		       ea		      nop
     17  225a					      REPEND
     18  225b		       ea		      nop
     19  225c					      REPEND
    235  225c
    236  225c		       88		      dey
    237  225d
    238  225d		       8a		      txa
    239  225e				  -	      ifconst	bmp_96x2_2_fade
    240  225e				  -	      and	bmp_96x2_2_fade
    241  225e					      else
      0  225e					      sleep	3
      1  225e				   .CYCLES    SET	3
      2  225e
      3  225e				  -	      IF	.CYCLES < 2
      4  225e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  225e				  -	      ERR
      6  225e					      ENDIF
      7  225e
      8  225e					      IF	.CYCLES & 1
      9  225e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  225e		       04 00		      nop	0
     11  2260				  -	      ELSE
     12  2260				  -	      bit	VSYNC
     13  2260					      ENDIF
     14  2260				   .CYCLES    SET	.CYCLES - 3
     15  2260					      ENDIF
     16  2260
     17  2260				  -	      REPEAT	.CYCLES / 2
     18  2260				  -	      nop
     19  2260					      REPEND
    243  2260					      endif
    244  2260		       85 07		      sta	COLUP1	;3
    245  2262		       85 06		      sta	COLUP0	;3
    246  2264
    247  2264		       c4 9c		      cpy	temp1	;2
    248  2266		       d0 98		      bne	pfline_96x2_2_frame1	;2/3
    249  2268
    250  2268				   pf96x2_2_1codeend
    251  2268							;echo "critical code #2 in 96x2_2 is ",(pf96x2_2_1codeend-pfline_96x2_2_frame1), " bytes long."
    252  2268
    253  2268		       a9 00		      lda	#0
    254  226a		       85 1b		      sta	GRP0
    255  226c		       85 1c		      sta	GRP1
    256  226e
    257  226e				   pfdone_96x2_2
    258  226e		       85 02		      sta	WSYNC	; debug
    259  2270
    260  2270		       60		      rts
------- FILE titlescreen/asm/titlescreen.asm
    153  2271					      endif		;mk_96x2_2_on
    154  2271
    155  2271					      ifconst	mk_96x2_3_on
------- FILE titlescreen/asm/96x2_3_kernel.asm LEVEL 3 PASS 2
      0  2271					      include	"titlescreen/asm/96x2_3_kernel.asm"
      1  2271				   draw_bmp_96x2_3
      2  2271
      3  2271				  -	      ifconst	bmp_96x2_3_index
      4  2271				  -	      lda	#(bmp_96x2_3_height-1)
      5  2271				  -	      sec
      6  2271				  -	      sbc	bmp_96x2_3_index
      7  2271				  -	      tay
      8  2271				  -	      sbc	#bmp_96x2_3_window
      9  2271				  -	      sta	temp1
     10  2271					      else
     11  2271		       a0 13		      ldy	#(bmp_96x2_3_window-1)
     12  2273		       a9 ff		      lda	#255
     13  2275		       85 9c		      sta	temp1
     14  2277					      endif
     15  2277
     16  2277		       a9 03		      lda	#3
     17  2279		       85 04		      sta	NUSIZ0	;3=Player and Missile are drawn twice 32 clocks apart
     18  227b		       85 05		      sta	NUSIZ1	;3=Player and Missile are drawn twice 32 clocks apart
     19  227d		       a9 00		      lda	#0
     20  227f
     21  227f		       b9 a1 b6 	      lda	bmp_96x2_3_colors,y	;4
     22  2282				  -	      ifconst	bmp_96x2_3_fade
     23  2282				  -	      and	bmp_96x2_3_fade
     24  2282					      endif
     25  2282		       85 06		      sta	COLUP0	;3
     26  2284		       85 07		      sta	COLUP1	;3
     27  2286		       85 2b		      sta	HMCLR	;3
     28  2288
     29  2288		       a5 82		      lda	titleframe
     30  228a		       29 01		      and	#1
     31  228c		       f0 03		      beq	jmp_pf96x2_3_frame0
     32  228e		       4c 70 b3 	      jmp	pf96x2_3_frame1
     33  2291				   jmp_pf96x2_3_frame0
     34  2291		       4c 94 b2 	      jmp	pf96x2_3_frame0
     35  2294
     36  2294				   pf96x2_3_frame0
     37  2294							;postion P0 and P1
     38  2294		       85 02		      sta	WSYNC
     39  2296		       a9 e0		      lda	#%11100000
     40  2298		       85 20		      sta	HMP0
     41  229a		       a9 10		      lda	#%00010000
     42  229c		       85 21		      sta	HMP1
     43  229e		       85 02		      sta	WSYNC
      0  22a0					      sleep	28
      1  22a0				   .CYCLES    SET	28
      2  22a0
      3  22a0				  -	      IF	.CYCLES < 2
      4  22a0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22a0				  -	      ERR
      6  22a0					      ENDIF
      7  22a0
      8  22a0				  -	      IF	.CYCLES & 1
      9  22a0				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22a0				  -	      nop	0
     11  22a0				  -	      ELSE
     12  22a0				  -	      bit	VSYNC
     13  22a0				  -	      ENDIF
     14  22a0				  -.CYCLES    SET	.CYCLES - 3
     15  22a0					      ENDIF
     16  22a0
     17  22a0					      REPEAT	.CYCLES / 2
     18  22a0		       ea		      nop
     17  22a0					      REPEND
     18  22a1		       ea		      nop
     17  22a1					      REPEND
     18  22a2		       ea		      nop
     17  22a2					      REPEND
     18  22a3		       ea		      nop
     17  22a3					      REPEND
     18  22a4		       ea		      nop
     17  22a4					      REPEND
     18  22a5		       ea		      nop
     17  22a5					      REPEND
     18  22a6		       ea		      nop
     17  22a6					      REPEND
     18  22a7		       ea		      nop
     17  22a7					      REPEND
     18  22a8		       ea		      nop
     17  22a8					      REPEND
     18  22a9		       ea		      nop
     17  22a9					      REPEND
     18  22aa		       ea		      nop
     17  22aa					      REPEND
     18  22ab		       ea		      nop
     17  22ab					      REPEND
     18  22ac		       ea		      nop
     17  22ac					      REPEND
     18  22ad		       ea		      nop
     19  22ae					      REPEND
     45  22ae		       85 10		      sta	RESP0
      0  22b0					      sleep	14
      1  22b0				   .CYCLES    SET	14
      2  22b0
      3  22b0				  -	      IF	.CYCLES < 2
      4  22b0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22b0				  -	      ERR
      6  22b0					      ENDIF
      7  22b0
      8  22b0				  -	      IF	.CYCLES & 1
      9  22b0				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22b0				  -	      nop	0
     11  22b0				  -	      ELSE
     12  22b0				  -	      bit	VSYNC
     13  22b0				  -	      ENDIF
     14  22b0				  -.CYCLES    SET	.CYCLES - 3
     15  22b0					      ENDIF
     16  22b0
     17  22b0					      REPEAT	.CYCLES / 2
     18  22b0		       ea		      nop
     17  22b0					      REPEND
     18  22b1		       ea		      nop
     17  22b1					      REPEND
     18  22b2		       ea		      nop
     17  22b2					      REPEND
     18  22b3		       ea		      nop
     17  22b3					      REPEND
     18  22b4		       ea		      nop
     17  22b4					      REPEND
     18  22b5		       ea		      nop
     17  22b5					      REPEND
     18  22b6		       ea		      nop
     19  22b7					      REPEND
     47  22b7		       85 11		      sta	RESP1
     48  22b9		       85 02		      sta	WSYNC
     49  22bb		       85 2a		      sta	HMOVE
     50  22bd
     51  22bd		       85 02		      sta	WSYNC
     52  22bf		       85 2b		      sta	HMCLR
     53  22c1		       85 02		      sta	WSYNC
     54  22c3
      0  22c3					      sleep	4
      1  22c3				   .CYCLES    SET	4
      2  22c3
      3  22c3				  -	      IF	.CYCLES < 2
      4  22c3				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22c3				  -	      ERR
      6  22c3					      ENDIF
      7  22c3
      8  22c3				  -	      IF	.CYCLES & 1
      9  22c3				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22c3				  -	      nop	0
     11  22c3				  -	      ELSE
     12  22c3				  -	      bit	VSYNC
     13  22c3				  -	      ENDIF
     14  22c3				  -.CYCLES    SET	.CYCLES - 3
     15  22c3					      ENDIF
     16  22c3
     17  22c3					      REPEAT	.CYCLES / 2
     18  22c3		       ea		      nop
     17  22c3					      REPEND
     18  22c4		       ea		      nop
     19  22c5					      REPEND
     56  22c5		       4c 00 b3 	      jmp	pfline_96x2_3_frame0
     57  22c8							;align so our branch doesn't unexpectedly cross a page...
     58  22c8					      if	>. != >[.+$70]
     59  2300		       00 00 00 00*	      align	256
     60  2300					      endif
     61  2300
     62  2300				   pfline_96x2_3_frame0
     63  2300		       a9 80		      lda	#$80	;2
     64  2302		       85 20		      sta	HMP0	;3
     65  2304		       85 21		      sta	HMP1	;3
     66  2306
     67  2306		       b9 3c b7 	      lda	bmp_96x2_3_06,y	;4
     68  2309		       85 1c		      sta	GRP1	;3
     69  230b
     70  230b		       b9 b5 b6 	      lda	bmp_96x2_3_00,y
     71  230e		       85 1b		      sta	GRP0
     72  2310		       b9 dd b6 	      lda	bmp_96x2_3_02,y
     73  2313		       85 1b		      sta	GRP0
     74  2315		       b9 14 b7 	      lda	bmp_96x2_3_04,y
     75  2318		       85 1b		      sta	GRP0
     76  231a
      0  231a					      sleep	2
      1  231a				   .CYCLES    SET	2
      2  231a
      3  231a				  -	      IF	.CYCLES < 2
      4  231a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  231a				  -	      ERR
      6  231a					      ENDIF
      7  231a
      8  231a				  -	      IF	.CYCLES & 1
      9  231a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  231a				  -	      nop	0
     11  231a				  -	      ELSE
     12  231a				  -	      bit	VSYNC
     13  231a				  -	      ENDIF
     14  231a				  -.CYCLES    SET	.CYCLES - 3
     15  231a					      ENDIF
     16  231a
     17  231a					      REPEAT	.CYCLES / 2
     18  231a		       ea		      nop
     19  231b					      REPEND
     78  231b
     79  231b		       b9 64 b7 	      lda	bmp_96x2_3_08,y
     80  231e		       85 1c		      sta	GRP1
     81  2320		       b9 8c b7 	      lda	bmp_96x2_3_10,y
     82  2323		       85 1c		      sta	GRP1
     83  2325
     84  2325		       b9 c9 b6 	      lda	bmp_96x2_3_01,y
     85  2328		       85 1b		      sta	GRP0
     86  232a
      0  232a					      sleep	8
      1  232a				   .CYCLES    SET	8
      2  232a
      3  232a				  -	      IF	.CYCLES < 2
      4  232a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  232a				  -	      ERR
      6  232a					      ENDIF
      7  232a
      8  232a				  -	      IF	.CYCLES & 1
      9  232a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  232a				  -	      nop	0
     11  232a				  -	      ELSE
     12  232a				  -	      bit	VSYNC
     13  232a				  -	      ENDIF
     14  232a				  -.CYCLES    SET	.CYCLES - 3
     15  232a					      ENDIF
     16  232a
     17  232a					      REPEAT	.CYCLES / 2
     18  232a		       ea		      nop
     17  232a					      REPEND
     18  232b		       ea		      nop
     17  232b					      REPEND
     18  232c		       ea		      nop
     17  232c					      REPEND
     18  232d		       ea		      nop
     19  232e					      REPEND
     88  232e
     89  232e							;sta WSYNC	;=0
     90  232e		       85 2a		      sta	HMOVE	;3 - NORMAL HMOVE
     91  2330
     92  2330		       b9 a0 b6 	      lda	bmp_96x2_3_colors-1,y	;4 - get the title color early and store it for later
     93  2333				  -	      ifconst	bmp_96x2_3_fade
     94  2333				  -	      and	bmp_96x2_3_fade
     95  2333					      else
      0  2333					      sleep	3
      1  2333				   .CYCLES    SET	3
      2  2333
      3  2333				  -	      IF	.CYCLES < 2
      4  2333				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2333				  -	      ERR
      6  2333					      ENDIF
      7  2333
      8  2333					      IF	.CYCLES & 1
      9  2333					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2333		       04 00		      nop	0
     11  2335				  -	      ELSE
     12  2335				  -	      bit	VSYNC
     13  2335					      ENDIF
     14  2335				   .CYCLES    SET	.CYCLES - 3
     15  2335					      ENDIF
     16  2335
     17  2335				  -	      REPEAT	.CYCLES / 2
     18  2335				  -	      nop
     19  2335					      REPEND
     97  2335					      endif
     98  2335		       aa		      tax
     99  2336
    100  2336		       a9 00		      lda	#0	;2
    101  2338		       85 20		      sta	HMP0	;3
    102  233a		       85 21		      sta	HMP1	;3
    103  233c
      0  233c					      sleep	7
      1  233c				   .CYCLES    SET	7
      2  233c
      3  233c				  -	      IF	.CYCLES < 2
      4  233c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  233c				  -	      ERR
      6  233c					      ENDIF
      7  233c
      8  233c					      IF	.CYCLES & 1
      9  233c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  233c		       04 00		      nop	0
     11  233e				  -	      ELSE
     12  233e				  -	      bit	VSYNC
     13  233e					      ENDIF
     14  233e				   .CYCLES    SET	.CYCLES - 3
     15  233e					      ENDIF
     16  233e
     17  233e					      REPEAT	.CYCLES / 2
     18  233e		       ea		      nop
     17  233e					      REPEND
     18  233f		       ea		      nop
     19  2340					      REPEND
    105  2340
    106  2340		       b9 50 b7 	      lda	bmp_96x2_3_07,y
    107  2343		       85 1c		      sta	GRP1
    108  2345
    109  2345		       b9 00 b7 	      lda	bmp_96x2_3_03,y	;5
    110  2348		       85 1b		      sta	GRP0	;3 =  8
    111  234a		       b9 28 b7 	      lda	bmp_96x2_3_05,y	;5
    112  234d		       85 1b		      sta	GRP0	;3 =  8
    113  234f
      0  234f					      sleep	2
      1  234f				   .CYCLES    SET	2
      2  234f
      3  234f				  -	      IF	.CYCLES < 2
      4  234f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  234f				  -	      ERR
      6  234f					      ENDIF
      7  234f
      8  234f				  -	      IF	.CYCLES & 1
      9  234f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  234f				  -	      nop	0
     11  234f				  -	      ELSE
     12  234f				  -	      bit	VSYNC
     13  234f				  -	      ENDIF
     14  234f				  -.CYCLES    SET	.CYCLES - 3
     15  234f					      ENDIF
     16  234f
     17  234f					      REPEAT	.CYCLES / 2
     18  234f		       ea		      nop
     19  2350					      REPEND
    115  2350
    116  2350		       b9 78 b7 	      lda	bmp_96x2_3_09,y	;5
    117  2353		       85 1c		      sta	GRP1	;3 =  8
    118  2355		       b9 a0 b7 	      lda	bmp_96x2_3_11,y	;5
    119  2358		       85 1c		      sta	GRP1	;3 =  8
    120  235a
      0  235a					      sleep	2
      1  235a				   .CYCLES    SET	2
      2  235a
      3  235a				  -	      IF	.CYCLES < 2
      4  235a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  235a				  -	      ERR
      6  235a					      ENDIF
      7  235a
      8  235a				  -	      IF	.CYCLES & 1
      9  235a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  235a				  -	      nop	0
     11  235a				  -	      ELSE
     12  235a				  -	      bit	VSYNC
     13  235a				  -	      ENDIF
     14  235a				  -.CYCLES    SET	.CYCLES - 3
     15  235a					      ENDIF
     16  235a
     17  235a					      REPEAT	.CYCLES / 2
     18  235a		       ea		      nop
     19  235b					      REPEND
    122  235b		       86 07		      stx	COLUP1
    123  235d		       86 06		      stx	COLUP0
    124  235f
    125  235f
    126  235f		       85 2a		      sta	HMOVE	;3 - CYCLE 74 HMOVE
      0  2361					      sleep	2
      1  2361				   .CYCLES    SET	2
      2  2361
      3  2361				  -	      IF	.CYCLES < 2
      4  2361				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2361				  -	      ERR
      6  2361					      ENDIF
      7  2361
      8  2361				  -	      IF	.CYCLES & 1
      9  2361				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2361				  -	      nop	0
     11  2361				  -	      ELSE
     12  2361				  -	      bit	VSYNC
     13  2361				  -	      ENDIF
     14  2361				  -.CYCLES    SET	.CYCLES - 3
     15  2361					      ENDIF
     16  2361
     17  2361					      REPEAT	.CYCLES / 2
     18  2361		       ea		      nop
     19  2362					      REPEND
    128  2362		       88		      dey
    129  2363
    130  2363		       c4 9c		      cpy	temp1	;3
    131  2365		       d0 99		      bne	pfline_96x2_3_frame0	;2/3
    132  2367
    133  2367				   pf96x2_3_0codeend
    134  2367							;echo "critical code #1 in 96x2_3 is ",(pf96x2_3_0codeend-pfline_96x2_3_frame0), " bytes long."
    135  2367
    136  2367		       a9 00		      lda	#0
    137  2369		       85 1b		      sta	GRP0
    138  236b		       85 1c		      sta	GRP1
    139  236d		       4c 6e b4 	      jmp	pfdone_96x2_3
    140  2370
    141  2370
    142  2370				   pf96x2_3_frame1
    143  2370
    144  2370							;postion P0 and P1
    145  2370		       85 02		      sta	WSYNC
    146  2372		       a9 20		      lda	#%00100000
    147  2374		       85 20		      sta	HMP0
    148  2376		       a9 00		      lda	#0
    149  2378		       a9 f0		      lda	#%11110000
    150  237a		       85 21		      sta	HMP1
    151  237c		       85 02		      sta	WSYNC
      0  237e					      sleep	32
      1  237e				   .CYCLES    SET	32
      2  237e
      3  237e				  -	      IF	.CYCLES < 2
      4  237e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  237e				  -	      ERR
      6  237e					      ENDIF
      7  237e
      8  237e				  -	      IF	.CYCLES & 1
      9  237e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  237e				  -	      nop	0
     11  237e				  -	      ELSE
     12  237e				  -	      bit	VSYNC
     13  237e				  -	      ENDIF
     14  237e				  -.CYCLES    SET	.CYCLES - 3
     15  237e					      ENDIF
     16  237e
     17  237e					      REPEAT	.CYCLES / 2
     18  237e		       ea		      nop
     17  237e					      REPEND
     18  237f		       ea		      nop
     17  237f					      REPEND
     18  2380		       ea		      nop
     17  2380					      REPEND
     18  2381		       ea		      nop
     17  2381					      REPEND
     18  2382		       ea		      nop
     17  2382					      REPEND
     18  2383		       ea		      nop
     17  2383					      REPEND
     18  2384		       ea		      nop
     17  2384					      REPEND
     18  2385		       ea		      nop
     17  2385					      REPEND
     18  2386		       ea		      nop
     17  2386					      REPEND
     18  2387		       ea		      nop
     17  2387					      REPEND
     18  2388		       ea		      nop
     17  2388					      REPEND
     18  2389		       ea		      nop
     17  2389					      REPEND
     18  238a		       ea		      nop
     17  238a					      REPEND
     18  238b		       ea		      nop
     17  238b					      REPEND
     18  238c		       ea		      nop
     17  238c					      REPEND
     18  238d		       ea		      nop
     19  238e					      REPEND
    153  238e		       85 10		      sta	RESP0
      0  2390					      sleep	12
      1  2390				   .CYCLES    SET	12
      2  2390
      3  2390				  -	      IF	.CYCLES < 2
      4  2390				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2390				  -	      ERR
      6  2390					      ENDIF
      7  2390
      8  2390				  -	      IF	.CYCLES & 1
      9  2390				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2390				  -	      nop	0
     11  2390				  -	      ELSE
     12  2390				  -	      bit	VSYNC
     13  2390				  -	      ENDIF
     14  2390				  -.CYCLES    SET	.CYCLES - 3
     15  2390					      ENDIF
     16  2390
     17  2390					      REPEAT	.CYCLES / 2
     18  2390		       ea		      nop
     17  2390					      REPEND
     18  2391		       ea		      nop
     17  2391					      REPEND
     18  2392		       ea		      nop
     17  2392					      REPEND
     18  2393		       ea		      nop
     17  2393					      REPEND
     18  2394		       ea		      nop
     17  2394					      REPEND
     18  2395		       ea		      nop
     19  2396					      REPEND
    155  2396		       85 11		      sta	RESP1
    156  2398		       85 02		      sta	WSYNC
    157  239a		       85 2a		      sta	HMOVE
    158  239c
    159  239c		       85 02		      sta	WSYNC
    160  239e		       85 2b		      sta	HMCLR
    161  23a0
    162  23a0
    163  23a0
    164  23a0		       85 02		      sta	WSYNC
      0  23a2					      sleep	3
      1  23a2				   .CYCLES    SET	3
      2  23a2
      3  23a2				  -	      IF	.CYCLES < 2
      4  23a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  23a2				  -	      ERR
      6  23a2					      ENDIF
      7  23a2
      8  23a2					      IF	.CYCLES & 1
      9  23a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  23a2		       04 00		      nop	0
     11  23a4				  -	      ELSE
     12  23a4				  -	      bit	VSYNC
     13  23a4					      ENDIF
     14  23a4				   .CYCLES    SET	.CYCLES - 3
     15  23a4					      ENDIF
     16  23a4
     17  23a4				  -	      REPEAT	.CYCLES / 2
     18  23a4				  -	      nop
     19  23a4					      REPEND
    166  23a4		       4c 00 b4 	      jmp	pfline_96x2_3_frame1
    167  23a7
    168  23a7							;align so our branch doesn't unexpectedly cross a page...
    169  23a7					      if	>. != >[.+$70]
    170  2400		       00 00 00 00*	      align	256
    171  2400					      endif
    172  2400
    173  2400				   pfline_96x2_3_frame1
    174  2400
    175  2400		       85 2a		      sta	HMOVE
    176  2402
    177  2402		       b9 50 b7 	      lda	bmp_96x2_3_07,y	;4
    178  2405		       85 1c		      sta	GRP1	;3
    179  2407
    180  2407		       a9 00		      lda	#$0	;2
    181  2409		       85 20		      sta	HMP0	;3
    182  240b		       85 21		      sta	HMP1	;3
    183  240d
    184  240d		       b9 c9 b6 	      lda	bmp_96x2_3_01,y
    185  2410		       8d 1b 00 	      sta.w	GRP0
    186  2413		       b9 00 b7 	      lda	bmp_96x2_3_03,y
    187  2416		       85 1b		      sta	GRP0
    188  2418		       b9 28 b7 	      lda	bmp_96x2_3_05,y
    189  241b		       85 1b		      sta	GRP0
    190  241d
      0  241d					      sleep	2
      1  241d				   .CYCLES    SET	2
      2  241d
      3  241d				  -	      IF	.CYCLES < 2
      4  241d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  241d				  -	      ERR
      6  241d					      ENDIF
      7  241d
      8  241d				  -	      IF	.CYCLES & 1
      9  241d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  241d				  -	      nop	0
     11  241d				  -	      ELSE
     12  241d				  -	      bit	VSYNC
     13  241d				  -	      ENDIF
     14  241d				  -.CYCLES    SET	.CYCLES - 3
     15  241d					      ENDIF
     16  241d
     17  241d					      REPEAT	.CYCLES / 2
     18  241d		       ea		      nop
     19  241e					      REPEND
    192  241e
    193  241e		       b9 78 b7 	      lda	bmp_96x2_3_09,y
    194  2421		       85 1c		      sta	GRP1
    195  2423		       b9 a0 b7 	      lda	bmp_96x2_3_11,y
    196  2426		       85 1c		      sta	GRP1
    197  2428
    198  2428		       b9 b5 b6 	      lda	bmp_96x2_3_00,y
    199  242b		       85 1b		      sta	GRP0
    200  242d
    201  242d		       8d 2a 00 	      sta.w	HMOVE	;3 - cycle 74
    202  2430
    203  2430							;sta WSYNC	;=0 -----------------------------------------
    204  2430
    205  2430		       b9 3c b7 	      lda	bmp_96x2_3_06,y
    206  2433		       85 1c		      sta	GRP1
    207  2435
      0  2435					      sleep	8
      1  2435				   .CYCLES    SET	8
      2  2435
      3  2435				  -	      IF	.CYCLES < 2
      4  2435				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2435				  -	      ERR
      6  2435					      ENDIF
      7  2435
      8  2435				  -	      IF	.CYCLES & 1
      9  2435				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2435				  -	      nop	0
     11  2435				  -	      ELSE
     12  2435				  -	      bit	VSYNC
     13  2435				  -	      ENDIF
     14  2435				  -.CYCLES    SET	.CYCLES - 3
     15  2435					      ENDIF
     16  2435
     17  2435					      REPEAT	.CYCLES / 2
     18  2435		       ea		      nop
     17  2435					      REPEND
     18  2436		       ea		      nop
     17  2436					      REPEND
     18  2437		       ea		      nop
     17  2437					      REPEND
     18  2438		       ea		      nop
     19  2439					      REPEND
    209  2439
    210  2439		       b9 a0 b6 	      lda	bmp_96x2_3_colors-1,y	;get the title color early and store it for later
    211  243c		       aa		      tax		;2
    212  243d
      0  243d					      sleep	3
      1  243d				   .CYCLES    SET	3
      2  243d
      3  243d				  -	      IF	.CYCLES < 2
      4  243d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  243d				  -	      ERR
      6  243d					      ENDIF
      7  243d
      8  243d					      IF	.CYCLES & 1
      9  243d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  243d		       04 00		      nop	0
     11  243f				  -	      ELSE
     12  243f				  -	      bit	VSYNC
     13  243f					      ENDIF
     14  243f				   .CYCLES    SET	.CYCLES - 3
     15  243f					      ENDIF
     16  243f
     17  243f				  -	      REPEAT	.CYCLES / 2
     18  243f				  -	      nop
     19  243f					      REPEND
    214  243f
    215  243f		       a9 80		      lda	#$80	;2
    216  2441		       85 20		      sta	HMP0	;3
    217  2443		       85 21		      sta	HMP1	;3
    218  2445
    219  2445
    220  2445		       b9 dd b6 	      lda	bmp_96x2_3_02,y	;5
    221  2448		       85 1b		      sta	GRP0	;3 =  8
    222  244a
    223  244a		       b9 14 b7 	      lda	bmp_96x2_3_04,y	;5
    224  244d		       85 1b		      sta	GRP0	;3 =  8
    225  244f
      0  244f					      sleep	2
      1  244f				   .CYCLES    SET	2
      2  244f
      3  244f				  -	      IF	.CYCLES < 2
      4  244f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  244f				  -	      ERR
      6  244f					      ENDIF
      7  244f
      8  244f				  -	      IF	.CYCLES & 1
      9  244f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  244f				  -	      nop	0
     11  244f				  -	      ELSE
     12  244f				  -	      bit	VSYNC
     13  244f				  -	      ENDIF
     14  244f				  -.CYCLES    SET	.CYCLES - 3
     15  244f					      ENDIF
     16  244f
     17  244f					      REPEAT	.CYCLES / 2
     18  244f		       ea		      nop
     19  2450					      REPEND
    227  2450
    228  2450		       b9 64 b7 	      lda	bmp_96x2_3_08,y	;5
    229  2453		       85 1c		      sta	GRP1	;3 =  8
    230  2455
    231  2455		       b9 8c b7 	      lda	bmp_96x2_3_10,y	;5
    232  2458		       85 1c		      sta	GRP1	;3 =  8
    233  245a
      0  245a					      sleep	4
      1  245a				   .CYCLES    SET	4
      2  245a
      3  245a				  -	      IF	.CYCLES < 2
      4  245a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  245a				  -	      ERR
      6  245a					      ENDIF
      7  245a
      8  245a				  -	      IF	.CYCLES & 1
      9  245a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  245a				  -	      nop	0
     11  245a				  -	      ELSE
     12  245a				  -	      bit	VSYNC
     13  245a				  -	      ENDIF
     14  245a				  -.CYCLES    SET	.CYCLES - 3
     15  245a					      ENDIF
     16  245a
     17  245a					      REPEAT	.CYCLES / 2
     18  245a		       ea		      nop
     17  245a					      REPEND
     18  245b		       ea		      nop
     19  245c					      REPEND
    235  245c
    236  245c		       88		      dey
    237  245d
    238  245d		       8a		      txa
    239  245e				  -	      ifconst	bmp_96x2_3_fade
    240  245e				  -	      and	bmp_96x2_3_fade
    241  245e					      else
      0  245e					      sleep	3
      1  245e				   .CYCLES    SET	3
      2  245e
      3  245e				  -	      IF	.CYCLES < 2
      4  245e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  245e				  -	      ERR
      6  245e					      ENDIF
      7  245e
      8  245e					      IF	.CYCLES & 1
      9  245e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  245e		       04 00		      nop	0
     11  2460				  -	      ELSE
     12  2460				  -	      bit	VSYNC
     13  2460					      ENDIF
     14  2460				   .CYCLES    SET	.CYCLES - 3
     15  2460					      ENDIF
     16  2460
     17  2460				  -	      REPEAT	.CYCLES / 2
     18  2460				  -	      nop
     19  2460					      REPEND
    243  2460					      endif
    244  2460		       85 07		      sta	COLUP1	;3
    245  2462		       85 06		      sta	COLUP0	;3
    246  2464
    247  2464		       c4 9c		      cpy	temp1	;2
    248  2466		       d0 98		      bne	pfline_96x2_3_frame1	;2/3
    249  2468
    250  2468				   pf96x2_3_1codeend
    251  2468							;echo "critical code #2 in 96x2_3 is ",(pf96x2_3_1codeend-pfline_96x2_3_frame1), " bytes long."
    252  2468
    253  2468		       a9 00		      lda	#0
    254  246a		       85 1b		      sta	GRP0
    255  246c		       85 1c		      sta	GRP1
    256  246e
    257  246e				   pfdone_96x2_3
    258  246e		       85 02		      sta	WSYNC	; debug
    259  2470
    260  2470		       60		      rts
------- FILE titlescreen/asm/titlescreen.asm
    157  2471					      endif		;mk_96x2_3_on
    158  2471
    159  2471				  -	      ifconst	mk_96x2_4_on
    160  2471				  -	      include	"titlescreen/asm/96x2_4_kernel.asm"
    161  2471					      endif		;mk_96x2_4_on
    162  2471
    163  2471				  -	      ifconst	mk_96x2_5_on
    164  2471				  -	      include	"titlescreen/asm/96x2_5_kernel.asm"
    165  2471					      endif		;mk_96x2_5_on
    166  2471
    167  2471				  -	      ifconst	mk_96x2_6_on
    168  2471				  -	      include	"titlescreen/asm/96x2_6_kernel.asm"
    169  2471					      endif		;mk_96x2_6_on
    170  2471
    171  2471				  -	      ifconst	mk_96x2_7_on
    172  2471				  -	      include	"titlescreen/asm/96x2_7_kernel.asm"
    173  2471					      endif		;mk_96x2_7_on
    174  2471
    175  2471				  -	      ifconst	mk_96x2_8_on
    176  2471				  -	      include	"titlescreen/asm/96x2_8_kernel.asm"
    177  2471					      endif		;mk_96x2_8_on
    178  2471
    179  2471				  -	      ifconst	mk_score_on
    180  2471				  -	      include	"titlescreen/asm/score_kernel.asm"
    181  2471					      endif		;mk_score_on
    182  2471
    183  2471				  -	      ifconst	mk_gameselect_on
    184  2471				  -	      include	"titlescreen/asm/gameselect_kernel.asm"
    185  2471					      endif		;mk_gameselect_on
    186  2471
    187  2471				   PFWAIT
    188  2471		       ad 84 02 	      lda	INTIM
    189  2474		       d0 fb		      bne	PFWAIT
    190  2476		       85 02		      sta	WSYNC
    191  2478
    192  2478				   OVERSCAN
    193  2478				  -	      ifnconst	overscan_time
    194  2478				  -	      lda	#34+128
    195  2478					      else
    196  2478		       a9 a0		      lda	#overscan_time+128-5
    197  247a					      endif
    198  247a		       8d 96 02 	      sta	TIM64T
    199  247d
    200  247d							;fix height variables we borrowed, so DPC doesn't crash on drawscreen...
    201  247d				  -	      ifconst	player9height
    202  247d				  -	      ldy	#8
    203  247d				  -	      lda	#0
    204  247d				  -	      sta	player0height
    205  247d				  -.playerheightfixloop
    206  247d				  -	      sta	player1height,y
    207  247d				  -	      ifconst	_NUSIZ1
    208  247d				  -	      sta	_NUSIZ1,y
    209  247d				  -	      endif
    210  247d				  -	      dey
    211  247d				  -	      bpl	.playerheightfixloop
    212  247d					      endif
    213  247d
    214  247d		       a9 c2		      lda	#%11000010
    215  247f		       85 02		      sta	WSYNC
    216  2481		       85 01		      sta	VBLANK
      0  2483					      RETURN
      1  2483				  -	      ifnconst	bankswitch
      2  2483				  -	      rts
      3  2483					      else
      4  2483		       4c dd ff 	      jmp	BS_return
      5  2486					      endif
    218  2486
    219  2486				  -	      ifconst	mk_48x1_1_on
    220  2486				  -	      include	"titlescreen/48x1_1_image.asm"
    221  2486					      endif
    222  2486				  -	      ifconst	mk_48x1_2_on
    223  2486				  -	      include	"titlescreen/48x1_2_image.asm"
    224  2486					      endif
    225  2486				  -	      ifconst	mk_48x1_3_on
    226  2486				  -	      include	"titlescreen/48x1_3_image.asm"
    227  2486					      endif
    228  2486				  -	      ifconst	mk_48x1_4_on
    229  2486				  -	      include	"titlescreen/48x1_4_image.asm"
    230  2486					      endif
    231  2486				  -	      ifconst	mk_48x1_5_on
    232  2486				  -	      include	"titlescreen/48x1_5_image.asm"
    233  2486					      endif
    234  2486				  -	      ifconst	mk_48x1_6_on
    235  2486				  -	      include	"titlescreen/48x1_6_image.asm"
    236  2486					      endif
    237  2486				  -	      ifconst	mk_48x1_7_on
    238  2486				  -	      include	"titlescreen/48x1_7_image.asm"
    239  2486					      endif
    240  2486				  -	      ifconst	mk_48x1_8_on
    241  2486				  -	      include	"titlescreen/48x1_8_image.asm"
    242  2486					      endif
    243  2486
    244  2486
    245  2486				  -	      ifconst	mk_48x2_1_on
    246  2486				  -	      include	"titlescreen/48x2_1_image.asm"
    247  2486					      endif
    248  2486				  -	      ifconst	mk_48x2_2_on
    249  2486				  -	      include	"titlescreen/48x2_2_image.asm"
    250  2486					      endif
    251  2486				  -	      ifconst	mk_48x2_3_on
    252  2486				  -	      include	"titlescreen/48x2_3_image.asm"
    253  2486					      endif
    254  2486				  -	      ifconst	mk_48x2_4_on
    255  2486				  -	      include	"titlescreen/48x2_4_image.asm"
    256  2486					      endif
    257  2486				  -	      ifconst	mk_48x2_5_on
    258  2486				  -	      include	"titlescreen/48x2_5_image.asm"
    259  2486					      endif
    260  2486				  -	      ifconst	mk_48x2_6_on
    261  2486				  -	      include	"titlescreen/48x2_6_image.asm"
    262  2486					      endif
    263  2486				  -	      ifconst	mk_48x2_7_on
    264  2486				  -	      include	"titlescreen/48x2_7_image.asm"
    265  2486					      endif
    266  2486
    267  2486				  -	      ifconst	mk_48x2_8_on
    268  2486				  -	      include	"titlescreen/48x2_8_image.asm"
    269  2486					      endif
    270  2486
    271  2486
    272  2486				  -	      ifconst	mk_96x2_1_on
    273  2486				  -	      include	"titlescreen/96x2_1_image.asm"
    274  2486					      endif
    275  2486					      ifconst	mk_96x2_2_on
------- FILE titlescreen/96x2_2_image.asm LEVEL 3 PASS 2
      0  2486					      include	"titlescreen/96x2_2_image.asm"
      1  2486							;*** The height of the displayed data...
      2  2486		       00 28	   bmp_96x2_2_window =	40
      3  2486
      4  2486							;*** The height of the bitmap data. This can be larger than 
      5  2486							;*** the displayed data height, if you're scrolling or animating 
      6  2486							;*** the data...
      7  2486		       00 28	   bmp_96x2_2_height =	40
      8  2486
      9  2486
     10  2486				  -	      if	>. != >[.+(bmp_96x2_2_height)]
     11  2486				  -	      align	256
     12  2486					      endif
     13  2486		       00		      BYTE.b	$00	; leave this here!
     14  2487
     15  2487
     16  2487							;*** The color of each line in the bitmap, in reverse order...
     17  2487				   bmp_96x2_2_colors
     18  2487		       1e		      .byte.b	$1E
     19  2488		       1e		      .byte.b	$1E
     20  2489		       1e		      .byte.b	$1E
     21  248a		       1e		      .byte.b	$1E
     22  248b		       1e		      .byte.b	$1E
     23  248c		       1e		      .byte.b	$1E
     24  248d		       1e		      .byte.b	$1E
     25  248e		       1e		      .byte.b	$1E
     26  248f		       1e		      .byte.b	$1E
     27  2490		       1e		      .byte.b	$1E
     28  2491		       1e		      .byte.b	$1E
     29  2492		       1e		      .byte.b	$1E
     30  2493		       1e		      .byte.b	$1E
     31  2494		       1e		      .byte.b	$1E
     32  2495		       1e		      .byte.b	$1E
     33  2496		       1e		      .byte.b	$1E
     34  2497		       1e		      .byte.b	$1E
     35  2498		       1e		      .byte.b	$1E
     36  2499		       1e		      .byte.b	$1E
     37  249a		       1e		      .byte.b	$1E
     38  249b		       1e		      .byte.b	$1E
     39  249c		       1e		      .byte.b	$1E
     40  249d		       1e		      .byte.b	$1E
     41  249e		       1e		      .byte.b	$1E
     42  249f		       1e		      .byte.b	$1E
     43  24a0		       1e		      .byte.b	$1E
     44  24a1		       1e		      .byte.b	$1E
     45  24a2		       1e		      .byte.b	$1E
     46  24a3		       1e		      .byte.b	$1E
     47  24a4		       1e		      .byte.b	$1E
     48  24a5		       1e		      .byte.b	$1E
     49  24a6		       1e		      .byte.b	$1E
     50  24a7		       1e		      .byte.b	$1E
     51  24a8		       1e		      .byte.b	$1E
     52  24a9		       1e		      .byte.b	$1E
     53  24aa		       1e		      .byte.b	$1E
     54  24ab		       1e		      .byte.b	$1E
     55  24ac		       1e		      .byte.b	$1E
     56  24ad		       1e		      .byte.b	$1E
     57  24ae		       1e		      .byte.b	$1E
     58  24af
     59  24af
     60  24af				  -	      if	>. != >[.+(bmp_96x2_2_height)]
     61  24af				  -	      align	256
     62  24af					      endif
     63  24af
     64  24af
     65  24af				   bmp_96x2_2_00
     66  24af							; *** replace this block with your bimap_00 data block...
     67  24af		       00		      BYTE.b	%00000000
     68  24b0		       01		      BYTE.b	%00000001
     69  24b1		       01		      BYTE.b	%00000001
     70  24b2		       01		      BYTE.b	%00000001
     71  24b3		       01		      BYTE.b	%00000001
     72  24b4		       01		      BYTE.b	%00000001
     73  24b5		       01		      BYTE.b	%00000001
     74  24b6		       01		      BYTE.b	%00000001
     75  24b7		       01		      BYTE.b	%00000001
     76  24b8		       01		      BYTE.b	%00000001
     77  24b9		       01		      BYTE.b	%00000001
     78  24ba		       00		      BYTE.b	%00000000
     79  24bb		       00		      BYTE.b	%00000000
     80  24bc		       00		      BYTE.b	%00000000
     81  24bd		       00		      BYTE.b	%00000000
     82  24be		       00		      BYTE.b	%00000000
     83  24bf		       00		      BYTE.b	%00000000
     84  24c0		       00		      BYTE.b	%00000000
     85  24c1		       00		      BYTE.b	%00000000
     86  24c2		       00		      BYTE.b	%00000000
     87  24c3		       00		      BYTE.b	%00000000
     88  24c4		       00		      BYTE.b	%00000000
     89  24c5		       00		      BYTE.b	%00000000
     90  24c6		       00		      BYTE.b	%00000000
     91  24c7		       00		      BYTE.b	%00000000
     92  24c8		       00		      BYTE.b	%00000000
     93  24c9		       00		      BYTE.b	%00000000
     94  24ca		       00		      BYTE.b	%00000000
     95  24cb		       00		      BYTE.b	%00000000
     96  24cc		       00		      BYTE.b	%00000000
     97  24cd		       00		      BYTE.b	%00000000
     98  24ce		       00		      BYTE.b	%00000000
     99  24cf		       00		      BYTE.b	%00000000
    100  24d0		       00		      BYTE.b	%00000000
    101  24d1		       00		      BYTE.b	%00000000
    102  24d2		       00		      BYTE.b	%00000000
    103  24d3		       00		      BYTE.b	%00000000
    104  24d4		       00		      BYTE.b	%00000000
    105  24d5		       00		      BYTE.b	%00000000
    106  24d6		       00		      BYTE.b	%00000000
    107  24d7
    108  24d7
    109  24d7
    110  24d7				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    111  24d7				  -	      align	256
    112  24d7					      endif
    113  24d7
    114  24d7
    115  24d7				   bmp_96x2_2_01
    116  24d7							; *** replace this block with your bimap_01 data block...
    117  24d7		       00		      BYTE.b	%00000000
    118  24d8		       e0		      BYTE.b	%11100000
    119  24d9		       e0		      BYTE.b	%11100000
    120  24da		       e0		      BYTE.b	%11100000
    121  24db		       e3		      BYTE.b	%11100011
    122  24dc		       e3		      BYTE.b	%11100011
    123  24dd		       f7		      BYTE.b	%11110111
    124  24de		       ff		      BYTE.b	%11111111
    125  24df		       fc		      BYTE.b	%11111100
    126  24e0		       f0		      BYTE.b	%11110000
    127  24e1		       e0		      BYTE.b	%11100000
    128  24e2		       00		      BYTE.b	%00000000
    129  24e3		       00		      BYTE.b	%00000000
    130  24e4		       00		      BYTE.b	%00000000
    131  24e5		       00		      BYTE.b	%00000000
    132  24e6		       00		      BYTE.b	%00000000
    133  24e7		       00		      BYTE.b	%00000000
    134  24e8		       00		      BYTE.b	%00000000
    135  24e9		       00		      BYTE.b	%00000000
    136  24ea		       00		      BYTE.b	%00000000
    137  24eb		       00		      BYTE.b	%00000000
    138  24ec		       00		      BYTE.b	%00000000
    139  24ed		       00		      BYTE.b	%00000000
    140  24ee		       00		      BYTE.b	%00000000
    141  24ef		       00		      BYTE.b	%00000000
    142  24f0		       00		      BYTE.b	%00000000
    143  24f1		       00		      BYTE.b	%00000000
    144  24f2		       00		      BYTE.b	%00000000
    145  24f3		       00		      BYTE.b	%00000000
    146  24f4		       00		      BYTE.b	%00000000
    147  24f5		       00		      BYTE.b	%00000000
    148  24f6		       00		      BYTE.b	%00000000
    149  24f7		       00		      BYTE.b	%00000000
    150  24f8		       00		      BYTE.b	%00000000
    151  24f9		       00		      BYTE.b	%00000000
    152  24fa		       00		      BYTE.b	%00000000
    153  24fb		       00		      BYTE.b	%00000000
    154  24fc		       00		      BYTE.b	%00000000
    155  24fd		       00		      BYTE.b	%00000000
    156  24fe		       00		      BYTE.b	%00000000
    157  24ff
    158  24ff
    159  24ff
    160  24ff					      if	>. != >[.+(bmp_96x2_2_height)]
    161  2500		       00		      align	256
    162  2500					      endif
    163  2500
    164  2500
    165  2500				   bmp_96x2_2_02
    166  2500							; *** replace this block with your bimap_02 data block...
    167  2500		       00		      BYTE.b	%00000000
    168  2501		       3c		      BYTE.b	%00111100
    169  2502		       3c		      BYTE.b	%00111100
    170  2503		       3c		      BYTE.b	%00111100
    171  2504		       3c		      BYTE.b	%00111100
    172  2505		       3c		      BYTE.b	%00111100
    173  2506		       7c		      BYTE.b	%01111100
    174  2507		       fc		      BYTE.b	%11111100
    175  2508		       fc		      BYTE.b	%11111100
    176  2509		       7c		      BYTE.b	%01111100
    177  250a		       3c		      BYTE.b	%00111100
    178  250b		       00		      BYTE.b	%00000000
    179  250c		       ff		      BYTE.b	%11111111
    180  250d		       ff		      BYTE.b	%11111111
    181  250e		       f0		      BYTE.b	%11110000
    182  250f		       f0		      BYTE.b	%11110000
    183  2510		       ff		      BYTE.b	%11111111
    184  2511		       ff		      BYTE.b	%11111111
    185  2512		       f0		      BYTE.b	%11110000
    186  2513		       f0		      BYTE.b	%11110000
    187  2514		       ff		      BYTE.b	%11111111
    188  2515		       ff		      BYTE.b	%11111111
    189  2516		       00		      BYTE.b	%00000000
    190  2517		       00		      BYTE.b	%00000000
    191  2518		       00		      BYTE.b	%00000000
    192  2519		       00		      BYTE.b	%00000000
    193  251a		       00		      BYTE.b	%00000000
    194  251b		       00		      BYTE.b	%00000000
    195  251c		       00		      BYTE.b	%00000000
    196  251d		       00		      BYTE.b	%00000000
    197  251e		       00		      BYTE.b	%00000000
    198  251f		       00		      BYTE.b	%00000000
    199  2520		       00		      BYTE.b	%00000000
    200  2521		       00		      BYTE.b	%00000000
    201  2522		       00		      BYTE.b	%00000000
    202  2523		       00		      BYTE.b	%00000000
    203  2524		       00		      BYTE.b	%00000000
    204  2525		       00		      BYTE.b	%00000000
    205  2526		       00		      BYTE.b	%00000000
    206  2527		       00		      BYTE.b	%00000000
    207  2528
    208  2528
    209  2528
    210  2528				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    211  2528				  -	      align	256
    212  2528					      endif
    213  2528
    214  2528
    215  2528				   bmp_96x2_2_03
    216  2528							; *** replace this block with your bimap_03 data block...
    217  2528		       00		      BYTE.b	%00000000
    218  2529		       78		      BYTE.b	%01111000
    219  252a		       78		      BYTE.b	%01111000
    220  252b		       78		      BYTE.b	%01111000
    221  252c		       7f		      BYTE.b	%01111111
    222  252d		       78		      BYTE.b	%01111000
    223  252e		       78		      BYTE.b	%01111000
    224  252f		       78		      BYTE.b	%01111000
    225  2530		       1e		      BYTE.b	%00011110
    226  2531		       07		      BYTE.b	%00000111
    227  2532		       07		      BYTE.b	%00000111
    228  2533		       00		      BYTE.b	%00000000
    229  2534		       f8		      BYTE.b	%11111000
    230  2535		       f8		      BYTE.b	%11111000
    231  2536		       1e		      BYTE.b	%00011110
    232  2537		       1e		      BYTE.b	%00011110
    233  2538		       f8		      BYTE.b	%11111000
    234  2539		       f8		      BYTE.b	%11111000
    235  253a		       1e		      BYTE.b	%00011110
    236  253b		       1e		      BYTE.b	%00011110
    237  253c		       f8		      BYTE.b	%11111000
    238  253d		       f8		      BYTE.b	%11111000
    239  253e		       00		      BYTE.b	%00000000
    240  253f		       00		      BYTE.b	%00000000
    241  2540		       00		      BYTE.b	%00000000
    242  2541		       00		      BYTE.b	%00000000
    243  2542		       00		      BYTE.b	%00000000
    244  2543		       00		      BYTE.b	%00000000
    245  2544		       00		      BYTE.b	%00000000
    246  2545		       00		      BYTE.b	%00000000
    247  2546		       00		      BYTE.b	%00000000
    248  2547		       00		      BYTE.b	%00000000
    249  2548		       00		      BYTE.b	%00000000
    250  2549		       00		      BYTE.b	%00000000
    251  254a		       00		      BYTE.b	%00000000
    252  254b		       00		      BYTE.b	%00000000
    253  254c		       00		      BYTE.b	%00000000
    254  254d		       00		      BYTE.b	%00000000
    255  254e		       00		      BYTE.b	%00000000
    256  254f		       00		      BYTE.b	%00000000
    257  2550
    258  2550
    259  2550
    260  2550				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    261  2550				  -	      align	256
    262  2550					      endif
    263  2550
    264  2550
    265  2550				   bmp_96x2_2_04
    266  2550							; *** replace this block with your bimap_04 data block...
    267  2550		       00		      BYTE.b	%00000000
    268  2551		       0f		      BYTE.b	%00001111
    269  2552		       1f		      BYTE.b	%00011111
    270  2553		       1f		      BYTE.b	%00011111
    271  2554		       ff		      BYTE.b	%11111111
    272  2555		       1f		      BYTE.b	%00011111
    273  2556		       1f		      BYTE.b	%00011111
    274  2557		       1f		      BYTE.b	%00011111
    275  2558		       7c		      BYTE.b	%01111100
    276  2559		       f0		      BYTE.b	%11110000
    277  255a		       e0		      BYTE.b	%11100000
    278  255b		       00		      BYTE.b	%00000000
    279  255c		       3f		      BYTE.b	%00111111
    280  255d		       3f		      BYTE.b	%00111111
    281  255e		       3c		      BYTE.b	%00111100
    282  255f		       3c		      BYTE.b	%00111100
    283  2560		       3f		      BYTE.b	%00111111
    284  2561		       3f		      BYTE.b	%00111111
    285  2562		       3c		      BYTE.b	%00111100
    286  2563		       3c		      BYTE.b	%00111100
    287  2564		       3f		      BYTE.b	%00111111
    288  2565		       3f		      BYTE.b	%00111111
    289  2566		       00		      BYTE.b	%00000000
    290  2567		       00		      BYTE.b	%00000000
    291  2568		       01		      BYTE.b	%00000001
    292  2569		       00		      BYTE.b	%00000000
    293  256a		       00		      BYTE.b	%00000000
    294  256b		       00		      BYTE.b	%00000000
    295  256c		       00		      BYTE.b	%00000000
    296  256d		       00		      BYTE.b	%00000000
    297  256e		       00		      BYTE.b	%00000000
    298  256f		       00		      BYTE.b	%00000000
    299  2570		       00		      BYTE.b	%00000000
    300  2571		       00		      BYTE.b	%00000000
    301  2572		       01		      BYTE.b	%00000001
    302  2573		       01		      BYTE.b	%00000001
    303  2574		       00		      BYTE.b	%00000000
    304  2575		       00		      BYTE.b	%00000000
    305  2576		       00		      BYTE.b	%00000000
    306  2577		       00		      BYTE.b	%00000000
    307  2578
    308  2578
    309  2578
    310  2578				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    311  2578				  -	      align	256
    312  2578					      endif
    313  2578
    314  2578
    315  2578				   bmp_96x2_2_05
    316  2578							; *** replace this block with your bimap_05 data block...
    317  2578		       00		      BYTE.b	%00000000
    318  2579		       1e		      BYTE.b	%00011110
    319  257a		       3e		      BYTE.b	%00111110
    320  257b		       3e		      BYTE.b	%00111110
    321  257c		       3e		      BYTE.b	%00111110
    322  257d		       3e		      BYTE.b	%00111110
    323  257e		       3e		      BYTE.b	%00111110
    324  257f		       3f		      BYTE.b	%00111111
    325  2580		       3f		      BYTE.b	%00111111
    326  2581		       3e		      BYTE.b	%00111110
    327  2582		       1e		      BYTE.b	%00011110
    328  2583		       00		      BYTE.b	%00000000
    329  2584		       ff		      BYTE.b	%11111111
    330  2585		       ff		      BYTE.b	%11111111
    331  2586		       00		      BYTE.b	%00000000
    332  2587		       00		      BYTE.b	%00000000
    333  2588		       fc		      BYTE.b	%11111100
    334  2589		       fc		      BYTE.b	%11111100
    335  258a		       00		      BYTE.b	%00000000
    336  258b		       00		      BYTE.b	%00000000
    337  258c		       ff		      BYTE.b	%11111111
    338  258d		       ff		      BYTE.b	%11111111
    339  258e		       00		      BYTE.b	%00000000
    340  258f		       00		      BYTE.b	%00000000
    341  2590		       ff		      BYTE.b	%11111111
    342  2591		       00		      BYTE.b	%00000000
    343  2592		       7f		      BYTE.b	%01111111
    344  2593		       7f		      BYTE.b	%01111111
    345  2594		       07		      BYTE.b	%00000111
    346  2595		       37		      BYTE.b	%00110111
    347  2596		       37		      BYTE.b	%00110111
    348  2597		       30		      BYTE.b	%00110000
    349  2598		       32		      BYTE.b	%00110010
    350  2599		       3e		      BYTE.b	%00111110
    351  259a		       1f		      BYTE.b	%00011111
    352  259b		       ff		      BYTE.b	%11111111
    353  259c		       b7		      BYTE.b	%10110111
    354  259d		       0f		      BYTE.b	%00001111
    355  259e		       0e		      BYTE.b	%00001110
    356  259f		       00		      BYTE.b	%00000000
    357  25a0
    358  25a0
    359  25a0
    360  25a0				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    361  25a0				  -	      align	256
    362  25a0					      endif
    363  25a0
    364  25a0
    365  25a0				   bmp_96x2_2_06
    366  25a0							; *** replace this block with your bimap_06 data block...
    367  25a0		       00		      BYTE.b	%00000000
    368  25a1		       07		      BYTE.b	%00000111
    369  25a2		       07		      BYTE.b	%00000111
    370  25a3		       07		      BYTE.b	%00000111
    371  25a4		       1f		      BYTE.b	%00011111
    372  25a5		       7f		      BYTE.b	%01111111
    373  25a6		       ff		      BYTE.b	%11111111
    374  25a7		       e7		      BYTE.b	%11100111
    375  25a8		       87		      BYTE.b	%10000111
    376  25a9		       07		      BYTE.b	%00000111
    377  25aa		       07		      BYTE.b	%00000111
    378  25ab		       00		      BYTE.b	%00000000
    379  25ac		       1f		      BYTE.b	%00011111
    380  25ad		       1f		      BYTE.b	%00011111
    381  25ae		       1f		      BYTE.b	%00011111
    382  25af		       1f		      BYTE.b	%00011111
    383  25b0		       1f		      BYTE.b	%00011111
    384  25b1		       1f		      BYTE.b	%00011111
    385  25b2		       1f		      BYTE.b	%00011111
    386  25b3		       1f		      BYTE.b	%00011111
    387  25b4		       1f		      BYTE.b	%00011111
    388  25b5		       1f		      BYTE.b	%00011111
    389  25b6		       00		      BYTE.b	%00000000
    390  25b7		       00		      BYTE.b	%00000000
    391  25b8		       fc		      BYTE.b	%11111100
    392  25b9		       38		      BYTE.b	%00111000
    393  25ba		       fb		      BYTE.b	%11111011
    394  25bb		       f8		      BYTE.b	%11111000
    395  25bc		       f8		      BYTE.b	%11111000
    396  25bd		       f8		      BYTE.b	%11111000
    397  25be		       f8		      BYTE.b	%11111000
    398  25bf		       fb		      BYTE.b	%11111011
    399  25c0		       80		      BYTE.b	%10000000
    400  25c1		       3c		      BYTE.b	%00111100
    401  25c2		       f6		      BYTE.b	%11110110
    402  25c3		       da		      BYTE.b	%11011010
    403  25c4		       d4		      BYTE.b	%11010100
    404  25c5		       40		      BYTE.b	%01000000
    405  25c6		       80		      BYTE.b	%10000000
    406  25c7		       00		      BYTE.b	%00000000
    407  25c8
    408  25c8
    409  25c8
    410  25c8				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    411  25c8				  -	      align	256
    412  25c8					      endif
    413  25c8
    414  25c8
    415  25c8				   bmp_96x2_2_07
    416  25c8							; *** replace this block with your bimap_07 data block...
    417  25c8		       00		      BYTE.b	%00000000
    418  25c9		       83		      BYTE.b	%10000011
    419  25ca		       81		      BYTE.b	%10000001
    420  25cb		       80		      BYTE.b	%10000000
    421  25cc		       80		      BYTE.b	%10000000
    422  25cd		       80		      BYTE.b	%10000000
    423  25ce		       80		      BYTE.b	%10000000
    424  25cf		       80		      BYTE.b	%10000000
    425  25d0		       80		      BYTE.b	%10000000
    426  25d1		       83		      BYTE.b	%10000011
    427  25d2		       83		      BYTE.b	%10000011
    428  25d3		       00		      BYTE.b	%00000000
    429  25d4		       ff		      BYTE.b	%11111111
    430  25d5		       ff		      BYTE.b	%11111111
    431  25d6		       00		      BYTE.b	%00000000
    432  25d7		       00		      BYTE.b	%00000000
    433  25d8		       ff		      BYTE.b	%11111111
    434  25d9		       ff		      BYTE.b	%11111111
    435  25da		       00		      BYTE.b	%00000000
    436  25db		       00		      BYTE.b	%00000000
    437  25dc		       ff		      BYTE.b	%11111111
    438  25dd		       ff		      BYTE.b	%11111111
    439  25de		       00		      BYTE.b	%00000000
    440  25df		       00		      BYTE.b	%00000000
    441  25e0		       00		      BYTE.b	%00000000
    442  25e1		       00		      BYTE.b	%00000000
    443  25e2		       c0		      BYTE.b	%11000000
    444  25e3		       40		      BYTE.b	%01000000
    445  25e4		       40		      BYTE.b	%01000000
    446  25e5		       40		      BYTE.b	%01000000
    447  25e6		       40		      BYTE.b	%01000000
    448  25e7		       c0		      BYTE.b	%11000000
    449  25e8		       00		      BYTE.b	%00000000
    450  25e9		       00		      BYTE.b	%00000000
    451  25ea		       00		      BYTE.b	%00000000
    452  25eb		       00		      BYTE.b	%00000000
    453  25ec		       00		      BYTE.b	%00000000
    454  25ed		       00		      BYTE.b	%00000000
    455  25ee		       00		      BYTE.b	%00000000
    456  25ef		       00		      BYTE.b	%00000000
    457  25f0
    458  25f0
    459  25f0
    460  25f0					      if	>. != >[.+(bmp_96x2_2_height)]
    461  2600		       00 00 00 00*	      align	256
    462  2600					      endif
    463  2600
    464  2600
    465  2600				   bmp_96x2_2_08
    466  2600							; *** replace this block with your bimap_08 data block...
    467  2600		       00		      BYTE.b	%00000000
    468  2601		       ff		      BYTE.b	%11111111
    469  2602		       ff		      BYTE.b	%11111111
    470  2603		       1e		      BYTE.b	%00011110
    471  2604		       1e		      BYTE.b	%00011110
    472  2605		       1e		      BYTE.b	%00011110
    473  2606		       1e		      BYTE.b	%00011110
    474  2607		       1e		      BYTE.b	%00011110
    475  2608		       1e		      BYTE.b	%00011110
    476  2609		       ff		      BYTE.b	%11111111
    477  260a		       ff		      BYTE.b	%11111111
    478  260b		       00		      BYTE.b	%00000000
    479  260c		       c7		      BYTE.b	%11000111
    480  260d		       c7		      BYTE.b	%11000111
    481  260e		       07		      BYTE.b	%00000111
    482  260f		       07		      BYTE.b	%00000111
    483  2610		       07		      BYTE.b	%00000111
    484  2611		       07		      BYTE.b	%00000111
    485  2612		       07		      BYTE.b	%00000111
    486  2613		       07		      BYTE.b	%00000111
    487  2614		       c7		      BYTE.b	%11000111
    488  2615		       c7		      BYTE.b	%11000111
    489  2616		       00		      BYTE.b	%00000000
    490  2617		       00		      BYTE.b	%00000000
    491  2618		       00		      BYTE.b	%00000000
    492  2619		       00		      BYTE.b	%00000000
    493  261a		       00		      BYTE.b	%00000000
    494  261b		       00		      BYTE.b	%00000000
    495  261c		       00		      BYTE.b	%00000000
    496  261d		       00		      BYTE.b	%00000000
    497  261e		       00		      BYTE.b	%00000000
    498  261f		       00		      BYTE.b	%00000000
    499  2620		       00		      BYTE.b	%00000000
    500  2621		       00		      BYTE.b	%00000000
    501  2622		       00		      BYTE.b	%00000000
    502  2623		       00		      BYTE.b	%00000000
    503  2624		       00		      BYTE.b	%00000000
    504  2625		       00		      BYTE.b	%00000000
    505  2626		       00		      BYTE.b	%00000000
    506  2627		       00		      BYTE.b	%00000000
    507  2628
    508  2628
    509  2628
    510  2628				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    511  2628				  -	      align	256
    512  2628					      endif
    513  2628
    514  2628
    515  2628				   bmp_96x2_2_09
    516  2628							; *** replace this block with your bimap_09 data block...
    517  2628		       00		      BYTE.b	%00000000
    518  2629		       e3		      BYTE.b	%11100011
    519  262a		       e3		      BYTE.b	%11100011
    520  262b		       03		      BYTE.b	%00000011
    521  262c		       03		      BYTE.b	%00000011
    522  262d		       03		      BYTE.b	%00000011
    523  262e		       03		      BYTE.b	%00000011
    524  262f		       03		      BYTE.b	%00000011
    525  2630		       00		      BYTE.b	%00000000
    526  2631		       e0		      BYTE.b	%11100000
    527  2632		       e0		      BYTE.b	%11100000
    528  2633		       00		      BYTE.b	%00000000
    529  2634		       83		      BYTE.b	%10000011
    530  2635		       87		      BYTE.b	%10000111
    531  2636		       9f		      BYTE.b	%10011111
    532  2637		       ff		      BYTE.b	%11111111
    533  2638		       87		      BYTE.b	%10000111
    534  2639		       83		      BYTE.b	%10000011
    535  263a		       80		      BYTE.b	%10000000
    536  263b		       80		      BYTE.b	%10000000
    537  263c		       ff		      BYTE.b	%11111111
    538  263d		       ff		      BYTE.b	%11111111
    539  263e		       00		      BYTE.b	%00000000
    540  263f		       00		      BYTE.b	%00000000
    541  2640		       00		      BYTE.b	%00000000
    542  2641		       00		      BYTE.b	%00000000
    543  2642		       00		      BYTE.b	%00000000
    544  2643		       00		      BYTE.b	%00000000
    545  2644		       00		      BYTE.b	%00000000
    546  2645		       00		      BYTE.b	%00000000
    547  2646		       00		      BYTE.b	%00000000
    548  2647		       00		      BYTE.b	%00000000
    549  2648		       00		      BYTE.b	%00000000
    550  2649		       00		      BYTE.b	%00000000
    551  264a		       00		      BYTE.b	%00000000
    552  264b		       00		      BYTE.b	%00000000
    553  264c		       00		      BYTE.b	%00000000
    554  264d		       00		      BYTE.b	%00000000
    555  264e		       00		      BYTE.b	%00000000
    556  264f		       00		      BYTE.b	%00000000
    557  2650
    558  2650
    559  2650
    560  2650				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    561  2650				  -	      align	256
    562  2650					      endif
    563  2650
    564  2650
    565  2650				   bmp_96x2_2_10
    566  2650							; *** replace this block with your bimap_10 data block...
    567  2650		       00		      BYTE.b	%00000000
    568  2651		       c0		      BYTE.b	%11000000
    569  2652		       c0		      BYTE.b	%11000000
    570  2653		       c0		      BYTE.b	%11000000
    571  2654		       ff		      BYTE.b	%11111111
    572  2655		       c0		      BYTE.b	%11000000
    573  2656		       c0		      BYTE.b	%11000000
    574  2657		       c0		      BYTE.b	%11000000
    575  2658		       f3		      BYTE.b	%11110011
    576  2659		       3f		      BYTE.b	%00111111
    577  265a		       3f		      BYTE.b	%00111111
    578  265b		       00		      BYTE.b	%00000000
    579  265c		       f0		      BYTE.b	%11110000
    580  265d		       e0		      BYTE.b	%11100000
    581  265e		       c0		      BYTE.b	%11000000
    582  265f		       00		      BYTE.b	%00000000
    583  2660		       f0		      BYTE.b	%11110000
    584  2661		       f0		      BYTE.b	%11110000
    585  2662		       f0		      BYTE.b	%11110000
    586  2663		       f0		      BYTE.b	%11110000
    587  2664		       c0		      BYTE.b	%11000000
    588  2665		       c0		      BYTE.b	%11000000
    589  2666		       00		      BYTE.b	%00000000
    590  2667		       00		      BYTE.b	%00000000
    591  2668		       00		      BYTE.b	%00000000
    592  2669		       00		      BYTE.b	%00000000
    593  266a		       00		      BYTE.b	%00000000
    594  266b		       00		      BYTE.b	%00000000
    595  266c		       00		      BYTE.b	%00000000
    596  266d		       00		      BYTE.b	%00000000
    597  266e		       00		      BYTE.b	%00000000
    598  266f		       00		      BYTE.b	%00000000
    599  2670		       00		      BYTE.b	%00000000
    600  2671		       00		      BYTE.b	%00000000
    601  2672		       00		      BYTE.b	%00000000
    602  2673		       00		      BYTE.b	%00000000
    603  2674		       00		      BYTE.b	%00000000
    604  2675		       00		      BYTE.b	%00000000
    605  2676		       00		      BYTE.b	%00000000
    606  2677		       00		      BYTE.b	%00000000
    607  2678
    608  2678
    609  2678
    610  2678				  -	      if	>. != >[.+(bmp_96x2_2_height)]
    611  2678				  -	      align	256
    612  2678					      endif
    613  2678
    614  2678
    615  2678				   bmp_96x2_2_11
    616  2678							; *** replace this block with your bimap_11 data block...
    617  2678		       00		      BYTE.b	%00000000
    618  2679		       f8		      BYTE.b	%11111000
    619  267a		       f8		      BYTE.b	%11111000
    620  267b		       f8		      BYTE.b	%11111000
    621  267c		       f8		      BYTE.b	%11111000
    622  267d		       f8		      BYTE.b	%11111000
    623  267e		       f8		      BYTE.b	%11111000
    624  267f		       f8		      BYTE.b	%11111000
    625  2680		       e0		      BYTE.b	%11100000
    626  2681		       80		      BYTE.b	%10000000
    627  2682		       00		      BYTE.b	%00000000
    628  2683		       00		      BYTE.b	%00000000
    629  2684		       00		      BYTE.b	%00000000
    630  2685		       00		      BYTE.b	%00000000
    631  2686		       00		      BYTE.b	%00000000
    632  2687		       00		      BYTE.b	%00000000
    633  2688		       00		      BYTE.b	%00000000
    634  2689		       00		      BYTE.b	%00000000
    635  268a		       00		      BYTE.b	%00000000
    636  268b		       00		      BYTE.b	%00000000
    637  268c		       00		      BYTE.b	%00000000
    638  268d		       00		      BYTE.b	%00000000
    639  268e		       00		      BYTE.b	%00000000
    640  268f		       00		      BYTE.b	%00000000
    641  2690		       00		      BYTE.b	%00000000
    642  2691		       00		      BYTE.b	%00000000
    643  2692		       00		      BYTE.b	%00000000
    644  2693		       00		      BYTE.b	%00000000
    645  2694		       00		      BYTE.b	%00000000
    646  2695		       00		      BYTE.b	%00000000
    647  2696		       00		      BYTE.b	%00000000
    648  2697		       00		      BYTE.b	%00000000
    649  2698		       00		      BYTE.b	%00000000
    650  2699		       00		      BYTE.b	%00000000
    651  269a		       00		      BYTE.b	%00000000
    652  269b		       00		      BYTE.b	%00000000
    653  269c		       00		      BYTE.b	%00000000
    654  269d		       00		      BYTE.b	%00000000
    655  269e		       00		      BYTE.b	%00000000
    656  269f		       00		      BYTE.b	%00000000
------- FILE titlescreen/asm/titlescreen.asm
    277  26a0					      endif
    278  26a0					      ifconst	mk_96x2_3_on
------- FILE titlescreen/96x2_3_image.asm LEVEL 3 PASS 2
      0  26a0					      include	"titlescreen/96x2_3_image.asm"
      1  26a0
      2  26a0							;*** The height of the displayed data...
      3  26a0		       00 14	   bmp_96x2_3_window =	20
      4  26a0
      5  26a0							;*** The height of the bitmap data. This can be larger than 
      6  26a0							;*** the displayed data height, if you're scrolling or animating 
      7  26a0							;*** the data...
      8  26a0		       00 14	   bmp_96x2_3_height =	20
      9  26a0
     10  26a0
     11  26a0				  -	      if	>. != >[.+(bmp_96x2_3_height)]
     12  26a0				  -	      align	256
     13  26a0					      endif
     14  26a0		       00		      BYTE.b	$00	; leave this here!
     15  26a1
     16  26a1
     17  26a1							;*** The color of each line in the bitmap, in reverse order...
     18  26a1				   bmp_96x2_3_colors
     19  26a1		       42		      .byte.b	$42
     20  26a2		       42		      .byte.b	$42
     21  26a3		       42		      .byte.b	$42
     22  26a4		       42		      .byte.b	$42
     23  26a5		       42		      .byte.b	$42
     24  26a6		       42		      .byte.b	$42
     25  26a7		       42		      .byte.b	$42
     26  26a8		       42		      .byte.b	$42
     27  26a9		       42		      .byte.b	$42
     28  26aa		       42		      .byte.b	$42
     29  26ab		       42		      .byte.b	$42
     30  26ac		       42		      .byte.b	$42
     31  26ad		       42		      .byte.b	$42
     32  26ae		       42		      .byte.b	$42
     33  26af		       42		      .byte.b	$42
     34  26b0		       42		      .byte.b	$42
     35  26b1		       42		      .byte.b	$42
     36  26b2		       42		      .byte.b	$42
     37  26b3		       42		      .byte.b	$42
     38  26b4		       42		      .byte.b	$42
     39  26b5
     40  26b5
     41  26b5				  -	      if	>. != >[.+(bmp_96x2_3_height)]
     42  26b5				  -	      align	256
     43  26b5					      endif
     44  26b5
     45  26b5
     46  26b5				   bmp_96x2_3_00
     47  26b5							; *** replace this block with your bimap_00 data block...
     48  26b5		       00		      BYTE.b	%00000000
     49  26b6		       00		      BYTE.b	%00000000
     50  26b7		       00		      BYTE.b	%00000000
     51  26b8		       00		      BYTE.b	%00000000
     52  26b9		       00		      BYTE.b	%00000000
     53  26ba		       00		      BYTE.b	%00000000
     54  26bb		       00		      BYTE.b	%00000000
     55  26bc		       00		      BYTE.b	%00000000
     56  26bd		       00		      BYTE.b	%00000000
     57  26be		       00		      BYTE.b	%00000000
     58  26bf		       70		      BYTE.b	%01110000
     59  26c0		       70		      BYTE.b	%01110000
     60  26c1		       7f		      BYTE.b	%01111111
     61  26c2		       7f		      BYTE.b	%01111111
     62  26c3		       71		      BYTE.b	%01110001
     63  26c4		       71		      BYTE.b	%01110001
     64  26c5		       71		      BYTE.b	%01110001
     65  26c6		       7f		      BYTE.b	%01111111
     66  26c7		       7f		      BYTE.b	%01111111
     67  26c8		       00		      BYTE.b	%00000000
     68  26c9
     69  26c9
     70  26c9
     71  26c9				  -	      if	>. != >[.+(bmp_96x2_3_height)]
     72  26c9				  -	      align	256
     73  26c9					      endif
     74  26c9
     75  26c9
     76  26c9				   bmp_96x2_3_01
     77  26c9							; *** replace this block with your bimap_01 data block...
     78  26c9		       03		      BYTE.b	%00000011
     79  26ca		       03		      BYTE.b	%00000011
     80  26cb		       03		      BYTE.b	%00000011
     81  26cc		       03		      BYTE.b	%00000011
     82  26cd		       03		      BYTE.b	%00000011
     83  26ce		       03		      BYTE.b	%00000011
     84  26cf		       03		      BYTE.b	%00000011
     85  26d0		       0f		      BYTE.b	%00001111
     86  26d1		       0f		      BYTE.b	%00001111
     87  26d2		       00		      BYTE.b	%00000000
     88  26d3		       19		      BYTE.b	%00011001
     89  26d4		       3b		      BYTE.b	%00111011
     90  26d5		       3f		      BYTE.b	%00111111
     91  26d6		       bf		      BYTE.b	%10111111
     92  26d7		       b9		      BYTE.b	%10111001
     93  26d8		       b8		      BYTE.b	%10111000
     94  26d9		       b8		      BYTE.b	%10111000
     95  26da		       bf		      BYTE.b	%10111111
     96  26db		       1f		      BYTE.b	%00011111
     97  26dc		       00		      BYTE.b	%00000000
     98  26dd
     99  26dd
    100  26dd
    101  26dd				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    102  26dd				  -	      align	256
    103  26dd					      endif
    104  26dd
    105  26dd
    106  26dd				   bmp_96x2_3_02
    107  26dd							; *** replace this block with your bimap_02 data block...
    108  26dd		       07		      BYTE.b	%00000111
    109  26de		       87		      BYTE.b	%10000111
    110  26df		       8e		      BYTE.b	%10001110
    111  26e0		       8e		      BYTE.b	%10001110
    112  26e1		       8e		      BYTE.b	%10001110
    113  26e2		       8e		      BYTE.b	%10001110
    114  26e3		       8e		      BYTE.b	%10001110
    115  26e4		       ef		      BYTE.b	%11101111
    116  26e5		       e7		      BYTE.b	%11100111
    117  26e6		       00		      BYTE.b	%00000000
    118  26e7		       ef		      BYTE.b	%11101111
    119  26e8		       ef		      BYTE.b	%11101111
    120  26e9		       ce		      BYTE.b	%11001110
    121  26ea		       cf		      BYTE.b	%11001111
    122  26eb		       ef		      BYTE.b	%11101111
    123  26ec		       ee		      BYTE.b	%11101110
    124  26ed		       ee		      BYTE.b	%11101110
    125  26ee		       cf		      BYTE.b	%11001111
    126  26ef		       cf		      BYTE.b	%11001111
    127  26f0		       00		      BYTE.b	%00000000
    128  26f1
    129  26f1
    130  26f1
    131  26f1					      if	>. != >[.+(bmp_96x2_3_height)]
    132  2700		       00 00 00 00*	      align	256
    133  2700					      endif
    134  2700
    135  2700
    136  2700				   bmp_96x2_3_03
    137  2700							; *** replace this block with your bimap_03 data block...
    138  2700		       e0		      BYTE.b	%11100000
    139  2701		       f0		      BYTE.b	%11110000
    140  2702		       38		      BYTE.b	%00111000
    141  2703		       38		      BYTE.b	%00111000
    142  2704		       38		      BYTE.b	%00111000
    143  2705		       38		      BYTE.b	%00111000
    144  2706		       38		      BYTE.b	%00111000
    145  2707		       f0		      BYTE.b	%11110000
    146  2708		       e0		      BYTE.b	%11100000
    147  2709		       00		      BYTE.b	%00000000
    148  270a		       f1		      BYTE.b	%11110001
    149  270b		       f3		      BYTE.b	%11110011
    150  270c		       03		      BYTE.b	%00000011
    151  270d		       e1		      BYTE.b	%11100001
    152  270e		       e3		      BYTE.b	%11100011
    153  270f		       07		      BYTE.b	%00000111
    154  2710		       07		      BYTE.b	%00000111
    155  2711		       f3		      BYTE.b	%11110011
    156  2712		       f1		      BYTE.b	%11110001
    157  2713		       00		      BYTE.b	%00000000
    158  2714
    159  2714
    160  2714
    161  2714				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    162  2714				  -	      align	256
    163  2714					      endif
    164  2714
    165  2714
    166  2714				   bmp_96x2_3_04
    167  2714							; *** replace this block with your bimap_04 data block...
    168  2714		       00		      BYTE.b	%00000000
    169  2715		       01		      BYTE.b	%00000001
    170  2716		       01		      BYTE.b	%00000001
    171  2717		       00		      BYTE.b	%00000000
    172  2718		       00		      BYTE.b	%00000000
    173  2719		       01		      BYTE.b	%00000001
    174  271a		       01		      BYTE.b	%00000001
    175  271b		       01		      BYTE.b	%00000001
    176  271c		       00		      BYTE.b	%00000000
    177  271d		       00		      BYTE.b	%00000000
    178  271e		       f8		      BYTE.b	%11111000
    179  271f		       fd		      BYTE.b	%11111101
    180  2720		       1d		      BYTE.b	%00011101
    181  2721		       fc		      BYTE.b	%11111100
    182  2722		       f8		      BYTE.b	%11111000
    183  2723		       01		      BYTE.b	%00000001
    184  2724		       1d		      BYTE.b	%00011101
    185  2725		       f8		      BYTE.b	%11111000
    186  2726		       f0		      BYTE.b	%11110000
    187  2727		       00		      BYTE.b	%00000000
    188  2728
    189  2728
    190  2728
    191  2728				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    192  2728				  -	      align	256
    193  2728					      endif
    194  2728
    195  2728
    196  2728				   bmp_96x2_3_05
    197  2728							; *** replace this block with your bimap_05 data block...
    198  2728		       fc		      BYTE.b	%11111100
    199  2729		       fe		      BYTE.b	%11111110
    200  272a		       c6		      BYTE.b	%11000110
    201  272b		       06		      BYTE.b	%00000110
    202  272c		       fc		      BYTE.b	%11111100
    203  272d		       c0		      BYTE.b	%11000000
    204  272e		       c6		      BYTE.b	%11000110
    205  272f		       fe		      BYTE.b	%11111110
    206  2730		       fc		      BYTE.b	%11111100
    207  2731		       00		      BYTE.b	%00000000
    208  2732		       fc		      BYTE.b	%11111100
    209  2733		       fe		      BYTE.b	%11111110
    210  2734		       c6		      BYTE.b	%11000110
    211  2735		       7e		      BYTE.b	%01111110
    212  2736		       fc		      BYTE.b	%11111100
    213  2737		       c0		      BYTE.b	%11000000
    214  2738		       c6		      BYTE.b	%11000110
    215  2739		       fe		      BYTE.b	%11111110
    216  273a		       fc		      BYTE.b	%11111100
    217  273b		       00		      BYTE.b	%00000000
    218  273c
    219  273c
    220  273c
    221  273c
    222  273c				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    223  273c				  -	      align	256
    224  273c					      endif
    225  273c
    226  273c
    227  273c				   bmp_96x2_3_06
    228  273c							; *** replace this block with your bimap_06 data block...
    229  273c		       0c		      BYTE.b	%00001100
    230  273d		       0e		      BYTE.b	%00001110
    231  273e		       0e		      BYTE.b	%00001110
    232  273f		       0e		      BYTE.b	%00001110
    233  2740		       0e		      BYTE.b	%00001110
    234  2741		       0e		      BYTE.b	%00001110
    235  2742		       0e		      BYTE.b	%00001110
    236  2743		       3f		      BYTE.b	%00111111
    237  2744		       3f		      BYTE.b	%00111111
    238  2745		       00		      BYTE.b	%00000000
    239  2746		       00		      BYTE.b	%00000000
    240  2747		       00		      BYTE.b	%00000000
    241  2748		       00		      BYTE.b	%00000000
    242  2749		       00		      BYTE.b	%00000000
    243  274a		       00		      BYTE.b	%00000000
    244  274b		       00		      BYTE.b	%00000000
    245  274c		       00		      BYTE.b	%00000000
    246  274d		       00		      BYTE.b	%00000000
    247  274e		       00		      BYTE.b	%00000000
    248  274f		       00		      BYTE.b	%00000000
    249  2750
    250  2750
    251  2750
    252  2750				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    253  2750				  -	      align	256
    254  2750					      endif
    255  2750
    256  2750
    257  2750				   bmp_96x2_3_07
    258  2750							; *** replace this block with your bimap_07 data block...
    259  2750		       38		      BYTE.b	%00111000
    260  2751		       38		      BYTE.b	%00111000
    261  2752		       38		      BYTE.b	%00111000
    262  2753		       3f		      BYTE.b	%00111111
    263  2754		       38		      BYTE.b	%00111000
    264  2755		       38		      BYTE.b	%00111000
    265  2756		       1d		      BYTE.b	%00011101
    266  2757		       9f		      BYTE.b	%10011111
    267  2758		       8f		      BYTE.b	%10001111
    268  2759		       00		      BYTE.b	%00000000
    269  275a		       38		      BYTE.b	%00111000
    270  275b		       38		      BYTE.b	%00111000
    271  275c		       38		      BYTE.b	%00111000
    272  275d		       3f		      BYTE.b	%00111111
    273  275e		       3f		      BYTE.b	%00111111
    274  275f		       38		      BYTE.b	%00111000
    275  2760		       38		      BYTE.b	%00111000
    276  2761		       3f		      BYTE.b	%00111111
    277  2762		       3f		      BYTE.b	%00111111
    278  2763		       00		      BYTE.b	%00000000
    279  2764
    280  2764
    281  2764
    282  2764				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    283  2764				  -	      align	256
    284  2764					      endif
    285  2764
    286  2764
    287  2764				   bmp_96x2_3_08
    288  2764							; *** replace this block with your bimap_08 data block...
    289  2764		       cc		      BYTE.b	%11001100
    290  2765		       ed		      BYTE.b	%11101101
    291  2766		       ef		      BYTE.b	%11101111
    292  2767		       ef		      BYTE.b	%11101111
    293  2768		       ec		      BYTE.b	%11101100
    294  2769		       ec		      BYTE.b	%11101100
    295  276a		       cc		      BYTE.b	%11001100
    296  276b		       8f		      BYTE.b	%10001111
    297  276c		       0f		      BYTE.b	%00001111
    298  276d		       00		      BYTE.b	%00000000
    299  276e		       07		      BYTE.b	%00000111
    300  276f		       07		      BYTE.b	%00000111
    301  2770		       01		      BYTE.b	%00000001
    302  2771		       81		      BYTE.b	%10000001
    303  2772		       81		      BYTE.b	%10000001
    304  2773		       01		      BYTE.b	%00000001
    305  2774		       01		      BYTE.b	%00000001
    306  2775		       c7		      BYTE.b	%11000111
    307  2776		       c7		      BYTE.b	%11000111
    308  2777		       00		      BYTE.b	%00000000
    309  2778
    310  2778
    311  2778
    312  2778				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    313  2778				  -	      align	256
    314  2778					      endif
    315  2778
    316  2778
    317  2778				   bmp_96x2_3_09
    318  2778							; *** replace this block with your bimap_09 data block...
    319  2778		       f0		      BYTE.b	%11110000
    320  2779		       f0		      BYTE.b	%11110000
    321  277a		       e0		      BYTE.b	%11100000
    322  277b		       c0		      BYTE.b	%11000000
    323  277c		       f0		      BYTE.b	%11110000
    324  277d		       70		      BYTE.b	%01110000
    325  277e		       70		      BYTE.b	%01110000
    326  277f		       f3		      BYTE.b	%11110011
    327  2780		       e3		      BYTE.b	%11100011
    328  2781		       00		      BYTE.b	%00000000
    329  2782		       f7		      BYTE.b	%11110111
    330  2783		       f7		      BYTE.b	%11110111
    331  2784		       c7		      BYTE.b	%11000111
    332  2785		       c7		      BYTE.b	%11000111
    333  2786		       c7		      BYTE.b	%11000111
    334  2787		       c7		      BYTE.b	%11000111
    335  2788		       c7		      BYTE.b	%11000111
    336  2789		       f7		      BYTE.b	%11110111
    337  278a		       f7		      BYTE.b	%11110111
    338  278b		       00		      BYTE.b	%00000000
    339  278c
    340  278c
    341  278c
    342  278c				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    343  278c				  -	      align	256
    344  278c					      endif
    345  278c
    346  278c
    347  278c				   bmp_96x2_3_10
    348  278c							; *** replace this block with your bimap_10 data block...
    349  278c		       60		      BYTE.b	%01100000
    350  278d		       e0		      BYTE.b	%11100000
    351  278e		       e0		      BYTE.b	%11100000
    352  278f		       e0		      BYTE.b	%11100000
    353  2790		       e0		      BYTE.b	%11100000
    354  2791		       e0		      BYTE.b	%11100000
    355  2792		       e0		      BYTE.b	%11100000
    356  2793		       f8		      BYTE.b	%11111000
    357  2794		       f8		      BYTE.b	%11111000
    358  2795		       00		      BYTE.b	%00000000
    359  2796		       39		      BYTE.b	%00111001
    360  2797		       79		      BYTE.b	%01111001
    361  2798		       f1		      BYTE.b	%11110001
    362  2799		       f9		      BYTE.b	%11111001
    363  279a		       39		      BYTE.b	%00111001
    364  279b		       19		      BYTE.b	%00011001
    365  279c		       19		      BYTE.b	%00011001
    366  279d		       f9		      BYTE.b	%11111001
    367  279e		       f1		      BYTE.b	%11110001
    368  279f		       00		      BYTE.b	%00000000
    369  27a0
    370  27a0
    371  27a0				  -	      if	>. != >[.+(bmp_96x2_3_height)]
    372  27a0				  -	      align	256
    373  27a0					      endif
    374  27a0
    375  27a0
    376  27a0				   bmp_96x2_3_11
    377  27a0							; *** replace this block with your bimap_11 data block...
    378  27a0		       00		      BYTE.b	%00000000
    379  27a1		       00		      BYTE.b	%00000000
    380  27a2		       00		      BYTE.b	%00000000
    381  27a3		       00		      BYTE.b	%00000000
    382  27a4		       00		      BYTE.b	%00000000
    383  27a5		       00		      BYTE.b	%00000000
    384  27a6		       00		      BYTE.b	%00000000
    385  27a7		       00		      BYTE.b	%00000000
    386  27a8		       00		      BYTE.b	%00000000
    387  27a9		       00		      BYTE.b	%00000000
    388  27aa		       fe		      BYTE.b	%11111110
    389  27ab		       fe		      BYTE.b	%11111110
    390  27ac		       80		      BYTE.b	%10000000
    391  27ad		       f8		      BYTE.b	%11111000
    392  27ae		       fc		      BYTE.b	%11111100
    393  27af		       80		      BYTE.b	%10000000
    394  27b0		       80		      BYTE.b	%10000000
    395  27b1		       fe		      BYTE.b	%11111110
    396  27b2		       fe		      BYTE.b	%11111110
    397  27b3		       00		      BYTE.b	%00000000
------- FILE titlescreen/asm/titlescreen.asm
    280  27b4					      endif
    281  27b4				  -	      ifconst	mk_96x2_4_on
    282  27b4				  -	      include	"titlescreen/96x2_4_image.asm"
    283  27b4					      endif
    284  27b4				  -	      ifconst	mk_96x2_5_on
    285  27b4				  -	      include	"titlescreen/96x2_5_image.asm"
    286  27b4					      endif
    287  27b4				  -	      ifconst	mk_96x2_6_on
    288  27b4				  -	      include	"titlescreen/96x2_6_image.asm"
    289  27b4					      endif
    290  27b4				  -	      ifconst	mk_96x2_7_on
    291  27b4				  -	      include	"titlescreen/96x2_7_image.asm"
    292  27b4					      endif
    293  27b4				  -	      ifconst	mk_96x2_8_on
    294  27b4				  -	      include	"titlescreen/96x2_8_image.asm"
    295  27b4					      endif
    296  27b4
    297  27b4				  -	      ifconst	mk_player_on
    298  27b4				  -	      include	"titlescreen/player_image.asm"
    299  27b4					      endif
    300  27b4
    301  27b4				  -	      ifconst	mk_score_on
    302  27b4				  -	      include	"titlescreen/score_image.asm"
    303  27b4					      endif
    304  27b4
    305  27b4				  -	      ifconst	mk_gameselect_on
    306  27b4				  -	      include	"titlescreen/gameselect_image.asm"
    307  27b4					      endif
    308  27b4
    309  27b4				  -	      ifconst	mk_player_on
    310  27b4				  -	      include	"titlescreen/asm/player_kernel.asm"
    311  27b4					      endif		;mk_player_on
    312  27b4
    313  27b4
------- FILE beer_mania.bas.asm
    938  27b4
    939  27b4				   .
    940  27b4							;
    941  27b4
    942  27b4				   .L093		;  bank 3
    943  27b4
    944  27b4					      if	ECHO2
      2080 bytes of ROM space left in bank 2
    945  27b4					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
    946  27b4					      endif
    947  27b4		       00 01	   ECHO2      =	1
    948  2fd4					      ORG	$2FF4-bscode_length
    949  2fd4					      RORG	$BFF4-bscode_length
    950  2fd4		       a2 ff	   start_bank2 ldx	#$ff
    951  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
    952  2fd6				  -	      stx	FASTFETCH
    953  2fd6					      endif
    954  2fd6		       9a		      txs
    955  2fd7				  -	      if	bankswitch == 64
    956  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
    957  2fd7					      else
    958  2fd7		       a9 f2		      lda	#>(start-1)
    959  2fd9					      endif
    960  2fd9		       48		      pha
    961  2fda		       a9 51		      lda	#<(start-1)
    962  2fdc		       48		      pha
    963  2fdd		       48		      pha
    964  2fde		       8a		      txa
    965  2fdf		       48		      pha
    966  2fe0		       ba		      tsx
    967  2fe1					      if	bankswitch != 64
    968  2fe1		       b5 04		      lda	4,x	; get high byte of return address
    969  2fe3		       2a		      rol
    970  2fe4		       2a		      rol
    971  2fe5		       2a		      rol
    972  2fe6		       2a		      rol
    973  2fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
    974  2fe9		       aa		      tax
    975  2fea		       e8		      inx
    976  2feb				  -	      else
    977  2feb				  -	      lda	4,x	; get high byte of return address
    978  2feb				  -	      tay
    979  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
    980  2feb				  -	      sta	4,x
    981  2feb				  -	      tya
    982  2feb				  -	      lsr
    983  2feb				  -	      lsr
    984  2feb				  -	      lsr
    985  2feb				  -	      lsr
    986  2feb				  -	      tax
    987  2feb				  -	      inx
    988  2feb					      endif
    989  2feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
    990  2fee		       68		      pla
    991  2fef		       aa		      tax
    992  2ff0		       68		      pla
    993  2ff1		       60		      rts
    994  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
    995  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
    996  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
    997  2ff2					      endif
    998  2ffc					      ORG	$2FFC
    999  2ffc					      RORG	$BFFC
   1000  2ffc		       d4 bf		      .word.w	(start_bank2 & $ffff)
   1001  2ffe		       d4 bf		      .word.w	(start_bank2 & $ffff)
   1002  3000					      ORG	$3000
   1003  3000					      RORG	$D000
   1004  3000				   .__Game_Over_Setup
   1005  3000							; __Game_Over_Setup
   1006  3000
   1007  3000				   .
   1008  3000							;
   1009  3000
   1010  3000				   .L094		;  player0y  =  200 :	player1y  =  200
   1011  3000
   1012  3000		       a9 c8		      LDA	#200
   1013  3002		       85 85		      STA	player0y
   1014  3004		       85 86		      STA	player1y
   1015  3006				   .
   1016  3006							;
   1017  3006
   1018  3006				   .L095		;  playfield:
   1019  3006
   1020  3006				  -	      ifconst	pfres
   1021  3006				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   1022  3006					      else
   1023  3006		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   1024  3008					      endif
   1025  3008		       4c 37 d0 	      jmp	pflabel1
   1026  300b				   PF_data1
   1027  300b		       7e bf		      .byte.b	%01111110, %10111111
   1028  300d					      if	(pfwidth>2)
   1029  300d		       ff 7d		      .byte.b	%11111111, %01111101
   1030  300f					      endif
   1031  300f		       60 b3		      .byte.b	%01100000, %10110011
   1032  3011					      if	(pfwidth>2)
   1033  3011		       99 0d		      .byte.b	%10011001, %00001101
   1034  3013					      endif
   1035  3013		       6e bf		      .byte.b	%01101110, %10111111
   1036  3015					      if	(pfwidth>2)
   1037  3015		       99 3d		      .byte.b	%10011001, %00111101
   1038  3017					      endif
   1039  3017		       66 b3		      .byte.b	%01100110, %10110011
   1040  3019					      if	(pfwidth>2)
   1041  3019		       99 0d		      .byte.b	%10011001, %00001101
   1042  301b					      endif
   1043  301b		       7e b3		      .byte.b	%01111110, %10110011
   1044  301d					      if	(pfwidth>2)
   1045  301d		       99 7d		      .byte.b	%10011001, %01111101
   1046  301f					      endif
   1047  301f		       00 00		      .byte.b	%00000000, %00000000
   1048  3021					      if	(pfwidth>2)
   1049  3021		       00 00		      .byte.b	%00000000, %00000000
   1050  3023					      endif
   1051  3023		       1f cd		      .byte.b	%00011111, %11001101
   1052  3025					      if	(pfwidth>2)
   1053  3025		       7d 1f		      .byte.b	%01111101, %00011111
   1054  3027					      endif
   1055  3027		       19 cd		      .byte.b	%00011001, %11001101
   1056  3029					      if	(pfwidth>2)
   1057  3029		       61 19		      .byte.b	%01100001, %00011001
   1058  302b					      endif
   1059  302b		       19 cd		      .byte.b	%00011001, %11001101
   1060  302d					      if	(pfwidth>2)
   1061  302d		       79 0f		      .byte.b	%01111001, %00001111
   1062  302f					      endif
   1063  302f		       19 cd		      .byte.b	%00011001, %11001101
   1064  3031					      if	(pfwidth>2)
   1065  3031		       61 19		      .byte.b	%01100001, %00011001
   1066  3033					      endif
   1067  3033		       1f 31		      .byte.b	%00011111, %00110001
   1068  3035					      if	(pfwidth>2)
   1069  3035		       7d 19		      .byte.b	%01111101, %00011001
   1070  3037					      endif
   1071  3037				   pflabel1
   1072  3037		       bd 0b d0 	      lda	PF_data1,x
   1073  303a		       95 a4		      sta	playfield,x
   1074  303c		       ca		      dex
   1075  303d		       10 f8		      bpl	pflabel1
   1076  303f				   .
   1077  303f							;
   1078  303f
   1079  303f				   .pfcolors
   1080  303f							; pfcolors:
   1081  303f
   1082  303f				   .$CA
   1083  303f							; $CA
   1084  303f
   1085  303f				   .$CA
   1086  303f							; $CA
   1087  303f
   1088  303f				   .$CA
   1089  303f							; $CA
   1090  303f
   1091  303f				   .$CA
   1092  303f							; $CA
   1093  303f
   1094  303f				   .$CA
   1095  303f							; $CA
   1096  303f
   1097  303f				   .$CA
   1098  303f							; $CA
   1099  303f
   1100  303f				   .$CA
   1101  303f							; $CA
   1102  303f
   1103  303f				   .$CA
   1104  303f							; $CA
   1105  303f
   1106  303f				   .$CA
   1107  303f							; $CA
   1108  303f
   1109  303f				   .$CA
   1110  303f							; $CA
   1111  303f
   1112  303f				   .$CA
   1113  303f							; $CA
   1114  303f
   1115  303f				   .
   1116  303f							;
   1117  303f
   1118  303f				   .gameover_loop
   1119  303f							; gameover_loop
   1120  303f
   1121  303f				   .L096		;  drawscreen
   1122  303f
   1123  303f		       85 ee		      sta	temp7
   1124  3041		       a9 d0		      lda	#>(ret_point4-1)
   1125  3043		       48		      pha
   1126  3044		       a9 56		      lda	#<(ret_point4-1)
   1127  3046		       48		      pha
   1128  3047		       a9 f4		      lda	#>(drawscreen-1)
   1129  3049		       48		      pha
   1130  304a		       a9 3b		      lda	#<(drawscreen-1)
   1131  304c		       48		      pha
   1132  304d		       a5 ee		      lda	temp7
   1133  304f		       48		      pha
   1134  3050		       8a		      txa
   1135  3051		       48		      pha
   1136  3052		       a2 04		      ldx	#4
   1137  3054		       4c eb ff 	      jmp	BS_jsr
   1138  3057				   ret_point4
   1139  3057				   .L097		;  if joy0fire  ||  switchreset then player0y = 200 : goto gamestart
   1140  3057
   1141  3057		       24 0c		      bit	INPT4
   1142  3059		       30 03		      BMI	.skipL097
   1143  305b				   .condpart28
   1144  305b		       4c 65 d0 	      jmp	.condpart29
   1145  305e				   .skipL097
   1146  305e		       a9 01		      lda	#1
   1147  3060		       2c 82 02 	      bit	SWCHB
   1148  3063		       d0 07		      BNE	.skip2OR
   1149  3065				   .condpart29
   1150  3065		       a9 c8		      LDA	#200
   1151  3067		       85 85		      STA	player0y
   1152  3069		       4c ac 90 	      jmp	.gamestart
   1153  306c
   1154  306c				   .skip2OR
   1155  306c				   .L098		;  goto gameover_loop
   1156  306c		       4c 3f d0 	      jmp	.gameover_loop
   1157  306f					      if	ECHO3
      3941 bytes of ROM space left in bank 3
   1158  306f					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   1159  306f					      endif
   1160  306f		       00 01	   ECHO3      =	1
   1161  3fd4					      ORG	$3FF4-bscode_length
   1162  3fd4					      RORG	$DFF4-bscode_length
   1163  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   1164  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1165  3fd6				  -	      stx	FASTFETCH
   1166  3fd6					      endif
   1167  3fd6		       9a		      txs
   1168  3fd7				  -	      if	bankswitch == 64
   1169  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1170  3fd7					      else
   1171  3fd7		       a9 f2		      lda	#>(start-1)
   1172  3fd9					      endif
   1173  3fd9		       48		      pha
   1174  3fda		       a9 51		      lda	#<(start-1)
   1175  3fdc		       48		      pha
   1176  3fdd		       48		      pha
   1177  3fde		       8a		      txa
   1178  3fdf		       48		      pha
   1179  3fe0		       ba		      tsx
   1180  3fe1					      if	bankswitch != 64
   1181  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   1182  3fe3		       2a		      rol
   1183  3fe4		       2a		      rol
   1184  3fe5		       2a		      rol
   1185  3fe6		       2a		      rol
   1186  3fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1187  3fe9		       aa		      tax
   1188  3fea		       e8		      inx
   1189  3feb				  -	      else
   1190  3feb				  -	      lda	4,x	; get high byte of return address
   1191  3feb				  -	      tay
   1192  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1193  3feb				  -	      sta	4,x
   1194  3feb				  -	      tya
   1195  3feb				  -	      lsr
   1196  3feb				  -	      lsr
   1197  3feb				  -	      lsr
   1198  3feb				  -	      lsr
   1199  3feb				  -	      tax
   1200  3feb				  -	      inx
   1201  3feb					      endif
   1202  3feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1203  3fee		       68		      pla
   1204  3fef		       aa		      tax
   1205  3ff0		       68		      pla
   1206  3ff1		       60		      rts
   1207  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1208  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1209  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1210  3ff2					      endif
   1211  3ffc					      ORG	$3FFC
   1212  3ffc					      RORG	$DFFC
   1213  3ffc		       d4 df		      .word.w	(start_bank3 & $ffff)
   1214  3ffe		       d4 df		      .word.w	(start_bank3 & $ffff)
   1215  4000					      ORG	$4000
   1216  4000					      RORG	$F000
   1217  4000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1218  4000
   1219  4000							; This is a 2-line kernel!
   1220  4000					      ifnconst	vertical_reflect
   1221  4000				   kernel
   1222  4000					      endif
   1223  4000		       85 02		      sta	WSYNC
   1224  4002		       a9 ff		      lda	#255
   1225  4004		       8d 96 02 	      sta	TIM64T
   1226  4007
   1227  4007		       a9 01		      lda	#1
   1228  4009		       85 27		      sta	VDELBL
   1229  400b		       85 25		      sta	VDELP0
   1230  400d		       a6 92		      ldx	ballheight
   1231  400f		       e8		      inx
   1232  4010		       e8		      inx
   1233  4011		       86 9f		      stx	temp4
   1234  4013		       a5 86		      lda	player1y
   1235  4015		       85 9e		      sta	temp3
   1236  4017
   1237  4017				  -	      ifconst	shakescreen
   1238  4017				  -	      jsr	doshakescreen
   1239  4017					      else
   1240  4017		       a6 90		      ldx	missile0height
   1241  4019		       e8		      inx
   1242  401a					      endif
   1243  401a
   1244  401a		       e8		      inx
   1245  401b		       86 f6		      stx	stack1
   1246  401d
   1247  401d		       a5 89		      lda	bally
   1248  401f		       85 f7		      sta	stack2
   1249  4021
   1250  4021		       a5 85		      lda	player0y
   1251  4023		       a2 00		      ldx	#0
   1252  4025		       85 02		      sta	WSYNC
   1253  4027		       86 1b		      stx	GRP0
   1254  4029		       86 1c		      stx	GRP1
   1255  402b		       86 0e		      stx	PF1L
   1256  402d		       86 0f		      stx	PF2
   1257  402f		       86 2c		      stx	CXCLR
   1258  4031				  -	      ifconst	readpaddle
   1259  4031				  -	      stx	paddle
   1260  4031					      else
      0  4031					      sleep	3
      1  4031				   .CYCLES    SET	3
      2  4031
      3  4031				  -	      IF	.CYCLES < 2
      4  4031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4031				  -	      ERR
      6  4031					      ENDIF
      7  4031
      8  4031					      IF	.CYCLES & 1
      9  4031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4031		       04 00		      nop	0
     11  4033				  -	      ELSE
     12  4033				  -	      bit	VSYNC
     13  4033					      ENDIF
     14  4033				   .CYCLES    SET	.CYCLES - 3
     15  4033					      ENDIF
     16  4033
     17  4033				  -	      REPEAT	.CYCLES / 2
     18  4033				  -	      nop
     19  4033					      REPEND
   1262  4033					      endif
   1263  4033
   1264  4033		       95 9d		      sta	temp2,x
   1265  4035
   1266  4035							;store these so they can be retrieved later
   1267  4035					      ifnconst	pfres
   1268  4035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   1269  4037				  -	      else
   1270  4037				  -	      ldx	#132-pfres*pfwidth
   1271  4037					      endif
   1272  4037
   1273  4037		       c6 85		      dec	player0y
   1274  4039
   1275  4039		       a5 91		      lda	missile0y
   1276  403b		       85 a0		      sta	temp5
   1277  403d		       a5 88		      lda	missile1y
   1278  403f		       85 a1		      sta	temp6
   1279  4041
   1280  4041		       a5 ef		      lda	playfieldpos
   1281  4043		       85 9c		      sta	temp1
   1282  4045
   1283  4045				  -	      ifconst	pfrowheight
   1284  4045				  -	      lda	#pfrowheight+2
   1285  4045					      else
   1286  4045					      ifnconst	pfres
   1287  4045		       a9 0a		      lda	#10
   1288  4047				  -	      else
   1289  4047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1290  4047					      endif
   1291  4047					      endif
   1292  4047		       18		      clc
   1293  4048		       e5 ef		      sbc	playfieldpos
   1294  404a		       85 ef		      sta	playfieldpos
   1295  404c		       4c 74 f0 	      jmp	.startkernel
   1296  404f
   1297  404f				   .skipDrawP0
   1298  404f		       a9 00		      lda	#0
   1299  4051		       a8		      tay
   1300  4052		       4c a2 f0 	      jmp	.continueP0
   1301  4055
   1302  4055				   .skipDrawP1
   1303  4055		       a9 00		      lda	#0
   1304  4057		       a8		      tay
   1305  4058		       4c 7e f0 	      jmp	.continueP1
   1306  405b
   1307  405b				   .kerloop		; enter at cycle 59??
   1308  405b
   1309  405b				   continuekernel
      0  405b					      sleep	2
      1  405b				   .CYCLES    SET	2
      2  405b
      3  405b				  -	      IF	.CYCLES < 2
      4  405b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  405b				  -	      ERR
      6  405b					      ENDIF
      7  405b
      8  405b				  -	      IF	.CYCLES & 1
      9  405b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  405b				  -	      nop	0
     11  405b				  -	      ELSE
     12  405b				  -	      bit	VSYNC
     13  405b				  -	      ENDIF
     14  405b				  -.CYCLES    SET	.CYCLES - 3
     15  405b					      ENDIF
     16  405b
     17  405b					      REPEAT	.CYCLES / 2
     18  405b		       ea		      nop
     19  405c					      REPEND
   1311  405c				   continuekernel2
   1312  405c		       a5 92		      lda	ballheight
   1313  405e
   1314  405e				  -	      ifconst	pfres
   1315  405e				  -	      ldy	playfield+pfres*pfwidth-132,x
   1316  405e				  -	      sty	PF1L	;3
   1317  405e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   1318  405e				  -	      sty	PF2L	;3
   1319  405e				  -	      ldy	playfield+pfres*pfwidth-129,x
   1320  405e				  -	      sty	PF1R	; 3 too early?
   1321  405e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   1322  405e				  -	      sty	PF2R	;3
   1323  405e					      else
   1324  405e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   1325  4060		       84 0e		      sty	PF1L	;3
   1326  4062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1327  4064		       84 0f		      sty	PF2L	;3
   1328  4066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   1329  4068		       84 0e		      sty	PF1R	; 3 too early?
   1330  406a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1331  406c		       84 0f		      sty	PF2R	;3
   1332  406e					      endif
   1333  406e
   1334  406e							; should be playfield+$38 for width=2
   1335  406e
   1336  406e		       c7 89		      dcp	bally
   1337  4070		       2a		      rol
   1338  4071		       2a		      rol
   1339  4072							; rol
   1340  4072							; rol
   1341  4072				   goback
   1342  4072		       85 1f		      sta	ENABL
   1343  4074				   .startkernel
   1344  4074		       a5 8f		      lda	player1height	;3
   1345  4076		       c7 86		      dcp	player1y	;5
   1346  4078		       90 db		      bcc	.skipDrawP1	;2
   1347  407a		       a4 86		      ldy	player1y	;3
   1348  407c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1349  407e							; so it doesn't cross a page boundary!
   1350  407e
   1351  407e				   .continueP1
   1352  407e		       85 1c		      sta	GRP1	;3
   1353  4080
   1354  4080				  -	      ifnconst	player1colors
   1355  4080				  -	      lda	missile1height	;3
   1356  4080				  -	      dcp	missile1y	;5
   1357  4080				  -	      rol		;2
   1358  4080				  -	      rol		;2
   1359  4080				  -	      sta	ENAM1	;3
   1360  4080					      else
   1361  4080		       b1 87		      lda	(player1color),y
   1362  4082		       85 07		      sta	COLUP1
   1363  4084					      ifnconst	playercolors
      0  4084					      sleep	7
      1  4084				   .CYCLES    SET	7
      2  4084
      3  4084				  -	      IF	.CYCLES < 2
      4  4084				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4084				  -	      ERR
      6  4084					      ENDIF
      7  4084
      8  4084					      IF	.CYCLES & 1
      9  4084					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4084		       04 00		      nop	0
     11  4086				  -	      ELSE
     12  4086				  -	      bit	VSYNC
     13  4086					      ENDIF
     14  4086				   .CYCLES    SET	.CYCLES - 3
     15  4086					      ENDIF
     16  4086
     17  4086					      REPEAT	.CYCLES / 2
     18  4086		       ea		      nop
     17  4086					      REPEND
     18  4087		       ea		      nop
     19  4088					      REPEND
   1365  4088				  -	      else
   1366  4088				  -	      lda.w	player0colorstore
   1367  4088				  -	      sta	COLUP0
   1368  4088					      endif
   1369  4088					      endif
   1370  4088
   1371  4088				  -	      ifconst	pfres
   1372  4088				  -	      lda	playfield+pfres*pfwidth-132,x
   1373  4088				  -	      sta	PF1L	;3
   1374  4088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   1375  4088				  -	      sta	PF2L	;3
   1376  4088				  -	      lda	playfield+pfres*pfwidth-129,x
   1377  4088				  -	      sta	PF1R	; 3 too early?
   1378  4088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   1379  4088				  -	      sta	PF2R	;3
   1380  4088					      else
   1381  4088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   1382  408a		       85 0e		      sta	PF1L	;3
   1383  408c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1384  408e		       85 0f		      sta	PF2L	;3
   1385  4090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   1386  4092		       85 0e		      sta	PF1R	; 3 too early?
   1387  4094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1388  4096		       85 0f		      sta	PF2R	;3
   1389  4098					      endif
   1390  4098							; sleep 3
   1391  4098
   1392  4098		       a5 8e		      lda	player0height
   1393  409a		       c7 85		      dcp	player0y
   1394  409c		       90 b1		      bcc	.skipDrawP0
   1395  409e		       a4 85		      ldy	player0y
   1396  40a0		       b1 8a		      lda	(player0pointer),y
   1397  40a2				   .continueP0
   1398  40a2		       85 1b		      sta	GRP0
   1399  40a4
   1400  40a4				  -	      ifnconst	no_blank_lines
   1401  40a4				  -	      ifnconst	playercolors
   1402  40a4				  -	      lda	missile0height	;3
   1403  40a4				  -	      dcp	missile0y	;5
   1404  40a4				  -	      sbc	stack1
   1405  40a4				  -	      sta	ENAM0	;3
   1406  40a4				  -	      else
   1407  40a4				  -	      lda	(player0color),y
   1408  40a4				  -	      sta	player0colorstore
   1409  40a4				  -	      sleep	6
   1410  40a4				  -	      endif
   1411  40a4				  -	      dec	temp1
   1412  40a4				  -	      bne	continuekernel
   1413  40a4					      else
   1414  40a4		       c6 9c		      dec	temp1
   1415  40a6		       f0 0c		      beq	altkernel2
   1416  40a8				  -	      ifconst	readpaddle
   1417  40a8				  -	      ldy	currentpaddle
   1418  40a8				  -	      lda	INPT0,y
   1419  40a8				  -	      bpl	noreadpaddle
   1420  40a8				  -	      inc	paddle
   1421  40a8				  -	      jmp	continuekernel2
   1422  40a8				  -noreadpaddle
   1423  40a8				  -	      sleep	2
   1424  40a8				  -	      jmp	continuekernel
   1425  40a8					      else
   1426  40a8					      ifnconst	playercolors
   1427  40a8					      ifconst	PFcolors
   1428  40a8		       8a		      txa
   1429  40a9		       a8		      tay
   1430  40aa		       b1 f0		      lda	(pfcolortable),y
   1431  40ac					      ifnconst	backgroundchange
   1432  40ac		       85 08		      sta	COLUPF
   1433  40ae				  -	      else
   1434  40ae				  -	      sta	COLUBK
   1435  40ae					      endif
   1436  40ae		       4c 5b f0 	      jmp	continuekernel
   1437  40b1				  -	      else
   1438  40b1				  -	      ifconst	kernelmacrodef
   1439  40b1				  -	      kernelmacro
   1440  40b1				  -	      else
   1441  40b1				  -	      sleep	12
   1442  40b1				  -	      endif
   1443  40b1					      endif
   1444  40b1				  -	      else
   1445  40b1				  -	      lda	(player0color),y
   1446  40b1				  -	      sta	player0colorstore
   1447  40b1				  -	      sleep	4
   1448  40b1					      endif
   1449  40b1		       4c 5b f0 	      jmp	continuekernel
   1450  40b4					      endif
   1451  40b4				   altkernel2
   1452  40b4		       8a		      txa
   1453  40b5					      ifnconst	vertical_reflect
   1454  40b5		       cb fc		      sbx	#256-pfwidth
   1455  40b7				  -	      else
   1456  40b7				  -	      sbx	#256-pfwidth/2
   1457  40b7					      endif
   1458  40b7		       30 24		      bmi	lastkernelline
   1459  40b9				  -	      ifconst	pfrowheight
   1460  40b9				  -	      lda	#pfrowheight
   1461  40b9					      else
   1462  40b9					      ifnconst	pfres
   1463  40b9		       a9 08		      lda	#8
   1464  40bb				  -	      else
   1465  40bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   1466  40bb					      endif
   1467  40bb					      endif
   1468  40bb		       85 9c		      sta	temp1
   1469  40bd		       4c 5b f0 	      jmp	continuekernel
   1470  40c0					      endif
   1471  40c0
   1472  40c0				   altkernel
   1473  40c0
   1474  40c0				  -	      ifconst	PFmaskvalue
   1475  40c0				  -	      lda	#PFmaskvalue
   1476  40c0					      else
   1477  40c0		       a9 00		      lda	#0
   1478  40c2					      endif
   1479  40c2		       85 0e		      sta	PF1L
   1480  40c4		       85 0f		      sta	PF2
   1481  40c6
   1482  40c6
   1483  40c6							;sleep 3
   1484  40c6
   1485  40c6							;28 cycles to fix things
   1486  40c6							;minus 11=17
   1487  40c6
   1488  40c6							; lax temp4
   1489  40c6							; clc
   1490  40c6		       8a		      txa
   1491  40c7					      ifnconst	vertical_reflect
   1492  40c7		       cb fc		      sbx	#256-pfwidth
   1493  40c9				  -	      else
   1494  40c9				  -	      sbx	#256-pfwidth/2
   1495  40c9					      endif
   1496  40c9
   1497  40c9		       30 12		      bmi	lastkernelline
   1498  40cb
   1499  40cb				  -	      ifconst	PFcolorandheight
   1500  40cb				  -	      ifconst	pfres
   1501  40cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   1502  40cb				  -	      else
   1503  40cb				  -	      ldy	playfieldcolorandheight-87,x
   1504  40cb				  -	      endif
   1505  40cb				  -	      ifnconst	backgroundchange
   1506  40cb				  -	      sty	COLUPF
   1507  40cb				  -	      else
   1508  40cb				  -	      sty	COLUBK
   1509  40cb				  -	      endif
   1510  40cb				  -	      ifconst	pfres
   1511  40cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   1512  40cb				  -	      else
   1513  40cb				  -	      lda	playfieldcolorandheight-88,x
   1514  40cb				  -	      endif
   1515  40cb				  -	      sta.w	temp1
   1516  40cb					      endif
   1517  40cb				  -	      ifconst	PFheights
   1518  40cb				  -	      lsr
   1519  40cb				  -	      lsr
   1520  40cb				  -	      tay
   1521  40cb				  -	      lda	(pfheighttable),y
   1522  40cb				  -	      sta.w	temp1
   1523  40cb					      endif
   1524  40cb					      ifconst	PFcolors
   1525  40cb		       a8		      tay
   1526  40cc		       b1 f0		      lda	(pfcolortable),y
   1527  40ce					      ifnconst	backgroundchange
   1528  40ce		       85 08		      sta	COLUPF
   1529  40d0				  -	      else
   1530  40d0				  -	      sta	COLUBK
   1531  40d0					      endif
   1532  40d0				  -	      ifconst	pfrowheight
   1533  40d0				  -	      lda	#pfrowheight
   1534  40d0					      else
   1535  40d0					      ifnconst	pfres
   1536  40d0		       a9 08		      lda	#8
   1537  40d2				  -	      else
   1538  40d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   1539  40d2					      endif
   1540  40d2					      endif
   1541  40d2		       85 9c		      sta	temp1
   1542  40d4					      endif
   1543  40d4					      ifnconst	PFcolorandheight
   1544  40d4				  -	      ifnconst	PFcolors
   1545  40d4				  -	      ifnconst	PFheights
   1546  40d4				  -	      ifnconst	no_blank_lines
   1547  40d4				  -			; read paddle 0
   1548  40d4				  -			; lo-res paddle read
   1549  40d4				  -			; bit INPT0
   1550  40d4				  -			; bmi paddleskipread
   1551  40d4				  -			; inc paddle0
   1552  40d4				  -			;donepaddleskip
   1553  40d4				  -	      sleep	10
   1554  40d4				  -	      ifconst	pfrowheight
   1555  40d4				  -	      lda	#pfrowheight
   1556  40d4				  -	      else
   1557  40d4				  -	      ifnconst	pfres
   1558  40d4				  -	      lda	#8
   1559  40d4				  -	      else
   1560  40d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   1561  40d4				  -	      endif
   1562  40d4				  -	      endif
   1563  40d4				  -	      sta	temp1
   1564  40d4				  -	      endif
   1565  40d4				  -	      endif
   1566  40d4					      endif
   1567  40d4					      endif
   1568  40d4
   1569  40d4
   1570  40d4		       a5 92		      lda	ballheight
   1571  40d6		       c7 89		      dcp	bally
   1572  40d8		       e5 9f		      sbc	temp4
   1573  40da
   1574  40da
   1575  40da		       4c 72 f0 	      jmp	goback
   1576  40dd
   1577  40dd
   1578  40dd				  -	      ifnconst	no_blank_lines
   1579  40dd				  -lastkernelline
   1580  40dd				  -	      ifnconst	PFcolors
   1581  40dd				  -	      sleep	10
   1582  40dd				  -	      else
   1583  40dd				  -	      ldy	#124
   1584  40dd				  -	      lda	(pfcolortable),y
   1585  40dd				  -	      sta	COLUPF
   1586  40dd				  -	      endif
   1587  40dd				  -
   1588  40dd				  -	      ifconst	PFheights
   1589  40dd				  -	      ldx	#1
   1590  40dd				  -			;sleep 4
   1591  40dd				  -	      sleep	3	; this was over 1 cycle
   1592  40dd				  -	      else
   1593  40dd				  -	      ldx	playfieldpos
   1594  40dd				  -			;sleep 3
   1595  40dd				  -	      sleep	2	; this was over 1 cycle
   1596  40dd				  -	      endif
   1597  40dd				  -
   1598  40dd				  -	      jmp	enterlastkernel
   1599  40dd				  -
   1600  40dd					      else
   1601  40dd				   lastkernelline
   1602  40dd
   1603  40dd				  -	      ifconst	PFheights
   1604  40dd				  -	      ldx	#1
   1605  40dd				  -			;sleep 5
   1606  40dd				  -	      sleep	4	; this was over 1 cycle
   1607  40dd					      else
   1608  40dd		       a6 ef		      ldx	playfieldpos
   1609  40df							;sleep 4
      0  40df					      sleep	3	; this was over 1 cycle
      1  40df				   .CYCLES    SET	3
      2  40df
      3  40df				  -	      IF	.CYCLES < 2
      4  40df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  40df				  -	      ERR
      6  40df					      ENDIF
      7  40df
      8  40df					      IF	.CYCLES & 1
      9  40df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  40df		       04 00		      nop	0
     11  40e1				  -	      ELSE
     12  40e1				  -	      bit	VSYNC
     13  40e1					      ENDIF
     14  40e1				   .CYCLES    SET	.CYCLES - 3
     15  40e1					      ENDIF
     16  40e1
     17  40e1				  -	      REPEAT	.CYCLES / 2
     18  40e1				  -	      nop
     19  40e1					      REPEND
   1611  40e1					      endif
   1612  40e1
   1613  40e1		       e0 00		      cpx	#0
   1614  40e3		       d0 22		      bne	.enterfromNBL
   1615  40e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   1616  40e8					      endif
   1617  40e8
   1618  40e8					      if	((<*)>$d5)
   1619  4100		       00 00 00 00*	      align	256
   1620  4100					      endif
   1621  4100							; this is a kludge to prevent page wrapping - fix!!!
   1622  4100
   1623  4100				   .skipDrawlastP1
   1624  4100		       a9 00		      lda	#0
   1625  4102		       a8		      tay		; added so we don't cross a page
   1626  4103		       4c 2d f1 	      jmp	.continuelastP1
   1627  4106
   1628  4106				   .endkerloop		; enter at cycle 59??
   1629  4106
   1630  4106		       ea		      nop
   1631  4107
   1632  4107				   .enterfromNBL
   1633  4107				  -	      ifconst	pfres
   1634  4107				  -	      ldy.w	playfield+pfres*pfwidth-4
   1635  4107				  -	      sty	PF1L	;3
   1636  4107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1637  4107				  -	      sty	PF2L	;3
   1638  4107				  -	      ldy.w	playfield+pfres*pfwidth-1
   1639  4107				  -	      sty	PF1R	; possibly too early?
   1640  4107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1641  4107				  -	      sty	PF2R	;3
   1642  4107					      else
   1643  4107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1644  410a		       84 0e		      sty	PF1L	;3
   1645  410c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1646  410f		       84 0f		      sty	PF2L	;3
   1647  4111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1648  4114		       84 0e		      sty	PF1R	; possibly too early?
   1649  4116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1650  4119		       84 0f		      sty	PF2R	;3
   1651  411b					      endif
   1652  411b
   1653  411b				   enterlastkernel
   1654  411b		       a5 92		      lda	ballheight
   1655  411d
   1656  411d							; tya
   1657  411d		       c7 89		      dcp	bally
   1658  411f							; sleep 4
   1659  411f
   1660  411f							; sbc stack3
   1661  411f		       2a		      rol
   1662  4120		       2a		      rol
   1663  4121		       85 1f		      sta	ENABL
   1664  4123
   1665  4123		       a5 8f		      lda	player1height	;3
   1666  4125		       c7 86		      dcp	player1y	;5
   1667  4127		       90 d7		      bcc	.skipDrawlastP1
   1668  4129		       a4 86		      ldy	player1y	;3
   1669  412b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1670  412d							; so it doesn't cross a page boundary!
   1671  412d
   1672  412d				   .continuelastP1
   1673  412d		       85 1c		      sta	GRP1	;3
   1674  412f
   1675  412f				  -	      ifnconst	player1colors
   1676  412f				  -	      lda	missile1height	;3
   1677  412f				  -	      dcp	missile1y	;5
   1678  412f					      else
   1679  412f		       b1 87		      lda	(player1color),y
   1680  4131		       85 07		      sta	COLUP1
   1681  4133					      endif
   1682  4133
   1683  4133		       ca		      dex
   1684  4134							;dec temp4 ; might try putting this above PF writes
   1685  4134		       f0 34		      beq	endkernel
   1686  4136
   1687  4136
   1688  4136				  -	      ifconst	pfres
   1689  4136				  -	      ldy.w	playfield+pfres*pfwidth-4
   1690  4136				  -	      sty	PF1L	;3
   1691  4136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1692  4136				  -	      sty	PF2L	;3
   1693  4136				  -	      ldy.w	playfield+pfres*pfwidth-1
   1694  4136				  -	      sty	PF1R	; possibly too early?
   1695  4136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1696  4136				  -	      sty	PF2R	;3
   1697  4136					      else
   1698  4136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1699  4139		       84 0e		      sty	PF1L	;3
   1700  413b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1701  413e		       84 0f		      sty	PF2L	;3
   1702  4140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1703  4143		       84 0e		      sty	PF1R	; possibly too early?
   1704  4145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1705  4148		       84 0f		      sty	PF2R	;3
   1706  414a					      endif
   1707  414a
   1708  414a				  -	      ifnconst	player1colors
   1709  414a				  -	      rol		;2
   1710  414a				  -	      rol		;2
   1711  414a				  -	      sta	ENAM1	;3
   1712  414a					      else
   1713  414a					      ifnconst	playercolors
      0  414a					      sleep	7
      1  414a				   .CYCLES    SET	7
      2  414a
      3  414a				  -	      IF	.CYCLES < 2
      4  414a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  414a				  -	      ERR
      6  414a					      ENDIF
      7  414a
      8  414a					      IF	.CYCLES & 1
      9  414a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  414a		       04 00		      nop	0
     11  414c				  -	      ELSE
     12  414c				  -	      bit	VSYNC
     13  414c					      ENDIF
     14  414c				   .CYCLES    SET	.CYCLES - 3
     15  414c					      ENDIF
     16  414c
     17  414c					      REPEAT	.CYCLES / 2
     18  414c		       ea		      nop
     17  414c					      REPEND
     18  414d		       ea		      nop
     19  414e					      REPEND
   1715  414e				  -	      else
   1716  414e				  -	      lda.w	player0colorstore
   1717  414e				  -	      sta	COLUP0
   1718  414e					      endif
   1719  414e					      endif
   1720  414e
   1721  414e		       ad 8e 00 	      lda.w	player0height
   1722  4151		       c7 85		      dcp	player0y
   1723  4153		       90 0d		      bcc	.skipDrawlastP0
   1724  4155		       a4 85		      ldy	player0y
   1725  4157		       b1 8a		      lda	(player0pointer),y
   1726  4159				   .continuelastP0
   1727  4159		       85 1b		      sta	GRP0
   1728  415b
   1729  415b
   1730  415b
   1731  415b				  -	      ifnconst	no_blank_lines
   1732  415b				  -	      lda	missile0height	;3
   1733  415b				  -	      dcp	missile0y	;5
   1734  415b				  -	      sbc	stack1
   1735  415b				  -	      sta	ENAM0	;3
   1736  415b				  -	      jmp	.endkerloop
   1737  415b					      else
   1738  415b				  -	      ifconst	readpaddle
   1739  415b				  -	      ldy	currentpaddle
   1740  415b				  -	      lda	INPT0,y
   1741  415b				  -	      bpl	noreadpaddle2
   1742  415b				  -	      inc	paddle
   1743  415b				  -	      jmp	.endkerloop
   1744  415b				  -noreadpaddle2
   1745  415b				  -	      sleep	4
   1746  415b				  -	      jmp	.endkerloop
   1747  415b					      else		; no_blank_lines and no paddle reading
   1748  415b		       68		      pla
   1749  415c		       48		      pha		; 14 cycles in 4 bytes
   1750  415d		       68		      pla
   1751  415e		       48		      pha
   1752  415f							; sleep 14
   1753  415f		       4c 06 f1 	      jmp	.endkerloop
   1754  4162					      endif
   1755  4162					      endif
   1756  4162
   1757  4162
   1758  4162							; ifconst donepaddleskip
   1759  4162							;paddleskipread
   1760  4162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   1761  4162							; plus we get a lo-res paddle read
   1762  4162							; bmi donepaddleskip
   1763  4162							; endif
   1764  4162
   1765  4162				   .skipDrawlastP0
   1766  4162		       a9 00		      lda	#0
   1767  4164		       a8		      tay
   1768  4165		       4c 59 f1 	      jmp	.continuelastP0
   1769  4168
   1770  4168					      ifconst	no_blank_lines
   1771  4168				   no_blank_lines_bailout
   1772  4168		       a2 00		      ldx	#0
   1773  416a					      endif
   1774  416a
   1775  416a				   endkernel
   1776  416a							; 6 digit score routine
   1777  416a		       86 0e		      stx	PF1
   1778  416c		       86 0f		      stx	PF2
   1779  416e		       86 0d		      stx	PF0
   1780  4170		       18		      clc
   1781  4171
   1782  4171				  -	      ifconst	pfrowheight
   1783  4171				  -	      lda	#pfrowheight+2
   1784  4171					      else
   1785  4171					      ifnconst	pfres
   1786  4171		       a9 0a		      lda	#10
   1787  4173				  -	      else
   1788  4173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1789  4173					      endif
   1790  4173					      endif
   1791  4173
   1792  4173		       e5 ef		      sbc	playfieldpos
   1793  4175		       85 ef		      sta	playfieldpos
   1794  4177		       8a		      txa
   1795  4178
   1796  4178				  -	      ifconst	shakescreen
   1797  4178				  -	      bit	shakescreen
   1798  4178				  -	      bmi	noshakescreen2
   1799  4178				  -	      ldx	#$3D
   1800  4178				  -noshakescreen2
   1801  4178					      endif
   1802  4178
   1803  4178		       95 02		      sta	WSYNC,x
   1804  417a
   1805  417a							; STA WSYNC ;first one, need one more
   1806  417a		       85 0b		      sta	REFP0
   1807  417c		       85 0c		      sta	REFP1
   1808  417e		       85 1b		      STA	GRP0
   1809  4180		       85 1c		      STA	GRP1
   1810  4182							; STA PF1
   1811  4182							; STA PF2
   1812  4182		       85 2b		      sta	HMCLR
   1813  4184		       85 1d		      sta	ENAM0
   1814  4186		       85 1e		      sta	ENAM1
   1815  4188		       85 1f		      sta	ENABL
   1816  418a
   1817  418a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   1818  418c		       85 85		      sta	player0y
   1819  418e		       a5 9e		      lda	temp3
   1820  4190		       85 86		      sta	player1y
   1821  4192				  -	      ifnconst	player1colors
   1822  4192				  -	      lda	temp6
   1823  4192				  -	      sta	missile1y
   1824  4192					      endif
   1825  4192					      ifnconst	playercolors
   1826  4192					      ifnconst	readpaddle
   1827  4192		       a5 a0		      lda	temp5
   1828  4194		       85 91		      sta	missile0y
   1829  4196					      endif
   1830  4196					      endif
   1831  4196		       a5 f7		      lda	stack2
   1832  4198		       85 89		      sta	bally
   1833  419a
   1834  419a							; strangely, this isn't required any more. might have
   1835  419a							; resulted from the no_blank_lines score bounce fix
   1836  419a							;ifconst no_blank_lines
   1837  419a							;sta WSYNC
   1838  419a							;endif
   1839  419a
   1840  419a		       ad 84 02 	      lda	INTIM
   1841  419d		       18		      clc
   1842  419e				  -	      ifnconst	vblank_time
   1843  419e				  -	      adc	#43+12+87
   1844  419e					      else
   1845  419e		       69 8e		      adc	#vblank_time+12+87
   1846  41a0
   1847  41a0					      endif
   1848  41a0							; sta WSYNC
   1849  41a0		       8d 96 02 	      sta	TIM64T
   1850  41a3
   1851  41a3				  -	      ifconst	minikernel
   1852  41a3				  -	      jsr	minikernel
   1853  41a3					      endif
   1854  41a3
   1855  41a3							; now reassign temp vars for score pointers
   1856  41a3
   1857  41a3							; score pointers contain:
   1858  41a3							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1859  41a3							; swap lo2->temp1
   1860  41a3							; swap lo4->temp3
   1861  41a3							; swap lo6->temp5
   1862  41a3					      ifnconst	noscore
   1863  41a3		       a5 97		      lda	scorepointers+1
   1864  41a5							; ldy temp1
   1865  41a5		       85 9c		      sta	temp1
   1866  41a7							; sty scorepointers+1
   1867  41a7
   1868  41a7		       a5 99		      lda	scorepointers+3
   1869  41a9							; ldy temp3
   1870  41a9		       85 9e		      sta	temp3
   1871  41ab							; sty scorepointers+3
   1872  41ab
   1873  41ab
   1874  41ab		       85 2b		      sta	HMCLR
   1875  41ad		       ba		      tsx
   1876  41ae		       86 f6		      stx	stack1
   1877  41b0		       a2 e0		      ldx	#$E0
   1878  41b2		       86 20		      stx	HMP0
   1879  41b4
   1880  41b4		       a5 a3		      LDA	scorecolor
   1881  41b6		       85 06		      STA	COLUP0
   1882  41b8		       85 07		      STA	COLUP1
   1883  41ba				  -	      ifconst	scorefade
   1884  41ba				  -	      STA	stack2
   1885  41ba					      endif
   1886  41ba					      ifconst	pfscore
   1887  41ba		       a5 f4		      lda	pfscorecolor
   1888  41bc		       85 08		      sta	COLUPF
   1889  41be					      endif
   1890  41be		       85 02		      sta	WSYNC
   1891  41c0		       a2 00		      ldx	#0
   1892  41c2		       86 1b		      STx	GRP0
   1893  41c4		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1894  41c6
   1895  41c6		       a5 9b		      lda	scorepointers+5
   1896  41c8							; ldy temp5
   1897  41c8		       95 a0		      sta	temp5,x
   1898  41ca							; sty scorepointers+5
   1899  41ca		       a9 ff		      lda	#>scoretable
   1900  41cc		       85 97		      sta	scorepointers+1
   1901  41ce		       85 99		      sta	scorepointers+3
   1902  41d0		       85 9b		      sta	scorepointers+5
   1903  41d2		       85 9d		      sta	temp2
   1904  41d4		       85 9f		      sta	temp4
   1905  41d6		       85 a1		      sta	temp6
   1906  41d8		       a0 07		      LDY	#7
   1907  41da		       84 25		      STY	VDELP0
   1908  41dc		       85 10		      STA	RESP0
   1909  41de		       85 11		      STA	RESP1
   1910  41e0
   1911  41e0
   1912  41e0		       a9 03		      LDA	#$03
   1913  41e2		       85 04		      STA	NUSIZ0
   1914  41e4		       85 05		      STA	NUSIZ1
   1915  41e6		       85 26		      STA	VDELP1
   1916  41e8		       a9 f0		      LDA	#$F0
   1917  41ea		       85 21		      STA	HMP1
   1918  41ec		       b1 96		      lda	(scorepointers),y
   1919  41ee		       85 1b		      sta	GRP0
   1920  41f0		       85 2a		      STA	HMOVE	; cycle 73 ?
   1921  41f2		       4c 09 f2 	      jmp	beginscore
   1922  41f5
   1923  41f5
   1924  41f5					      if	((<*)>$d4)
   1925  4200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   1926  4200					      endif
   1927  4200
   1928  4200				   loop2
   1929  4200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   1930  4202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   1931  4204					      ifconst	pfscore
   1932  4204		       ad f2 00 	      lda.w	pfscore1
   1933  4207		       85 0e		      sta	PF1
   1934  4209				  -	      else
   1935  4209				  -	      ifconst	scorefade
   1936  4209				  -	      sleep	2
   1937  4209				  -	      dec	stack2	; decrement the temporary scorecolor
   1938  4209				  -	      else
   1939  4209				  -	      sleep	7
   1940  4209				  -	      endif
   1941  4209					      endif
   1942  4209							; cycle 0
   1943  4209				   beginscore
   1944  4209		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   1945  420b		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   1946  420d		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   1947  420f		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   1948  4211		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   1949  4213		       9a		      txs
   1950  4214		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   1951  4216				  -	      ifconst	scorefade
   1952  4216				  -	      lda	stack2
   1953  4216					      else
      0  4216					      sleep	3
      1  4216				   .CYCLES    SET	3
      2  4216
      3  4216				  -	      IF	.CYCLES < 2
      4  4216				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4216				  -	      ERR
      6  4216					      ENDIF
      7  4216
      8  4216					      IF	.CYCLES & 1
      9  4216					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4216		       04 00		      nop	0
     11  4218				  -	      ELSE
     12  4218				  -	      bit	VSYNC
     13  4218					      ENDIF
     14  4218				   .CYCLES    SET	.CYCLES - 3
     15  4218					      ENDIF
     16  4218
     17  4218				  -	      REPEAT	.CYCLES / 2
     18  4218				  -	      nop
     19  4218					      REPEND
   1955  4218					      endif
   1956  4218
   1957  4218					      ifconst	pfscore
   1958  4218		       a5 f3		      lda	pfscore2
   1959  421a		       85 0e		      sta	PF1
   1960  421c				  -	      else
   1961  421c				  -	      ifconst	scorefade
   1962  421c				  -	      sta	COLUP0
   1963  421c				  -	      sta	COLUP1
   1964  421c				  -	      else
   1965  421c				  -	      sleep	6
   1966  421c				  -	      endif
   1967  421c					      endif
   1968  421c
   1969  421c		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   1970  421e		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   1971  4220		       ba		      tsx
   1972  4221		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   1973  4223		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   1974  4225		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   1975  4227		       88		      dey
   1976  4228		       10 d6		      bpl	loop2	;+2 60 180
   1977  422a
   1978  422a		       a6 f6		      ldx	stack1
   1979  422c		       9a		      txs
   1980  422d							; lda scorepointers+1
   1981  422d		       a4 9c		      ldy	temp1
   1982  422f							; sta temp1
   1983  422f		       84 97		      sty	scorepointers+1
   1984  4231
   1985  4231		       a9 00		      LDA	#0
   1986  4233		       85 0e		      sta	PF1
   1987  4235		       85 1b		      STA	GRP0
   1988  4237		       85 1c		      STA	GRP1
   1989  4239		       85 25		      STA	VDELP0
   1990  423b		       85 26		      STA	VDELP1	;do we need these
   1991  423d		       85 04		      STA	NUSIZ0
   1992  423f		       85 05		      STA	NUSIZ1
   1993  4241
   1994  4241							; lda scorepointers+3
   1995  4241		       a4 9e		      ldy	temp3
   1996  4243							; sta temp3
   1997  4243		       84 99		      sty	scorepointers+3
   1998  4245
   1999  4245							; lda scorepointers+5
   2000  4245		       a4 a0		      ldy	temp5
   2001  4247							; sta temp5
   2002  4247		       84 9b		      sty	scorepointers+5
   2003  4249					      endif		;noscore
   2004  4249		       a9 c2		      LDA	#%11000010
   2005  424b		       85 02		      sta	WSYNC
   2006  424d		       85 01		      STA	VBLANK
      0  424f					      RETURN
      1  424f				  -	      ifnconst	bankswitch
      2  424f				  -	      rts
      3  424f					      else
      4  424f		       4c dd ff 	      jmp	BS_return
      5  4252					      endif
   2008  4252
   2009  4252				  -	      ifconst	shakescreen
   2010  4252				  -doshakescreen
   2011  4252				  -	      bit	shakescreen
   2012  4252				  -	      bmi	noshakescreen
   2013  4252				  -	      sta	WSYNC
   2014  4252				  -noshakescreen
   2015  4252				  -	      ldx	missile0height
   2016  4252				  -	      inx
   2017  4252				  -	      rts
   2018  4252					      endif
   2019  4252
   2020  4252							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2021  4252
   2022  4252				   start
   2023  4252		       78		      sei
   2024  4253		       d8		      cld
   2025  4254		       a0 00		      ldy	#0
   2026  4256		       a5 d0		      lda	$D0
   2027  4258		       c9 2c		      cmp	#$2C	;check RAM location #1
   2028  425a		       d0 07		      bne	MachineIs2600
   2029  425c		       a5 d1		      lda	$D1
   2030  425e		       c9 a9		      cmp	#$A9	;check RAM location #2
   2031  4260		       d0 01		      bne	MachineIs2600
   2032  4262		       88		      dey
   2033  4263				   MachineIs2600
   2034  4263		       a2 00		      ldx	#0
   2035  4265		       8a		      txa
   2036  4266				   clearmem
   2037  4266		       e8		      inx
   2038  4267		       9a		      txs
   2039  4268		       48		      pha
   2040  4269		       d0 fb		      bne	clearmem
   2041  426b		       84 9c		      sty	temp1
   2042  426d					      ifnconst	multisprite
   2043  426d				  -	      ifconst	pfrowheight
   2044  426d				  -	      lda	#pfrowheight
   2045  426d					      else
   2046  426d				  -	      ifconst	pfres
   2047  426d				  -	      lda	#(96/pfres)
   2048  426d					      else
   2049  426d		       a9 08		      lda	#8
   2050  426f					      endif
   2051  426f					      endif
   2052  426f		       85 ef		      sta	playfieldpos
   2053  4271					      endif
   2054  4271		       a2 05		      ldx	#5
   2055  4273				   initscore
   2056  4273		       a9 74		      lda	#<scoretable
   2057  4275		       95 96		      sta	scorepointers,x
   2058  4277		       ca		      dex
   2059  4278		       10 f9		      bpl	initscore
   2060  427a		       a9 01		      lda	#1
   2061  427c		       85 0a		      sta	CTRLPF
   2062  427e		       0d 84 02 	      ora	INTIM
   2063  4281		       85 a2		      sta	rand
   2064  4283
   2065  4283				  -	      ifconst	multisprite
   2066  4283				  -	      jsr	multisprite_setup
   2067  4283					      endif
   2068  4283
   2069  4283				  -	      ifnconst	bankswitch
   2070  4283				  -	      jmp	game
   2071  4283					      else
   2072  4283		       a9 8f		      lda	#>(game-1)
   2073  4285		       48		      pha
   2074  4286		       a9 ff		      lda	#<(game-1)
   2075  4288		       48		      pha
   2076  4289		       48		      pha
   2077  428a		       48		      pha
   2078  428b		       a2 01		      ldx	#1
   2079  428d		       4c eb ff 	      jmp	BS_jsr
   2080  4290					      endif
   2081  4290							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2082  4290
   2083  4290							; playfield drawing routines
   2084  4290							; you get a 32x12 bitmapped display in a single color :)
   2085  4290							; 0-31 and 0-11
   2086  4290
   2087  4290				   pfclear		; clears playfield - or fill with pattern
   2088  4290				  -	      ifconst	pfres
   2089  4290				  -	      ldx	#pfres*pfwidth-1
   2090  4290					      else
   2091  4290		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   2092  4292					      endif
   2093  4292				   pfclear_loop
   2094  4292					      ifnconst	superchip
   2095  4292		       95 a4		      sta	playfield,x
   2096  4294				  -	      else
   2097  4294				  -	      sta	playfield-128,x
   2098  4294					      endif
   2099  4294		       ca		      dex
   2100  4295		       10 fb		      bpl	pfclear_loop
      0  4297					      RETURN
      1  4297				  -	      ifnconst	bankswitch
      2  4297				  -	      rts
      3  4297					      else
      4  4297		       4c dd ff 	      jmp	BS_return
      5  429a					      endif
   2102  429a
   2103  429a				   setuppointers
   2104  429a		       86 9d		      stx	temp2	; store on.off.flip value
   2105  429c		       aa		      tax		; put x-value in x 
   2106  429d		       4a		      lsr
   2107  429e		       4a		      lsr
   2108  429f		       4a		      lsr		; divide x pos by 8 
   2109  42a0		       85 9c		      sta	temp1
   2110  42a2		       98		      tya
   2111  42a3		       0a		      asl
   2112  42a4					      if	pfwidth=4
   2113  42a4		       0a		      asl		; multiply y pos by 4
   2114  42a5					      endif		; else multiply by 2
   2115  42a5		       18		      clc
   2116  42a6		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   2117  42a8		       a8		      tay		; put the value in y
   2118  42a9		       a5 9d		      lda	temp2	; restore on.off.flip value
   2119  42ab		       60		      rts
   2120  42ac
   2121  42ac				   pfread
   2122  42ac							;x=xvalue, y=yvalue
   2123  42ac		       20 9a f2 	      jsr	setuppointers
   2124  42af		       bd 44 f3 	      lda	setbyte,x
   2125  42b2		       39 a4 00 	      and	playfield,y
   2126  42b5		       5d 44 f3 	      eor	setbyte,x
   2127  42b8							; beq readzero
   2128  42b8							; lda #1
   2129  42b8							; readzero
      0  42b8					      RETURN
      1  42b8				  -	      ifnconst	bankswitch
      2  42b8				  -	      rts
      3  42b8					      else
      4  42b8		       4c dd ff 	      jmp	BS_return
      5  42bb					      endif
   2131  42bb
   2132  42bb				   pfpixel
   2133  42bb							;x=xvalue, y=yvalue, a=0,1,2
   2134  42bb		       20 9a f2 	      jsr	setuppointers
   2135  42be
   2136  42be					      ifconst	bankswitch
   2137  42be		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2138  42c0		       f0 0f		      beq	pixelon_r	; if "on" go to on
   2139  42c2		       4a		      lsr
   2140  42c3		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   2141  42c5		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2142  42c8		       5d 44 f3 	      eor	setbyte,x
   2143  42cb				  -	      ifconst	superchip
   2144  42cb				  -	      sta	playfield-128,y
   2145  42cb					      else
   2146  42cb		       99 a4 00 	      sta	playfield,y
   2147  42ce					      endif
      0  42ce					      RETURN
      1  42ce				  -	      ifnconst	bankswitch
      2  42ce				  -	      rts
      3  42ce					      else
      4  42ce		       4c dd ff 	      jmp	BS_return
      5  42d1					      endif
   2149  42d1				   pixelon_r
   2150  42d1		       b9 a4 00 	      lda	playfield,y
   2151  42d4		       1d 44 f3 	      ora	setbyte,x
   2152  42d7				  -	      ifconst	superchip
   2153  42d7				  -	      sta	playfield-128,y
   2154  42d7					      else
   2155  42d7		       99 a4 00 	      sta	playfield,y
   2156  42da					      endif
      0  42da					      RETURN
      1  42da				  -	      ifnconst	bankswitch
      2  42da				  -	      rts
      3  42da					      else
      4  42da		       4c dd ff 	      jmp	BS_return
      5  42dd					      endif
   2158  42dd				   pixeloff_r
   2159  42dd		       bd 44 f3 	      lda	setbyte,x
   2160  42e0		       49 ff		      eor	#$ff
   2161  42e2		       39 a4 00 	      and	playfield,y
   2162  42e5				  -	      ifconst	superchip
   2163  42e5				  -	      sta	playfield-128,y
   2164  42e5					      else
   2165  42e5		       99 a4 00 	      sta	playfield,y
   2166  42e8					      endif
      0  42e8					      RETURN
      1  42e8				  -	      ifnconst	bankswitch
      2  42e8				  -	      rts
      3  42e8					      else
      4  42e8		       4c dd ff 	      jmp	BS_return
      5  42eb					      endif
   2168  42eb
   2169  42eb				  -	      else
   2170  42eb				  -	      jmp	plotpoint
   2171  42eb					      endif
   2172  42eb
   2173  42eb				   pfhline
   2174  42eb							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2175  42eb		       20 9a f2 	      jsr	setuppointers
   2176  42ee		       4c f8 f2 	      jmp	noinc
   2177  42f1				   keepgoing
   2178  42f1		       e8		      inx
   2179  42f2		       8a		      txa
   2180  42f3		       29 07		      and	#7
   2181  42f5		       d0 01		      bne	noinc
   2182  42f7		       c8		      iny
   2183  42f8				   noinc
   2184  42f8		       20 1d f3 	      jsr	plotpoint
   2185  42fb		       e4 9e		      cpx	temp3
   2186  42fd		       30 f2		      bmi	keepgoing
      0  42ff					      RETURN
      1  42ff				  -	      ifnconst	bankswitch
      2  42ff				  -	      rts
      3  42ff					      else
      4  42ff		       4c dd ff 	      jmp	BS_return
      5  4302					      endif
   2188  4302
   2189  4302				   pfvline
   2190  4302							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2191  4302		       20 9a f2 	      jsr	setuppointers
   2192  4305		       84 9c		      sty	temp1	; store memory location offset
   2193  4307		       e6 9e		      inc	temp3	; increase final x by 1 
   2194  4309		       a5 9e		      lda	temp3
   2195  430b		       0a		      asl
   2196  430c					      if	pfwidth=4
   2197  430c		       0a		      asl		; multiply by 4
   2198  430d					      endif		; else multiply by 2
   2199  430d		       85 9e		      sta	temp3	; store it
   2200  430f							; Thanks to Michael Rideout for fixing a bug in this code
   2201  430f							; right now, temp1=y=starting memory location, temp3=final
   2202  430f							; x should equal original x value
   2203  430f				   keepgoingy
   2204  430f		       20 1d f3 	      jsr	plotpoint
   2205  4312		       c8		      iny
   2206  4313		       c8		      iny
   2207  4314					      if	pfwidth=4
   2208  4314		       c8		      iny
   2209  4315		       c8		      iny
   2210  4316					      endif
   2211  4316		       c4 9e		      cpy	temp3
   2212  4318		       30 f5		      bmi	keepgoingy
      0  431a					      RETURN
      1  431a				  -	      ifnconst	bankswitch
      2  431a				  -	      rts
      3  431a					      else
      4  431a		       4c dd ff 	      jmp	BS_return
      5  431d					      endif
   2214  431d
   2215  431d				   plotpoint
   2216  431d		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2217  431f		       f0 0d		      beq	pixelon	; if "on" go to on
   2218  4321		       4a		      lsr
   2219  4322		       b0 14		      bcs	pixeloff	; value is 1 if true
   2220  4324		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2221  4327		       5d 44 f3 	      eor	setbyte,x
   2222  432a				  -	      ifconst	superchip
   2223  432a				  -	      sta	playfield-128,y
   2224  432a					      else
   2225  432a		       99 a4 00 	      sta	playfield,y
   2226  432d					      endif
   2227  432d		       60		      rts
   2228  432e				   pixelon
   2229  432e		       b9 a4 00 	      lda	playfield,y
   2230  4331		       1d 44 f3 	      ora	setbyte,x
   2231  4334				  -	      ifconst	superchip
   2232  4334				  -	      sta	playfield-128,y
   2233  4334					      else
   2234  4334		       99 a4 00 	      sta	playfield,y
   2235  4337					      endif
   2236  4337		       60		      rts
   2237  4338				   pixeloff
   2238  4338		       bd 44 f3 	      lda	setbyte,x
   2239  433b		       49 ff		      eor	#$ff
   2240  433d		       39 a4 00 	      and	playfield,y
   2241  4340				  -	      ifconst	superchip
   2242  4340				  -	      sta	playfield-128,y
   2243  4340					      else
   2244  4340		       99 a4 00 	      sta	playfield,y
   2245  4343					      endif
   2246  4343		       60		      rts
   2247  4344
   2248  4344				   setbyte
   2249  4344					      ifnconst	pfcenter
   2250  4344		       80		      .byte.b	$80
   2251  4345		       40		      .byte.b	$40
   2252  4346		       20		      .byte.b	$20
   2253  4347		       10		      .byte.b	$10
   2254  4348		       08		      .byte.b	$08
   2255  4349		       04		      .byte.b	$04
   2256  434a		       02		      .byte.b	$02
   2257  434b		       01		      .byte.b	$01
   2258  434c					      endif
   2259  434c		       01		      .byte.b	$01
   2260  434d		       02		      .byte.b	$02
   2261  434e		       04		      .byte.b	$04
   2262  434f		       08		      .byte.b	$08
   2263  4350		       10		      .byte.b	$10
   2264  4351		       20		      .byte.b	$20
   2265  4352		       40		      .byte.b	$40
   2266  4353		       80		      .byte.b	$80
   2267  4354		       80		      .byte.b	$80
   2268  4355		       40		      .byte.b	$40
   2269  4356		       20		      .byte.b	$20
   2270  4357		       10		      .byte.b	$10
   2271  4358		       08		      .byte.b	$08
   2272  4359		       04		      .byte.b	$04
   2273  435a		       02		      .byte.b	$02
   2274  435b		       01		      .byte.b	$01
   2275  435c		       01		      .byte.b	$01
   2276  435d		       02		      .byte.b	$02
   2277  435e		       04		      .byte.b	$04
   2278  435f		       08		      .byte.b	$08
   2279  4360		       10		      .byte.b	$10
   2280  4361		       20		      .byte.b	$20
   2281  4362		       40		      .byte.b	$40
   2282  4363		       80		      .byte.b	$80
   2283  4364							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2284  4364
   2285  4364				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   2286  4364		       d0 15		      bne	notleft
   2287  4366							;left
   2288  4366				  -	      ifconst	pfres
   2289  4366				  -	      ldx	#pfres*4
   2290  4366					      else
   2291  4366		       a2 30		      ldx	#48
   2292  4368					      endif
   2293  4368				   leftloop
   2294  4368		       b5 a3		      lda	playfield-1,x
   2295  436a		       4a		      lsr
   2296  436b
   2297  436b				  -	      ifconst	superchip
   2298  436b				  -	      lda	playfield-2,x
   2299  436b				  -	      rol
   2300  436b				  -	      sta	playfield-130,x
   2301  436b				  -	      lda	playfield-3,x
   2302  436b				  -	      ror
   2303  436b				  -	      sta	playfield-131,x
   2304  436b				  -	      lda	playfield-4,x
   2305  436b				  -	      rol
   2306  436b				  -	      sta	playfield-132,x
   2307  436b				  -	      lda	playfield-1,x
   2308  436b				  -	      ror
   2309  436b				  -	      sta	playfield-129,x
   2310  436b					      else
   2311  436b		       36 a2		      rol	playfield-2,x
   2312  436d		       76 a1		      ror	playfield-3,x
   2313  436f		       36 a0		      rol	playfield-4,x
   2314  4371		       76 a3		      ror	playfield-1,x
   2315  4373					      endif
   2316  4373
   2317  4373		       8a		      txa
   2318  4374		       cb 04		      sbx	#4
   2319  4376		       d0 f0		      bne	leftloop
      0  4378					      RETURN
      1  4378				  -	      ifnconst	bankswitch
      2  4378				  -	      rts
      3  4378					      else
      4  4378		       4c dd ff 	      jmp	BS_return
      5  437b					      endif
   2321  437b
   2322  437b				   notleft
   2323  437b		       4a		      lsr
   2324  437c		       90 15		      bcc	notright
   2325  437e							;right
   2326  437e
   2327  437e				  -	      ifconst	pfres
   2328  437e				  -	      ldx	#pfres*4
   2329  437e					      else
   2330  437e		       a2 30		      ldx	#48
   2331  4380					      endif
   2332  4380				   rightloop
   2333  4380		       b5 a0		      lda	playfield-4,x
   2334  4382		       4a		      lsr
   2335  4383				  -	      ifconst	superchip
   2336  4383				  -	      lda	playfield-3,x
   2337  4383				  -	      rol
   2338  4383				  -	      sta	playfield-131,x
   2339  4383				  -	      lda	playfield-2,x
   2340  4383				  -	      ror
   2341  4383				  -	      sta	playfield-130,x
   2342  4383				  -	      lda	playfield-1,x
   2343  4383				  -	      rol
   2344  4383				  -	      sta	playfield-129,x
   2345  4383				  -	      lda	playfield-4,x
   2346  4383				  -	      ror
   2347  4383				  -	      sta	playfield-132,x
   2348  4383					      else
   2349  4383		       36 a1		      rol	playfield-3,x
   2350  4385		       76 a2		      ror	playfield-2,x
   2351  4387		       36 a3		      rol	playfield-1,x
   2352  4389		       76 a0		      ror	playfield-4,x
   2353  438b					      endif
   2354  438b		       8a		      txa
   2355  438c		       cb 04		      sbx	#4
   2356  438e		       d0 f0		      bne	rightloop
      0  4390					      RETURN
      1  4390				  -	      ifnconst	bankswitch
      2  4390				  -	      rts
      3  4390					      else
      4  4390		       4c dd ff 	      jmp	BS_return
      5  4393					      endif
   2358  4393
   2359  4393				   notright
   2360  4393		       4a		      lsr
   2361  4394		       90 4b		      bcc	notup
   2362  4396							;up
   2363  4396		       4a		      lsr
   2364  4397		       90 02		      bcc	onedecup
   2365  4399		       c6 ef		      dec	playfieldpos
   2366  439b				   onedecup
   2367  439b		       c6 ef		      dec	playfieldpos
   2368  439d		       f0 02		      beq	shiftdown
   2369  439f		       10 3d		      bpl	noshiftdown2
   2370  43a1				   shiftdown
   2371  43a1				  -	      ifconst	pfrowheight
   2372  43a1				  -	      lda	#pfrowheight
   2373  43a1					      else
   2374  43a1					      ifnconst	pfres
   2375  43a1		       a9 08		      lda	#8
   2376  43a3				  -	      else
   2377  43a3				  -	      lda	#(96/pfres)	; try to come close to the real size
   2378  43a3					      endif
   2379  43a3					      endif
   2380  43a3
   2381  43a3		       85 ef		      sta	playfieldpos
   2382  43a5		       a5 a7		      lda	playfield+3
   2383  43a7		       85 9f		      sta	temp4
   2384  43a9		       a5 a6		      lda	playfield+2
   2385  43ab		       85 9e		      sta	temp3
   2386  43ad		       a5 a5		      lda	playfield+1
   2387  43af		       85 9d		      sta	temp2
   2388  43b1		       a5 a4		      lda	playfield
   2389  43b3		       85 9c		      sta	temp1
   2390  43b5		       a2 00		      ldx	#0
   2391  43b7				   up2
   2392  43b7		       b5 a8		      lda	playfield+4,x
   2393  43b9				  -	      ifconst	superchip
   2394  43b9				  -	      sta	playfield-128,x
   2395  43b9				  -	      lda	playfield+5,x
   2396  43b9				  -	      sta	playfield-127,x
   2397  43b9				  -	      lda	playfield+6,x
   2398  43b9				  -	      sta	playfield-126,x
   2399  43b9				  -	      lda	playfield+7,x
   2400  43b9				  -	      sta	playfield-125,x
   2401  43b9					      else
   2402  43b9		       95 a4		      sta	playfield,x
   2403  43bb		       b5 a9		      lda	playfield+5,x
   2404  43bd		       95 a5		      sta	playfield+1,x
   2405  43bf		       b5 aa		      lda	playfield+6,x
   2406  43c1		       95 a6		      sta	playfield+2,x
   2407  43c3		       b5 ab		      lda	playfield+7,x
   2408  43c5		       95 a7		      sta	playfield+3,x
   2409  43c7					      endif
   2410  43c7		       8a		      txa
   2411  43c8		       cb fc		      sbx	#252
   2412  43ca				  -	      ifconst	pfres
   2413  43ca				  -	      cpx	#(pfres-1)*4
   2414  43ca					      else
   2415  43ca		       e0 2c		      cpx	#44
   2416  43cc					      endif
   2417  43cc		       d0 e9		      bne	up2
   2418  43ce
   2419  43ce		       a5 9f		      lda	temp4
   2420  43d0
   2421  43d0				  -	      ifconst	superchip
   2422  43d0				  -	      ifconst	pfres
   2423  43d0				  -	      sta	playfield+pfres*4-129
   2424  43d0				  -	      lda	temp3
   2425  43d0				  -	      sta	playfield+pfres*4-130
   2426  43d0				  -	      lda	temp2
   2427  43d0				  -	      sta	playfield+pfres*4-131
   2428  43d0				  -	      lda	temp1
   2429  43d0				  -	      sta	playfield+pfres*4-132
   2430  43d0				  -	      else
   2431  43d0				  -	      sta	playfield+47-128
   2432  43d0				  -	      lda	temp3
   2433  43d0				  -	      sta	playfield+46-128
   2434  43d0				  -	      lda	temp2
   2435  43d0				  -	      sta	playfield+45-128
   2436  43d0				  -	      lda	temp1
   2437  43d0				  -	      sta	playfield+44-128
   2438  43d0				  -	      endif
   2439  43d0					      else
   2440  43d0				  -	      ifconst	pfres
   2441  43d0				  -	      sta	playfield+pfres*4-1
   2442  43d0				  -	      lda	temp3
   2443  43d0				  -	      sta	playfield+pfres*4-2
   2444  43d0				  -	      lda	temp2
   2445  43d0				  -	      sta	playfield+pfres*4-3
   2446  43d0				  -	      lda	temp1
   2447  43d0				  -	      sta	playfield+pfres*4-4
   2448  43d0					      else
   2449  43d0		       85 d3		      sta	playfield+47
   2450  43d2		       a5 9e		      lda	temp3
   2451  43d4		       85 d2		      sta	playfield+46
   2452  43d6		       a5 9d		      lda	temp2
   2453  43d8		       85 d1		      sta	playfield+45
   2454  43da		       a5 9c		      lda	temp1
   2455  43dc		       85 d0		      sta	playfield+44
   2456  43de					      endif
   2457  43de					      endif
   2458  43de				   noshiftdown2
      0  43de					      RETURN
      1  43de				  -	      ifnconst	bankswitch
      2  43de				  -	      rts
      3  43de					      else
      4  43de		       4c dd ff 	      jmp	BS_return
      5  43e1					      endif
   2460  43e1
   2461  43e1
   2462  43e1				   notup
   2463  43e1							;down
   2464  43e1		       4a		      lsr
   2465  43e2		       b0 02		      bcs	oneincup
   2466  43e4		       e6 ef		      inc	playfieldpos
   2467  43e6				   oneincup
   2468  43e6		       e6 ef		      inc	playfieldpos
   2469  43e8		       a5 ef		      lda	playfieldpos
   2470  43ea
   2471  43ea				  -	      ifconst	pfrowheight
   2472  43ea				  -	      cmp	#pfrowheight+1
   2473  43ea					      else
   2474  43ea					      ifnconst	pfres
   2475  43ea		       c9 09		      cmp	#9
   2476  43ec				  -	      else
   2477  43ec				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   2478  43ec					      endif
   2479  43ec					      endif
   2480  43ec
   2481  43ec		       90 3b		      bcc	noshiftdown
   2482  43ee		       a9 01		      lda	#1
   2483  43f0		       85 ef		      sta	playfieldpos
   2484  43f2
   2485  43f2				  -	      ifconst	pfres
   2486  43f2				  -	      lda	playfield+pfres*4-1
   2487  43f2				  -	      sta	temp4
   2488  43f2				  -	      lda	playfield+pfres*4-2
   2489  43f2				  -	      sta	temp3
   2490  43f2				  -	      lda	playfield+pfres*4-3
   2491  43f2				  -	      sta	temp2
   2492  43f2				  -	      lda	playfield+pfres*4-4
   2493  43f2					      else
   2494  43f2		       a5 d3		      lda	playfield+47
   2495  43f4		       85 9f		      sta	temp4
   2496  43f6		       a5 d2		      lda	playfield+46
   2497  43f8		       85 9e		      sta	temp3
   2498  43fa		       a5 d1		      lda	playfield+45
   2499  43fc		       85 9d		      sta	temp2
   2500  43fe		       a5 d0		      lda	playfield+44
   2501  4400					      endif
   2502  4400
   2503  4400		       85 9c		      sta	temp1
   2504  4402
   2505  4402				  -	      ifconst	pfres
   2506  4402				  -	      ldx	#(pfres-1)*4
   2507  4402					      else
   2508  4402		       a2 2c		      ldx	#44
   2509  4404					      endif
   2510  4404				   down2
   2511  4404		       b5 a3		      lda	playfield-1,x
   2512  4406				  -	      ifconst	superchip
   2513  4406				  -	      sta	playfield-125,x
   2514  4406				  -	      lda	playfield-2,x
   2515  4406				  -	      sta	playfield-126,x
   2516  4406				  -	      lda	playfield-3,x
   2517  4406				  -	      sta	playfield-127,x
   2518  4406				  -	      lda	playfield-4,x
   2519  4406				  -	      sta	playfield-128,x
   2520  4406					      else
   2521  4406		       95 a7		      sta	playfield+3,x
   2522  4408		       b5 a2		      lda	playfield-2,x
   2523  440a		       95 a6		      sta	playfield+2,x
   2524  440c		       b5 a1		      lda	playfield-3,x
   2525  440e		       95 a5		      sta	playfield+1,x
   2526  4410		       b5 a0		      lda	playfield-4,x
   2527  4412		       95 a4		      sta	playfield,x
   2528  4414					      endif
   2529  4414		       8a		      txa
   2530  4415		       cb 04		      sbx	#4
   2531  4417		       d0 eb		      bne	down2
   2532  4419
   2533  4419		       a5 9f		      lda	temp4
   2534  441b				  -	      ifconst	superchip
   2535  441b				  -	      sta	playfield-125
   2536  441b				  -	      lda	temp3
   2537  441b				  -	      sta	playfield-126
   2538  441b				  -	      lda	temp2
   2539  441b				  -	      sta	playfield-127
   2540  441b				  -	      lda	temp1
   2541  441b				  -	      sta	playfield-128
   2542  441b					      else
   2543  441b		       85 a7		      sta	playfield+3
   2544  441d		       a5 9e		      lda	temp3
   2545  441f		       85 a6		      sta	playfield+2
   2546  4421		       a5 9d		      lda	temp2
   2547  4423		       85 a5		      sta	playfield+1
   2548  4425		       a5 9c		      lda	temp1
   2549  4427		       85 a4		      sta	playfield
   2550  4429					      endif
   2551  4429				   noshiftdown
      0  4429					      RETURN
      1  4429				  -	      ifnconst	bankswitch
      2  4429				  -	      rts
      3  4429					      else
      4  4429		       4c dd ff 	      jmp	BS_return
      5  442c					      endif
   2553  442c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2554  442c
   2555  442c							;standard routines needed for pretty much all games
   2556  442c							; just the random number generator is left - maybe we should remove this asm file altogether?
   2557  442c							; repositioning code and score pointer setup moved to overscan
   2558  442c							; read switches, joysticks now compiler generated (more efficient)
   2559  442c
   2560  442c				   randomize
   2561  442c		       a5 a2		      lda	rand
   2562  442e		       4a		      lsr
   2563  442f					      ifconst	rand16
   2564  442f		       26 e1		      rol	rand16
   2565  4431					      endif
   2566  4431		       90 02		      bcc	noeor
   2567  4433		       49 b4		      eor	#$B4
   2568  4435				   noeor
   2569  4435		       85 a2		      sta	rand
   2570  4437					      ifconst	rand16
   2571  4437		       45 e1		      eor	rand16
   2572  4439					      endif
      0  4439					      RETURN
      1  4439				  -	      ifnconst	bankswitch
      2  4439				  -	      rts
      3  4439					      else
      4  4439		       4c dd ff 	      jmp	BS_return
      5  443c					      endif
   2574  443c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2575  443c
   2576  443c				   drawscreen
   2577  443c				  -	      ifconst	debugscore
   2578  443c				  -	      ldx	#14
   2579  443c				  -	      lda	INTIM	; display # cycles left in the score
   2580  443c				  -
   2581  443c				  -	      ifconst	mincycles
   2582  443c				  -	      lda	mincycles
   2583  443c				  -	      cmp	INTIM
   2584  443c				  -	      lda	mincycles
   2585  443c				  -	      bcc	nochange
   2586  443c				  -	      lda	INTIM
   2587  443c				  -	      sta	mincycles
   2588  443c				  -nochange
   2589  443c				  -	      endif
   2590  443c				  -
   2591  443c				  -			; cmp #$2B
   2592  443c				  -			; bcs no_cycles_left
   2593  443c				  -	      bmi	cycles_left
   2594  443c				  -	      ldx	#64
   2595  443c				  -	      eor	#$ff	;make negative
   2596  443c				  -cycles_left
   2597  443c				  -	      stx	scorecolor
   2598  443c				  -	      and	#$7f	; clear sign bit
   2599  443c				  -	      tax
   2600  443c				  -	      lda	scorebcd,x
   2601  443c				  -	      sta	score+2
   2602  443c				  -	      lda	scorebcd1,x
   2603  443c				  -	      sta	score+1
   2604  443c				  -	      jmp	done_debugscore
   2605  443c				  -scorebcd
   2606  443c				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2607  443c				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2608  443c				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2609  443c				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2610  443c				  -scorebcd1
   2611  443c				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2612  443c				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2613  443c				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2614  443c				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2615  443c				  -done_debugscore
   2616  443c					      endif
   2617  443c
   2618  443c				  -	      ifconst	debugcycles
   2619  443c				  -	      lda	INTIM	; if we go over, it mucks up the background color
   2620  443c				  -			; cmp #$2B
   2621  443c				  -			; BCC overscan
   2622  443c				  -	      bmi	overscan
   2623  443c				  -	      sta	COLUBK
   2624  443c				  -	      bcs	doneoverscan
   2625  443c					      endif
   2626  443c
   2627  443c				   overscan
   2628  443c				  -	      ifconst	interlaced
   2629  443c				  -	      PHP
   2630  443c				  -	      PLA
   2631  443c				  -	      EOR	#4	; flip interrupt bit
   2632  443c				  -	      PHA
   2633  443c				  -	      PLP
   2634  443c				  -	      AND	#4	; isolate the interrupt bit
   2635  443c				  -	      TAX		; save it for later
   2636  443c					      endif
   2637  443c
   2638  443c				   overscanloop
   2639  443c		       ad 84 02 	      lda	INTIM	;wait for sync
   2640  443f		       30 fb		      bmi	overscanloop
   2641  4441				   doneoverscan
   2642  4441
   2643  4441							;do VSYNC
   2644  4441
   2645  4441				  -	      ifconst	interlaced
   2646  4441				  -	      CPX	#4
   2647  4441				  -	      BNE	oddframevsync
   2648  4441					      endif
   2649  4441
   2650  4441		       a9 02		      lda	#2
   2651  4443		       85 02		      sta	WSYNC
   2652  4445		       85 00		      sta	VSYNC
   2653  4447		       85 02		      STA	WSYNC
   2654  4449		       85 02		      STA	WSYNC
   2655  444b		       4a		      lsr
   2656  444c		       85 02		      STA	WSYNC
   2657  444e		       85 00		      STA	VSYNC
   2658  4450		       85 01		      sta	VBLANK
   2659  4452				  -	      ifnconst	overscan_time
   2660  4452				  -	      lda	#37+128
   2661  4452					      else
   2662  4452		       a9 a5		      lda	#overscan_time+128
   2663  4454					      endif
   2664  4454		       8d 96 02 	      sta	TIM64T
   2665  4457
   2666  4457				  -	      ifconst	interlaced
   2667  4457				  -	      jmp	postsync
   2668  4457				  -
   2669  4457				  -oddframevsync
   2670  4457				  -	      sta	WSYNC
   2671  4457				  -
   2672  4457				  -	      LDA	($80,X)	; 11 waste
   2673  4457				  -	      LDA	($80,X)	; 11 waste
   2674  4457				  -	      LDA	($80,X)	; 11 waste
   2675  4457				  -
   2676  4457				  -	      lda	#2
   2677  4457				  -	      sta	VSYNC
   2678  4457				  -	      sta	WSYNC
   2679  4457				  -	      sta	WSYNC
   2680  4457				  -	      sta	WSYNC
   2681  4457				  -
   2682  4457				  -	      LDA	($80,X)	; 11 waste
   2683  4457				  -	      LDA	($80,X)	; 11 waste
   2684  4457				  -	      LDA	($80,X)	; 11 waste
   2685  4457				  -
   2686  4457				  -	      lda	#0
   2687  4457				  -	      sta	VSYNC
   2688  4457				  -	      sta	VBLANK
   2689  4457				  -	      ifnconst	overscan_time
   2690  4457				  -	      lda	#37+128
   2691  4457				  -	      else
   2692  4457				  -	      lda	#overscan_time+128
   2693  4457				  -	      endif
   2694  4457				  -	      sta	TIM64T
   2695  4457				  -
   2696  4457				  -postsync
   2697  4457					      endif
   2698  4457
   2699  4457				  -	      ifconst	legacy
   2700  4457				  -	      if	legacy < 100
   2701  4457				  -	      ldx	#4
   2702  4457				  -adjustloop
   2703  4457				  -	      lda	player0x,x
   2704  4457				  -	      sec
   2705  4457				  -	      sbc	#14	;?
   2706  4457				  -	      sta	player0x,x
   2707  4457				  -	      dex
   2708  4457				  -	      bpl	adjustloop
   2709  4457				  -	      endif
   2710  4457					      endif
   2711  4457				  -	      if	((<*)>$e9)&&((<*)<$fa)
   2712  4457				  -	      repeat	($fa-(<*))
   2713  4457				  -	      nop
   2714  4457				  -	      repend
   2715  4457					      endif
   2716  4457		       85 02		      sta	WSYNC
   2717  4459		       a2 04		      ldx	#4
      0  445b					      SLEEP	3
      1  445b				   .CYCLES    SET	3
      2  445b
      3  445b				  -	      IF	.CYCLES < 2
      4  445b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  445b				  -	      ERR
      6  445b					      ENDIF
      7  445b
      8  445b					      IF	.CYCLES & 1
      9  445b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  445b		       04 00		      nop	0
     11  445d				  -	      ELSE
     12  445d				  -	      bit	VSYNC
     13  445d					      ENDIF
     14  445d				   .CYCLES    SET	.CYCLES - 3
     15  445d					      ENDIF
     16  445d
     17  445d				  -	      REPEAT	.CYCLES / 2
     18  445d				  -	      nop
     19  445d					      REPEND
   2719  445d				   HorPosLoop		; 5
   2720  445d		       b5 80		      lda	player0x,X	;+4 9
   2721  445f		       38		      sec		;+2 11
   2722  4460				   DivideLoop
   2723  4460		       e9 0f		      sbc	#15
   2724  4462		       b0 fc		      bcs	DivideLoop	;+4 15
   2725  4464		       95 9c		      sta	temp1,X	;+4 19
   2726  4466		       95 10		      sta	RESP0,X	;+4 23
   2727  4468		       85 02		      sta	WSYNC
   2728  446a		       ca		      dex
   2729  446b		       10 f0		      bpl	HorPosLoop	;+5 5
   2730  446d							; 4
   2731  446d
   2732  446d		       a2 04		      ldx	#4
   2733  446f		       b4 9c		      ldy	temp1,X
   2734  4471		       b9 cd f3 	      lda	repostable-256,Y
   2735  4474		       95 20		      sta	HMP0,X	;+14 18
   2736  4476
   2737  4476		       ca		      dex
   2738  4477		       b4 9c		      ldy	temp1,X
   2739  4479		       b9 cd f3 	      lda	repostable-256,Y
   2740  447c		       95 20		      sta	HMP0,X	;+14 32
   2741  447e
   2742  447e		       ca		      dex
   2743  447f		       b4 9c		      ldy	temp1,X
   2744  4481		       b9 cd f3 	      lda	repostable-256,Y
   2745  4484		       95 20		      sta	HMP0,X	;+14 46
   2746  4486
   2747  4486		       ca		      dex
   2748  4487		       b4 9c		      ldy	temp1,X
   2749  4489		       b9 cd f3 	      lda	repostable-256,Y
   2750  448c		       95 20		      sta	HMP0,X	;+14 60
   2751  448e
   2752  448e		       ca		      dex
   2753  448f		       b4 9c		      ldy	temp1,X
   2754  4491		       b9 cd f3 	      lda	repostable-256,Y
   2755  4494		       95 20		      sta	HMP0,X	;+14 74
   2756  4496
   2757  4496		       85 02		      sta	WSYNC
   2758  4498
   2759  4498		       85 2a		      sta	HMOVE	;+3 3
   2760  449a
   2761  449a
   2762  449a				  -	      ifconst	legacy
   2763  449a				  -	      if	legacy < 100
   2764  449a				  -	      ldx	#4
   2765  449a				  -adjustloop2
   2766  449a				  -	      lda	player0x,x
   2767  449a				  -	      clc
   2768  449a				  -	      adc	#14	;?
   2769  449a				  -	      sta	player0x,x
   2770  449a				  -	      dex
   2771  449a				  -	      bpl	adjustloop2
   2772  449a				  -	      endif
   2773  449a					      endif
   2774  449a
   2775  449a
   2776  449a
   2777  449a
   2778  449a							;set score pointers
   2779  449a		       a7 95		      lax	score+2
   2780  449c		       20 cd f4 	      jsr	scorepointerset
   2781  449f		       84 9b		      sty	scorepointers+5
   2782  44a1		       86 98		      stx	scorepointers+2
   2783  44a3		       a7 94		      lax	score+1
   2784  44a5		       20 cd f4 	      jsr	scorepointerset
   2785  44a8		       84 9a		      sty	scorepointers+4
   2786  44aa		       86 97		      stx	scorepointers+1
   2787  44ac		       a7 93		      lax	score
   2788  44ae		       20 cd f4 	      jsr	scorepointerset
   2789  44b1		       84 99		      sty	scorepointers+3
   2790  44b3		       86 96		      stx	scorepointers
   2791  44b5
   2792  44b5				   vblk
   2793  44b5							; run possible vblank bB code
   2794  44b5				  -	      ifconst	vblank_bB_code
   2795  44b5				  -	      jsr	vblank_bB_code
   2796  44b5					      endif
   2797  44b5				   vblk2
   2798  44b5		       ad 84 02 	      LDA	INTIM
   2799  44b8		       30 fb		      bmi	vblk2
   2800  44ba		       4c 00 f0 	      jmp	kernel
   2801  44bd
   2802  44bd
   2803  44bd		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   2804  44c6		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   2805  44cd				   repostable
   2806  44cd
   2807  44cd				   scorepointerset
   2808  44cd		       29 0f		      and	#$0F
   2809  44cf		       0a		      asl
   2810  44d0		       0a		      asl
   2811  44d1		       0a		      asl
   2812  44d2		       69 74		      adc	#<scoretable
   2813  44d4		       a8		      tay
   2814  44d5		       8a		      txa
   2815  44d6							; and #$F0
   2816  44d6							; lsr
   2817  44d6		       4b f0		      asr	#$F0
   2818  44d8		       69 74		      adc	#<scoretable
   2819  44da		       aa		      tax
   2820  44db		       60		      rts
   2821  44dc							;bB.asm
   2822  44dc							; bB.asm file is split here
   2823  44dc				  -	      ifconst	pfres
   2824  44dc				  -	      if	(<*) > (254-pfres*pfwidth)
   2825  44dc				  -	      align	256
   2826  44dc				  -	      endif
   2827  44dc				  -	      if	(<*) < (136-pfres*pfwidth)
   2828  44dc				  -	      repeat	((136-pfres*pfwidth)-(<*))
   2829  44dc				  -	      .byte	0
   2830  44dc				  -	      repend
   2831  44dc				  -	      endif
   2832  44dc					      else
   2833  44dc					      if	(<*) > 206
   2834  4500		       00 00 00 00*	      align	256
   2835  4500					      endif
   2836  4500					      if	(<*) < 88
   2837  4500					      repeat	(88-(<*))
   2838  4500		       00		      .byte.b	0
   2837  4500					      repend
   2838  4501		       00		      .byte.b	0
   2837  4501					      repend
   2838  4502		       00		      .byte.b	0
   2837  4502					      repend
   2838  4503		       00		      .byte.b	0
   2837  4503					      repend
   2838  4504		       00		      .byte.b	0
   2837  4504					      repend
   2838  4505		       00		      .byte.b	0
   2837  4505					      repend
   2838  4506		       00		      .byte.b	0
   2837  4506					      repend
   2838  4507		       00		      .byte.b	0
   2837  4507					      repend
   2838  4508		       00		      .byte.b	0
   2837  4508					      repend
   2838  4509		       00		      .byte.b	0
   2837  4509					      repend
   2838  450a		       00		      .byte.b	0
   2837  450a					      repend
   2838  450b		       00		      .byte.b	0
   2837  450b					      repend
   2838  450c		       00		      .byte.b	0
   2837  450c					      repend
   2838  450d		       00		      .byte.b	0
   2837  450d					      repend
   2838  450e		       00		      .byte.b	0
   2837  450e					      repend
   2838  450f		       00		      .byte.b	0
   2837  450f					      repend
   2838  4510		       00		      .byte.b	0
   2837  4510					      repend
   2838  4511		       00		      .byte.b	0
   2837  4511					      repend
   2838  4512		       00		      .byte.b	0
   2837  4512					      repend
   2838  4513		       00		      .byte.b	0
   2837  4513					      repend
   2838  4514		       00		      .byte.b	0
   2837  4514					      repend
   2838  4515		       00		      .byte.b	0
   2837  4515					      repend
   2838  4516		       00		      .byte.b	0
   2837  4516					      repend
   2838  4517		       00		      .byte.b	0
   2837  4517					      repend
   2838  4518		       00		      .byte.b	0
   2837  4518					      repend
   2838  4519		       00		      .byte.b	0
   2837  4519					      repend
   2838  451a		       00		      .byte.b	0
   2837  451a					      repend
   2838  451b		       00		      .byte.b	0
   2837  451b					      repend
   2838  451c		       00		      .byte.b	0
   2837  451c					      repend
   2838  451d		       00		      .byte.b	0
   2837  451d					      repend
   2838  451e		       00		      .byte.b	0
   2837  451e					      repend
   2838  451f		       00		      .byte.b	0
   2837  451f					      repend
   2838  4520		       00		      .byte.b	0
   2837  4520					      repend
   2838  4521		       00		      .byte.b	0
   2837  4521					      repend
   2838  4522		       00		      .byte.b	0
   2837  4522					      repend
   2838  4523		       00		      .byte.b	0
   2837  4523					      repend
   2838  4524		       00		      .byte.b	0
   2837  4524					      repend
   2838  4525		       00		      .byte.b	0
   2837  4525					      repend
   2838  4526		       00		      .byte.b	0
   2837  4526					      repend
   2838  4527		       00		      .byte.b	0
   2837  4527					      repend
   2838  4528		       00		      .byte.b	0
   2837  4528					      repend
   2838  4529		       00		      .byte.b	0
   2837  4529					      repend
   2838  452a		       00		      .byte.b	0
   2837  452a					      repend
   2838  452b		       00		      .byte.b	0
   2837  452b					      repend
   2838  452c		       00		      .byte.b	0
   2837  452c					      repend
   2838  452d		       00		      .byte.b	0
   2837  452d					      repend
   2838  452e		       00		      .byte.b	0
   2837  452e					      repend
   2838  452f		       00		      .byte.b	0
   2837  452f					      repend
   2838  4530		       00		      .byte.b	0
   2837  4530					      repend
   2838  4531		       00		      .byte.b	0
   2837  4531					      repend
   2838  4532		       00		      .byte.b	0
   2837  4532					      repend
   2838  4533		       00		      .byte.b	0
   2837  4533					      repend
   2838  4534		       00		      .byte.b	0
   2837  4534					      repend
   2838  4535		       00		      .byte.b	0
   2837  4535					      repend
   2838  4536		       00		      .byte.b	0
   2837  4536					      repend
   2838  4537		       00		      .byte.b	0
   2837  4537					      repend
   2838  4538		       00		      .byte.b	0
   2837  4538					      repend
   2838  4539		       00		      .byte.b	0
   2837  4539					      repend
   2838  453a		       00		      .byte.b	0
   2837  453a					      repend
   2838  453b		       00		      .byte.b	0
   2837  453b					      repend
   2838  453c		       00		      .byte.b	0
   2837  453c					      repend
   2838  453d		       00		      .byte.b	0
   2837  453d					      repend
   2838  453e		       00		      .byte.b	0
   2837  453e					      repend
   2838  453f		       00		      .byte.b	0
   2837  453f					      repend
   2838  4540		       00		      .byte.b	0
   2837  4540					      repend
   2838  4541		       00		      .byte.b	0
   2837  4541					      repend
   2838  4542		       00		      .byte.b	0
   2837  4542					      repend
   2838  4543		       00		      .byte.b	0
   2837  4543					      repend
   2838  4544		       00		      .byte.b	0
   2837  4544					      repend
   2838  4545		       00		      .byte.b	0
   2837  4545					      repend
   2838  4546		       00		      .byte.b	0
   2837  4546					      repend
   2838  4547		       00		      .byte.b	0
   2837  4547					      repend
   2838  4548		       00		      .byte.b	0
   2837  4548					      repend
   2838  4549		       00		      .byte.b	0
   2837  4549					      repend
   2838  454a		       00		      .byte.b	0
   2837  454a					      repend
   2838  454b		       00		      .byte.b	0
   2837  454b					      repend
   2838  454c		       00		      .byte.b	0
   2837  454c					      repend
   2838  454d		       00		      .byte.b	0
   2837  454d					      repend
   2838  454e		       00		      .byte.b	0
   2837  454e					      repend
   2838  454f		       00		      .byte.b	0
   2837  454f					      repend
   2838  4550		       00		      .byte.b	0
   2837  4550					      repend
   2838  4551		       00		      .byte.b	0
   2837  4551					      repend
   2838  4552		       00		      .byte.b	0
   2837  4552					      repend
   2838  4553		       00		      .byte.b	0
   2837  4553					      repend
   2838  4554		       00		      .byte.b	0
   2837  4554					      repend
   2838  4555		       00		      .byte.b	0
   2837  4555					      repend
   2838  4556		       00		      .byte.b	0
   2837  4556					      repend
   2838  4557		       00		      .byte.b	0
   2839  4558					      repend
   2840  4558					      endif
   2841  4558					      endif
   2842  4558				   pfcolorlabel13
   2843  4558		       9e 00 00 00	      .byte.b	$9E ,0,0,0
   2844  455c		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2845  4560		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2846  4564		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2847  4568		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2848  456c		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2849  4570		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2850  4574		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2851  4578		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2852  457c		       9e 00 00 00	      .byte.b	$9E,0,0,0
   2853  4580				  -	      if	(<*) > (<(*+9))
   2854  4580				  -	      repeat	($100-<*)
   2855  4580				  -	      .byte	0
   2856  4580				  -	      repend
   2857  4580					      endif
   2858  4580				   playerL043_0
   2859  4580		       42		      .byte.b	%01000010
   2860  4581		       64		      .byte.b	%01100100
   2861  4582		       1c		      .byte.b	%00011100
   2862  4583		       3c		      .byte.b	%00111100
   2863  4584		       1c		      .byte.b	%00011100
   2864  4585		       18		      .byte.b	%00011000
   2865  4586		       0c		      .byte.b	%00001100
   2866  4587		       0c		      .byte.b	%00001100
   2867  4588		       0c		      .byte.b	%00001100
   2868  4589		       00		      .byte.b	%00000000
   2869  458a				  -	      if	(<*) > (<(*+9))
   2870  458a				  -	      repeat	($100-<*)
   2871  458a				  -	      .byte	0
   2872  458a				  -	      repend
   2873  458a					      endif
   2874  458a				   playerL044_1
   2875  458a		       f8		      .byte.b	%11111000
   2876  458b		       f8		      .byte.b	%11111000
   2877  458c		       ff		      .byte.b	%11111111
   2878  458d		       f9		      .byte.b	%11111001
   2879  458e		       f9		      .byte.b	%11111001
   2880  458f		       f9		      .byte.b	%11111001
   2881  4590		       ff		      .byte.b	%11111111
   2882  4591		       f8		      .byte.b	%11111000
   2883  4592		       f8		      .byte.b	%11111000
   2884  4593		       f8		      .byte.b	%11111000
   2885  4594				  -	      if	(<*) > (<(*+10))
   2886  4594				  -	      repeat	($100-<*)
   2887  4594				  -	      .byte	0
   2888  4594				  -	      repend
   2889  4594					      endif
   2890  4594				   playercolorL045_0
   2891  4594		       84		      .byte.b	$84	;
   2892  4595		       84		      .byte.b	$84	;
   2893  4596		       84		      .byte.b	$84	;
   2894  4597		       b4		      .byte.b	$B4	;
   2895  4598		       b4		      .byte.b	$B4	;
   2896  4599		       b4		      .byte.b	$B4	;
   2897  459a		       fe		      .byte.b	$FE	;
   2898  459b		       fe		      .byte.b	$FE	;
   2899  459c		       fe		      .byte.b	$FE	;
   2900  459d		       fe		      .byte.b	$FE	;
   2901  459e		       0e		      .byte.b	$0E	;
   2902  459f				  -	      if	(<*) > (<(*+9))
   2903  459f				  -	      repeat	($100-<*)
   2904  459f				  -	      .byte	0
   2905  459f				  -	      repend
   2906  459f					      endif
   2907  459f				   playercolorL046_1
   2908  459f		       1c		      .byte.b	$1C	;
   2909  45a0		       1c		      .byte.b	$1C	;
   2910  45a1		       1c		      .byte.b	$1C	;
   2911  45a2		       1c		      .byte.b	$1C	;
   2912  45a3		       1c		      .byte.b	$1C	;
   2913  45a4		       1c		      .byte.b	$1C	;
   2914  45a5		       1c		      .byte.b	$1C	;
   2915  45a6		       1c		      .byte.b	$1C	;
   2916  45a7		       0e		      .byte.b	$0E	;
   2917  45a8		       0e		      .byte.b	$0E	;
   2918  45a9				  -	      if	(<*) > (<(*+9))
   2919  45a9				  -	      repeat	($100-<*)
   2920  45a9				  -	      .byte	0
   2921  45a9				  -	      repend
   2922  45a9					      endif
   2923  45a9				   player2then_0
   2924  45a9		       06		      .byte.b	%00000110
   2925  45aa		       64		      .byte.b	%01100100
   2926  45ab		       1c		      .byte.b	%00011100
   2927  45ac		       5a		      .byte.b	%01011010
   2928  45ad		       3c		      .byte.b	%00111100
   2929  45ae		       18		      .byte.b	%00011000
   2930  45af		       0c		      .byte.b	%00001100
   2931  45b0		       0c		      .byte.b	%00001100
   2932  45b1		       0c		      .byte.b	%00001100
   2933  45b2		       00		      .byte.b	%00000000
   2934  45b3				  -	      if	(<*) > (<(*+9))
   2935  45b3				  -	      repeat	($100-<*)
   2936  45b3				  -	      .byte	0
   2937  45b3				  -	      repend
   2938  45b3					      endif
   2939  45b3				   playercolor3then_0
   2940  45b3		       84		      .byte.b	$84	;
   2941  45b4		       84		      .byte.b	$84	;
   2942  45b5		       84		      .byte.b	$84	;
   2943  45b6		       b4		      .byte.b	$B4	;
   2944  45b7		       b4		      .byte.b	$B4	;
   2945  45b8		       b4		      .byte.b	$B4	;
   2946  45b9		       fe		      .byte.b	$FE	;
   2947  45ba		       fe		      .byte.b	$FE	;
   2948  45bb		       fe		      .byte.b	$FE	;
   2949  45bc		       fe		      .byte.b	$FE	;
   2950  45bd				  -	      if	(<*) > (<(*+9))
   2951  45bd				  -	      repeat	($100-<*)
   2952  45bd				  -	      .byte	0
   2953  45bd				  -	      repend
   2954  45bd					      endif
   2955  45bd				   player4then_0
   2956  45bd		       18		      .byte.b	%00011000
   2957  45be		       38		      .byte.b	%00111000
   2958  45bf		       18		      .byte.b	%00011000
   2959  45c0		       18		      .byte.b	%00011000
   2960  45c1		       18		      .byte.b	%00011000
   2961  45c2		       18		      .byte.b	%00011000
   2962  45c3		       0c		      .byte.b	%00001100
   2963  45c4		       0c		      .byte.b	%00001100
   2964  45c5		       0c		      .byte.b	%00001100
   2965  45c6		       00		      .byte.b	%00000000
   2966  45c7				  -	      if	(<*) > (<(*+9))
   2967  45c7				  -	      repeat	($100-<*)
   2968  45c7				  -	      .byte	0
   2969  45c7				  -	      repend
   2970  45c7					      endif
   2971  45c7				   playercolor5then_0
   2972  45c7		       84		      .byte.b	$84	;
   2973  45c8		       84		      .byte.b	$84	;
   2974  45c9		       84		      .byte.b	$84	;
   2975  45ca		       b4		      .byte.b	$B4	;
   2976  45cb		       b4		      .byte.b	$B4	;
   2977  45cc		       b4		      .byte.b	$B4	;
   2978  45cd		       fe		      .byte.b	$FE	;
   2979  45ce		       fe		      .byte.b	$FE	;
   2980  45cf		       fe		      .byte.b	$FE	;
   2981  45d0		       fe		      .byte.b	$FE	;
   2982  45d1				  -	      if	(<*) > (<(*+9))
   2983  45d1				  -	      repeat	($100-<*)
   2984  45d1				  -	      .byte	0
   2985  45d1				  -	      repend
   2986  45d1					      endif
   2987  45d1				   player6then_0
   2988  45d1		       40		      .byte.b	%01000000
   2989  45d2		       50		      .byte.b	%01010000
   2990  45d3		       48		      .byte.b	%01001000
   2991  45d4		       38		      .byte.b	%00111000
   2992  45d5		       78		      .byte.b	%01111000
   2993  45d6		       38		      .byte.b	%00111000
   2994  45d7		       30		      .byte.b	%00110000
   2995  45d8		       18		      .byte.b	%00011000
   2996  45d9		       18		      .byte.b	%00011000
   2997  45da		       18		      .byte.b	%00011000
   2998  45db					      if	ECHOFIRST
      2457 bytes of ROM space left in bank 4
   2999  45db					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 4")
   3000  45db					      endif
   3001  45db		       00 01	   ECHOFIRST  =	1
   3002  45db
   3003  45db
   3004  45db							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3005  45db
   3006  45db							; feel free to modify the score graphics - just keep each digit 8 high
   3007  45db							; and keep the conditional compilation stuff intact
   3008  45db				  -	      ifconst	ROM2k
   3009  45db				  -	      ORG	$F7AC-8
   3010  45db					      else
   3011  45db					      ifconst	bankswitch
   3012  45db				  -	      if	bankswitch == 8
   3013  45db				  -	      ORG	$2F94-bscode_length
   3014  45db				  -	      RORG	$FF94-bscode_length
   3015  45db					      endif
   3016  45db					      if	bankswitch == 16
   3017  4f74					      ORG	$4F94-bscode_length
   3018  4f74					      RORG	$FF94-bscode_length
   3019  4f74					      endif
   3020  4f74				  -	      if	bankswitch == 32
   3021  4f74				  -	      ORG	$8F94-bscode_length
   3022  4f74				  -	      RORG	$FF94-bscode_length
   3023  4f74					      endif
   3024  4f74				  -	      if	bankswitch == 64
   3025  4f74				  -	      ORG	$10F80-bscode_length
   3026  4f74				  -	      RORG	$1FF80-bscode_length
   3027  4f74					      endif
   3028  4f74				  -	      else
   3029  4f74				  -	      ORG	$FF9C
   3030  4f74					      endif
   3031  4f74					      endif
   3032  4f74
   3033  4f74							; font equates
   3034  4f74		       00 01	   .21stcentury =	1
   3035  4f74		       00 02	   alarmclock =	2
   3036  4f74		       00 03	   handwritten =	3
   3037  4f74		       00 04	   interrupted =	4
   3038  4f74		       00 05	   retroputer =	5
   3039  4f74		       00 06	   whimsey    =	6
   3040  4f74		       00 07	   tiny       =	7
   3041  4f74		       00 08	   hex	      =	8
   3042  4f74
   3043  4f74				  -	      ifconst	font
   3044  4f74				  -	      if	font == hex
   3045  4f74				  -	      ORG	. - 48
   3046  4f74				  -	      endif
   3047  4f74					      endif
   3048  4f74
   3049  4f74				   scoretable
   3050  4f74
   3051  4f74				  -	      ifconst	font
   3052  4f74				  -	      if	font == .21stcentury
   3053  4f74				  -	      include	"score_graphics.asm.21stcentury"
   3054  4f74				  -	      endif
   3055  4f74				  -	      if	font == alarmclock
   3056  4f74				  -	      include	"score_graphics.asm.alarmclock"
   3057  4f74				  -	      endif
   3058  4f74				  -	      if	font == handwritten
   3059  4f74				  -	      include	"score_graphics.asm.handwritten"
   3060  4f74				  -	      endif
   3061  4f74				  -	      if	font == interrupted
   3062  4f74				  -	      include	"score_graphics.asm.interrupted"
   3063  4f74				  -	      endif
   3064  4f74				  -	      if	font == retroputer
   3065  4f74				  -	      include	"score_graphics.asm.retroputer"
   3066  4f74				  -	      endif
   3067  4f74				  -	      if	font == whimsey
   3068  4f74				  -	      include	"score_graphics.asm.whimsey"
   3069  4f74				  -	      endif
   3070  4f74				  -	      if	font == tiny
   3071  4f74				  -	      include	"score_graphics.asm.tiny"
   3072  4f74				  -	      endif
   3073  4f74				  -	      if	font == hex
   3074  4f74				  -	      include	"score_graphics.asm.hex"
   3075  4f74				  -	      endif
   3076  4f74					      else		; default font
   3077  4f74
   3078  4f74		       3c		      .byte.b	%00111100
   3079  4f75		       66		      .byte.b	%01100110
   3080  4f76		       66		      .byte.b	%01100110
   3081  4f77		       66		      .byte.b	%01100110
   3082  4f78		       66		      .byte.b	%01100110
   3083  4f79		       66		      .byte.b	%01100110
   3084  4f7a		       66		      .byte.b	%01100110
   3085  4f7b		       3c		      .byte.b	%00111100
   3086  4f7c
   3087  4f7c		       7e		      .byte.b	%01111110
   3088  4f7d		       18		      .byte.b	%00011000
   3089  4f7e		       18		      .byte.b	%00011000
   3090  4f7f		       18		      .byte.b	%00011000
   3091  4f80		       18		      .byte.b	%00011000
   3092  4f81		       38		      .byte.b	%00111000
   3093  4f82		       18		      .byte.b	%00011000
   3094  4f83		       08		      .byte.b	%00001000
   3095  4f84
   3096  4f84		       7e		      .byte.b	%01111110
   3097  4f85		       60		      .byte.b	%01100000
   3098  4f86		       60		      .byte.b	%01100000
   3099  4f87		       3c		      .byte.b	%00111100
   3100  4f88		       06		      .byte.b	%00000110
   3101  4f89		       06		      .byte.b	%00000110
   3102  4f8a		       46		      .byte.b	%01000110
   3103  4f8b		       3c		      .byte.b	%00111100
   3104  4f8c
   3105  4f8c		       3c		      .byte.b	%00111100
   3106  4f8d		       46		      .byte.b	%01000110
   3107  4f8e		       06		      .byte.b	%00000110
   3108  4f8f		       06		      .byte.b	%00000110
   3109  4f90		       1c		      .byte.b	%00011100
   3110  4f91		       06		      .byte.b	%00000110
   3111  4f92		       46		      .byte.b	%01000110
   3112  4f93		       3c		      .byte.b	%00111100
   3113  4f94
   3114  4f94		       0c		      .byte.b	%00001100
   3115  4f95		       0c		      .byte.b	%00001100
   3116  4f96		       7e		      .byte.b	%01111110
   3117  4f97		       4c		      .byte.b	%01001100
   3118  4f98		       4c		      .byte.b	%01001100
   3119  4f99		       2c		      .byte.b	%00101100
   3120  4f9a		       1c		      .byte.b	%00011100
   3121  4f9b		       0c		      .byte.b	%00001100
   3122  4f9c
   3123  4f9c		       3c		      .byte.b	%00111100
   3124  4f9d		       46		      .byte.b	%01000110
   3125  4f9e		       06		      .byte.b	%00000110
   3126  4f9f		       06		      .byte.b	%00000110
   3127  4fa0		       3c		      .byte.b	%00111100
   3128  4fa1		       60		      .byte.b	%01100000
   3129  4fa2		       60		      .byte.b	%01100000
   3130  4fa3		       7e		      .byte.b	%01111110
   3131  4fa4
   3132  4fa4		       3c		      .byte.b	%00111100
   3133  4fa5		       66		      .byte.b	%01100110
   3134  4fa6		       66		      .byte.b	%01100110
   3135  4fa7		       66		      .byte.b	%01100110
   3136  4fa8		       7c		      .byte.b	%01111100
   3137  4fa9		       60		      .byte.b	%01100000
   3138  4faa		       62		      .byte.b	%01100010
   3139  4fab		       3c		      .byte.b	%00111100
   3140  4fac
   3141  4fac		       30		      .byte.b	%00110000
   3142  4fad		       30		      .byte.b	%00110000
   3143  4fae		       30		      .byte.b	%00110000
   3144  4faf		       18		      .byte.b	%00011000
   3145  4fb0		       0c		      .byte.b	%00001100
   3146  4fb1		       06		      .byte.b	%00000110
   3147  4fb2		       42		      .byte.b	%01000010
   3148  4fb3		       3e		      .byte.b	%00111110
   3149  4fb4
   3150  4fb4		       3c		      .byte.b	%00111100
   3151  4fb5		       66		      .byte.b	%01100110
   3152  4fb6		       66		      .byte.b	%01100110
   3153  4fb7		       66		      .byte.b	%01100110
   3154  4fb8		       3c		      .byte.b	%00111100
   3155  4fb9		       66		      .byte.b	%01100110
   3156  4fba		       66		      .byte.b	%01100110
   3157  4fbb		       3c		      .byte.b	%00111100
   3158  4fbc
   3159  4fbc		       3c		      .byte.b	%00111100
   3160  4fbd		       46		      .byte.b	%01000110
   3161  4fbe		       06		      .byte.b	%00000110
   3162  4fbf		       3e		      .byte.b	%00111110
   3163  4fc0		       66		      .byte.b	%01100110
   3164  4fc1		       66		      .byte.b	%01100110
   3165  4fc2		       66		      .byte.b	%01100110
   3166  4fc3		       3c		      .byte.b	%00111100
   3167  4fc4
   3168  4fc4					      ifnconst	DPC_kernel_options
   3169  4fc4
   3170  4fc4		       00		      .byte.b	%00000000
   3171  4fc5		       00		      .byte.b	%00000000
   3172  4fc6		       00		      .byte.b	%00000000
   3173  4fc7		       00		      .byte.b	%00000000
   3174  4fc8		       00		      .byte.b	%00000000
   3175  4fc9		       00		      .byte.b	%00000000
   3176  4fca		       00		      .byte.b	%00000000
   3177  4fcb		       00		      .byte.b	%00000000
   3178  4fcc
   3179  4fcc					      endif
   3180  4fcc
   3181  4fcc					      endif
   3182  4fcc
   3183  4fcc				  -	      ifconst	ROM2k
   3184  4fcc				  -	      ORG	$F7FC
   3185  4fcc					      else
   3186  4fcc					      ifconst	bankswitch
   3187  4fcc				  -	      if	bankswitch == 8
   3188  4fcc				  -	      ORG	$2FF4-bscode_length
   3189  4fcc				  -	      RORG	$FFF4-bscode_length
   3190  4fcc					      endif
   3191  4fcc					      if	bankswitch == 16
   3192  4fd4					      ORG	$4FF4-bscode_length
   3193  4fd4					      RORG	$FFF4-bscode_length
   3194  4fd4					      endif
   3195  4fd4				  -	      if	bankswitch == 32
   3196  4fd4				  -	      ORG	$8FF4-bscode_length
   3197  4fd4				  -	      RORG	$FFF4-bscode_length
   3198  4fd4					      endif
   3199  4fd4				  -	      if	bankswitch == 64
   3200  4fd4				  -	      ORG	$10FE0-bscode_length
   3201  4fd4				  -	      RORG	$1FFE0-bscode_length
   3202  4fd4					      endif
   3203  4fd4				  -	      else
   3204  4fd4				  -	      ORG	$FFFC
   3205  4fd4					      endif
   3206  4fd4					      endif
   3207  4fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3208  4fd4
   3209  4fd4							; every bank has this stuff at the same place
   3210  4fd4							; this code can switch to/from any bank at any entry point
   3211  4fd4							; and can preserve register values
   3212  4fd4							; note: lines not starting with a space are not placed in all banks
   3213  4fd4							;
   3214  4fd4							; line below tells the compiler how long this is - do not remove
   3215  4fd4							;size=32
   3216  4fd4
   3217  4fd4				   begin_bscode
   3218  4fd4		       a2 ff		      ldx	#$ff
   3219  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3220  4fd6				  -	      stx	FASTFETCH
   3221  4fd6					      endif
   3222  4fd6		       9a		      txs
   3223  4fd7				  -	      if	bankswitch == 64
   3224  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3225  4fd7					      else
   3226  4fd7		       a9 f2		      lda	#>(start-1)
   3227  4fd9					      endif
   3228  4fd9		       48		      pha
   3229  4fda		       a9 51		      lda	#<(start-1)
   3230  4fdc		       48		      pha
   3231  4fdd
   3232  4fdd				   BS_return
   3233  4fdd		       48		      pha
   3234  4fde		       8a		      txa
   3235  4fdf		       48		      pha
   3236  4fe0		       ba		      tsx
   3237  4fe1
   3238  4fe1					      if	bankswitch != 64
   3239  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   3240  4fe3
   3241  4fe3		       2a		      rol
   3242  4fe4		       2a		      rol
   3243  4fe5		       2a		      rol
   3244  4fe6		       2a		      rol
   3245  4fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3246  4fe9		       aa		      tax
   3247  4fea		       e8		      inx
   3248  4feb				  -	      else
   3249  4feb				  -	      lda	4,x	; get high byte of return address
   3250  4feb				  -	      tay
   3251  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3252  4feb				  -	      sta	4,x
   3253  4feb				  -	      tya
   3254  4feb				  -	      lsr
   3255  4feb				  -	      lsr
   3256  4feb				  -	      lsr
   3257  4feb				  -	      lsr
   3258  4feb				  -	      tax
   3259  4feb				  -	      inx
   3260  4feb					      endif
   3261  4feb
   3262  4feb				   BS_jsr
   3263  4feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3264  4fee		       68		      pla
   3265  4fef		       aa		      tax
   3266  4ff0		       68		      pla
   3267  4ff1		       60		      rts
   3268  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3269  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3270  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3271  4ff2					      endif
   3272  4ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3273  4ff2
   3274  4ff2					      ifconst	bankswitch
   3275  4ff2				  -	      if	bankswitch == 8
   3276  4ff2				  -	      ORG	$2FFC
   3277  4ff2				  -	      RORG	$FFFC
   3278  4ff2					      endif
   3279  4ff2					      if	bankswitch == 16
   3280  4ffc					      ORG	$4FFC
   3281  4ffc					      RORG	$FFFC
   3282  4ffc					      endif
   3283  4ffc				  -	      if	bankswitch == 32
   3284  4ffc				  -	      ORG	$8FFC
   3285  4ffc				  -	      RORG	$FFFC
   3286  4ffc					      endif
   3287  4ffc				  -	      if	bankswitch == 64
   3288  4ffc				  -	      ORG	$10FF0
   3289  4ffc				  -	      RORG	$1FFF0
   3290  4ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3291  4ffc				  -	      ORG	$10FF8
   3292  4ffc				  -	      RORG	$1FFF8
   3293  4ffc				  -	      ifconst	superchip
   3294  4ffc				  -	      .byte	"E","F","S","C"
   3295  4ffc				  -	      else
   3296  4ffc				  -	      .byte	"E","F","E","F"
   3297  4ffc				  -	      endif
   3298  4ffc				  -	      ORG	$10FFC
   3299  4ffc				  -	      RORG	$1FFFC
   3300  4ffc					      endif
   3301  4ffc				  -	      else
   3302  4ffc				  -	      ifconst	ROM2k
   3303  4ffc				  -	      ORG	$F7FC
   3304  4ffc				  -	      else
   3305  4ffc				  -	      ORG	$FFFC
   3306  4ffc				  -	      endif
   3307  4ffc					      endif
   3308  4ffc		       52 f2		      .word.w	(start & $ffff)
   3309  4ffe		       52 f2		      .word.w	(start & $ffff)
