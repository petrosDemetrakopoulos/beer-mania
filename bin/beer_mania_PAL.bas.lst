------- FILE beer_mania_PAL.bas.asm LEVEL 1 PASS 2
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE beer_mania_PAL.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE beer_mania_PAL.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 01	   pfscore    =	1
      5  5000 ????
      6  5000 ????	       00 eb	   _Ch0_Duration4 =	x
      7  5000 ????
      8  5000 ????	       00 ea	   _Ch0_Duration3 =	w
      9  5000 ????
     10  5000 ????	       00 e9	   _Ch0_Duration2 =	v
     11  5000 ????
     12  5000 ????	       00 e4	   _Ch0_Duration1 =	q
     13  5000 ????
     14  5000 ????	       00 e0	   _Ch0_Sound =	m
     15  5000 ????
     16  5000 ????	       00 e1	   rand16     =	n
     17  5000 ????
     18  5000 ????	       00 d6	   bmp_player0_index =	c
     19  5000 ????
     20  5000 ????	       00 d7	   missed     =	d
     21  5000 ????
     22  5000 ????	       00 4b	   logo_height =	75
     23  5000 ????
     24  5000 ????	       00 4c	   logo_color =	$4C
     25  5000 ????
     26  5000 ????	       00 d5	   addvalue   =	b
     27  5000 ????
     28  5000 ????	       00 d4	   frame      =	a
     29  5000 ????
     30  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     31  5000 ????
     32  5000 ????	       00 3a	   vblank_time =	58
     33  5000 ????	       00 52	   overscan_time =	82
     34  5000 ????	       00 01	   PFcolors   =	1
     35  5000 ????	       00 01	   no_blank_lines =	1
     36  5000 ????	       00 01	   player1colors =	1
     37  5000 ????	       00 03	   bs_mask    =	3
     38  5000 ????	       00 10	   bankswitch =	16
     39  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
------- FILE 2600basic.h
      7  5000 ????
      8  5000 ????	       00 80	   player0x   =	$80
      9  5000 ????	       00 81	   player1x   =	$81
     10  5000 ????	       00 82	   missile0x  =	$82
     11  5000 ????	       00 83	   missile1x  =	$83
     12  5000 ????	       00 84	   ballx      =	$84
     13  5000 ????
     14  5000 ????	       00 85	   objecty    =	$85
     15  5000 ????	       00 85	   player0y   =	$85
     16  5000 ????	       00 86	   player1y   =	$86
     17  5000 ????	       00 87	   missile1height =	$87
     18  5000 ????	       00 88	   missile1y  =	$88
     19  5000 ????	       00 89	   bally      =	$89
     20  5000 ????
     21  5000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  5000 ????
     23  5000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  5000 ????	       00 8a	   player0pointerlo =	$8A
     25  5000 ????	       00 8b	   player0pointerhi =	$8B
     26  5000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  5000 ????	       00 8c	   player1pointerlo =	$8C
     28  5000 ????	       00 8d	   player1pointerhi =	$8D
     29  5000 ????
     30  5000 ????	       00 8e	   player0height =	$8E
     31  5000 ????	       00 8f	   player1height =	$8F
     32  5000 ????	       00 90	   missile0height =	$90
     33  5000 ????	       00 91	   missile0y  =	$91
     34  5000 ????	       00 92	   ballheight =	$92
     35  5000 ????
     36  5000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  5000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  5000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  5000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  5000 ????
     41  5000 ????	       00 93	   score      =	$93	; $93-$95
     42  5000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  5000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  5000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  5000 ????	       00 9e	   temp3      =	$9E
     46  5000 ????	       00 9f	   temp4      =	$9F
     47  5000 ????	       00 a0	   temp5      =	$A0
     48  5000 ????	       00 a1	   temp6      =	$A1
     49  5000 ????
     50  5000 ????	       00 a2	   rand       =	$A2
     51  5000 ????	       00 a3	   scorecolor =	$A3
     52  5000 ????
     53  5000 ????	       00 a4	   var0       =	$A4
     54  5000 ????	       00 a5	   var1       =	$A5
     55  5000 ????	       00 a6	   var2       =	$A6
     56  5000 ????	       00 a7	   var3       =	$A7
     57  5000 ????	       00 a8	   var4       =	$A8
     58  5000 ????	       00 a9	   var5       =	$A9
     59  5000 ????	       00 aa	   var6       =	$AA
     60  5000 ????	       00 ab	   var7       =	$AB
     61  5000 ????	       00 ac	   var8       =	$AC
     62  5000 ????	       00 ad	   var9       =	$AD
     63  5000 ????	       00 ae	   var10      =	$AE
     64  5000 ????	       00 af	   var11      =	$AF
     65  5000 ????	       00 b0	   var12      =	$B0
     66  5000 ????	       00 b1	   var13      =	$B1
     67  5000 ????	       00 b2	   var14      =	$B2
     68  5000 ????	       00 b3	   var15      =	$B3
     69  5000 ????	       00 b4	   var16      =	$B4
     70  5000 ????	       00 b5	   var17      =	$B5
     71  5000 ????	       00 b6	   var18      =	$B6
     72  5000 ????	       00 b7	   var19      =	$B7
     73  5000 ????	       00 b8	   var20      =	$B8
     74  5000 ????	       00 b9	   var21      =	$B9
     75  5000 ????	       00 ba	   var22      =	$BA
     76  5000 ????	       00 bb	   var23      =	$BB
     77  5000 ????	       00 bc	   var24      =	$BC
     78  5000 ????	       00 bd	   var25      =	$BD
     79  5000 ????	       00 be	   var26      =	$BE
     80  5000 ????	       00 bf	   var27      =	$BF
     81  5000 ????	       00 c0	   var28      =	$C0
     82  5000 ????	       00 c1	   var29      =	$C1
     83  5000 ????	       00 c2	   var30      =	$C2
     84  5000 ????	       00 c3	   var31      =	$C3
     85  5000 ????	       00 c4	   var32      =	$C4
     86  5000 ????	       00 c5	   var33      =	$C5
     87  5000 ????	       00 c6	   var34      =	$C6
     88  5000 ????	       00 c7	   var35      =	$C7
     89  5000 ????	       00 c8	   var36      =	$C8
     90  5000 ????	       00 c9	   var37      =	$C9
     91  5000 ????	       00 ca	   var38      =	$CA
     92  5000 ????	       00 cb	   var39      =	$CB
     93  5000 ????	       00 cc	   var40      =	$CC
     94  5000 ????	       00 cd	   var41      =	$CD
     95  5000 ????	       00 ce	   var42      =	$CE
     96  5000 ????	       00 cf	   var43      =	$CF
     97  5000 ????	       00 d0	   var44      =	$D0
     98  5000 ????	       00 d1	   var45      =	$D1
     99  5000 ????	       00 d2	   var46      =	$D2
    100  5000 ????	       00 d3	   var47      =	$D3
    101  5000 ????
    102  5000 ????	       00 d4	   A	      =	$d4
    103  5000 ????	       00 d4	   a	      =	$d4
    104  5000 ????	       00 d5	   B	      =	$d5
    105  5000 ????	       00 d5	   b	      =	$d5
    106  5000 ????	       00 d6	   C	      =	$d6
    107  5000 ????	       00 d6	   c	      =	$d6
    108  5000 ????	       00 d7	   D	      =	$d7
    109  5000 ????	       00 d7	   d	      =	$d7
    110  5000 ????	       00 d8	   E	      =	$d8
    111  5000 ????	       00 d8	   e	      =	$d8
    112  5000 ????	       00 d9	   F	      =	$d9
    113  5000 ????	       00 d9	   f	      =	$d9
    114  5000 ????	       00 da	   G	      =	$da
    115  5000 ????	       00 da	   g	      =	$da
    116  5000 ????	       00 db	   H	      =	$db
    117  5000 ????	       00 db	   h	      =	$db
    118  5000 ????	       00 dc	   I	      =	$dc
    119  5000 ????	       00 dc	   i	      =	$dc
    120  5000 ????	       00 dd	   J	      =	$dd
    121  5000 ????	       00 dd	   j	      =	$dd
    122  5000 ????	       00 de	   K	      =	$de
    123  5000 ????	       00 de	   k	      =	$de
    124  5000 ????	       00 df	   L	      =	$df
    125  5000 ????	       00 df	   l	      =	$df
    126  5000 ????	       00 e0	   M	      =	$e0
    127  5000 ????	       00 e0	   m	      =	$e0
    128  5000 ????	       00 e1	   N	      =	$e1
    129  5000 ????	       00 e1	   n	      =	$e1
    130  5000 ????	       00 e2	   O	      =	$e2
    131  5000 ????	       00 e2	   o	      =	$e2
    132  5000 ????	       00 e3	   P	      =	$e3
    133  5000 ????	       00 e3	   p	      =	$e3
    134  5000 ????	       00 e4	   Q	      =	$e4
    135  5000 ????	       00 e4	   q	      =	$e4
    136  5000 ????	       00 e5	   R	      =	$e5
    137  5000 ????	       00 e5	   r	      =	$e5
    138  5000 ????	       00 e6	   S	      =	$e6
    139  5000 ????	       00 e6	   s	      =	$e6
    140  5000 ????	       00 e7	   T	      =	$e7
    141  5000 ????	       00 e7	   t	      =	$e7
    142  5000 ????	       00 e8	   U	      =	$e8
    143  5000 ????	       00 e8	   u	      =	$e8
    144  5000 ????	       00 e9	   V	      =	$e9
    145  5000 ????	       00 e9	   v	      =	$e9
    146  5000 ????	       00 ea	   W	      =	$ea
    147  5000 ????	       00 ea	   w	      =	$ea
    148  5000 ????	       00 eb	   X	      =	$eb
    149  5000 ????	       00 eb	   x	      =	$eb
    150  5000 ????	       00 ec	   Y	      =	$ec
    151  5000 ????	       00 ec	   y	      =	$ec
    152  5000 ????	       00 ed	   Z	      =	$ed
    153  5000 ????	       00 ed	   z	      =	$ed
    154  5000 ????
    155  5000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  5000 ????	       00 ef	   playfieldpos =	$ef
    157  5000 ????
    158  5000 ????						; available for other uses, or if unused, provide more stack space
    159  5000 ????
    160  5000 ????	       00 f0	   aux1       =	$f0
    161  5000 ????	       00 f1	   aux2       =	$f1
    162  5000 ????	       00 f2	   aux3       =	$f2
    163  5000 ????	       00 f3	   aux4       =	$f3
    164  5000 ????	       00 f4	   aux5       =	$f4
    165  5000 ????	       00 f5	   aux6       =	$f5
    166  5000 ????
    167  5000 ????						; playfield color/height pointers
    168  5000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  5000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  5000 ????						; the above pointers are the same because if color and height are both used together,
    171  5000 ????						; they must used absolute indexed and cannot use pointers
    172  5000 ????
    173  5000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  5000 ????						; upper 3 bits of $f2 contain the number of lives
    175  5000 ????	       00 f4	   lifecolor  =	$f4
    176  5000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  5000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  5000 ????
    179  5000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  5000 ????	       00 f3	   pfscore2   =	$f3
    181  5000 ????	       00 f4	   pfscorecolor =	$f4
    182  5000 ????
    183  5000 ????	       00 f6	   stack1     =	$f6
    184  5000 ????	       00 f7	   stack2     =	$f7
    185  5000 ????	       00 f8	   stack3     =	$f8
    186  5000 ????	       00 f9	   stack4     =	$f9
    187  5000 ????						; the stack bytes above may be used in the kernel
    188  5000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  5000 ????
    190  5000 ????				      MAC	return
    191  5000 ????				      ifnconst	bankswitch
    192  5000 ????				      rts
    193  5000 ????				      else
    194  5000 ????				      jmp	BS_return
    195  5000 ????				      endif
    196  5000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  5000 ????
    198  5000 ????			  -	      ifconst	superchip
    199  5000 ????			  -playfieldbase =	$10D0
    200  5000 ????			  -	      include	superchip.h
    201  5000 ????				      else
    202  5000 ????	       00 a4	   playfieldbase =	$A4
    203  5000 ????				      endif
    204  5000 ????
    205  5000 ????				      ifnconst	pfhalfwidth
    206  5000 ????	       00 04	   pfwidth    =	4
    207  5000 ????	       00 0e	   PF1L       =	PF1
    208  5000 ????	       00 0f	   PF2L       =	PF2
    209  5000 ????	       00 0e	   PF1R       =	PF1
    210  5000 ????	       00 0f	   PF2R       =	PF2
    211  5000 ????	       00 00	   pfadjust   =	0
    212  5000 ????			  -	      else
    213  5000 ????			  -pfwidth    =	2
    214  5000 ????			  -	      ifconst	pfcenter
    215  5000 ????			  -PF1L       =	$3F	; no effect
    216  5000 ????			  -PF2L       =	PF2
    217  5000 ????			  -PF1R       =	$3F
    218  5000 ????			  -PF2R       =	PF2	; no effect
    219  5000 ????			  -pfadjust   =	1
    220  5000 ????			  -	      else
    221  5000 ????			  -PF1L       =	PF1
    222  5000 ????			  -PF2L       =	PF2
    223  5000 ????			  -PF1R       =	$3F	; no effect
    224  5000 ????			  -PF2R       =	$3F	; no effect
    225  5000 ????			  -pfadjust   =	0
    226  5000 ????			  -	      endif
    227  5000 ????				      endif
    228  5000 ????
    229  5000 ????						; define playfield start based on height
    230  5000 ????				      ifnconst	pfres
    231  5000 ????	       00 a4	   playfield  =	playfieldbase
    232  5000 ????			  -	      else
    233  5000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  5000 ????				      endif
------- FILE beer_mania_PAL.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 01	   pfscore    =	1
      5  5000 ????
      6  5000 ????	       00 eb	   _Ch0_Duration4 =	x
      7  5000 ????
      8  5000 ????	       00 ea	   _Ch0_Duration3 =	w
      9  5000 ????
     10  5000 ????	       00 e9	   _Ch0_Duration2 =	v
     11  5000 ????
     12  5000 ????	       00 e4	   _Ch0_Duration1 =	q
     13  5000 ????
     14  5000 ????	       00 e0	   _Ch0_Sound =	m
     15  5000 ????
     16  5000 ????	       00 e1	   rand16     =	n
     17  5000 ????
     18  5000 ????	       00 d6	   bmp_player0_index =	c
     19  5000 ????
     20  5000 ????	       00 d7	   missed     =	d
     21  5000 ????
     22  5000 ????	       00 4b	   logo_height =	75
     23  5000 ????
     24  5000 ????	       00 4c	   logo_color =	$4C
     25  5000 ????
     26  5000 ????	       00 d5	   addvalue   =	b
     27  5000 ????
     28  5000 ????	       00 d4	   frame      =	a
     29  5000 ????
     30  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     31  5000 ????
     32  5000 ????	       00 3a	   vblank_time =	58
     33  5000 ????	       00 52	   overscan_time =	82
     34  5000 ????	       00 01	   PFcolors   =	1
     35  5000 ????	       00 01	   no_blank_lines =	1
     36  5000 ????	       00 01	   player1colors =	1
     37  5000 ????	       00 03	   bs_mask    =	3
     38  5000 ????	       00 10	   bankswitch =	16
     39  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
------- FILE beer_mania_PAL.bas.asm
      8  5000 ????				      ifconst	bankswitch
      9  5000 ????			  -	      if	bankswitch == 8
     10  5000 ????			  -	      ORG	$1000
     11  5000 ????			  -	      RORG	$D000
     12  5000 ????				      endif
     13  5000 ????				      if	bankswitch == 16
     14  1000					      ORG	$1000
     15  1000					      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .L00 		;  set romsize 16k
     36  1000
     37  1000				   .L01 		;  set kernel_options player1colors pfcolors no_blank_lines
     38  1000
     39  1000				   .L02 		;  set optimization speed
     40  1000
     41  1000				   .L03 		;  set smartbranching on
     42  1000
     43  1000				   .L04 		;  set optimization noinlinedata
     44  1000
     45  1000				   .L05 		;  set optimization inlinerand
     46  1000
     47  1000				   .
     48  1000							;
     49  1000
     50  1000				   .
     51  1000							;
     52  1000
     53  1000				   .L06 		;  set tv pal
     54  1000
     55  1000				   .
     56  1000							;
     57  1000
     58  1000				   .
     59  1000							;
     60  1000
     61  1000				   .L07 		;  pfclear
     62  1000
     63  1000		       a9 00		      LDA	#0
     64  1002		       85 ee		      sta	temp7
     65  1004		       a9 90		      lda	#>(ret_point1-1)
     66  1006		       48		      pha
     67  1007		       a9 19		      lda	#<(ret_point1-1)
     68  1009		       48		      pha
     69  100a		       a9 f2		      lda	#>(pfclear-1)
     70  100c		       48		      pha
     71  100d		       a9 8f		      lda	#<(pfclear-1)
     72  100f		       48		      pha
     73  1010		       a5 ee		      lda	temp7
     74  1012		       48		      pha
     75  1013		       8a		      txa
     76  1014		       48		      pha
     77  1015		       a2 04		      ldx	#4
     78  1017		       4c eb ff 	      jmp	BS_jsr
     79  101a				   ret_point1
     80  101a				   .
     81  101a							;
     82  101a
     83  101a				   .
     84  101a							;
     85  101a
     86  101a				   .L08 		;  AUDV0  =  0  :  AUDV1  =  0
     87  101a
     88  101a		       a9 00		      LDA	#0
     89  101c		       85 19		      STA	AUDV0
     90  101e		       85 1a		      STA	AUDV1
     91  1020				   .
     92  1020							;
     93  1020
     94  1020				   .
     95  1020							;
     96  1020
     97  1020				   .L09 		;  dim _Bit0_Reset_Restrainer	=  y
     98  1020
     99  1020				   .
    100  1020							;
    101  1020
    102  1020				   .
    103  1020							;
    104  1020
    105  1020				   .L010		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    106  1020
    107  1020		       a9 00		      LDA	#0
    108  1022		       85 d4		      STA	a
    109  1024		       85 d5		      STA	b
    110  1026		       85 d6		      STA	c
    111  1028		       85 d7		      STA	d
    112  102a		       85 d8		      STA	e
    113  102c		       85 d9		      STA	f
    114  102e		       85 da		      STA	g
    115  1030		       85 db		      STA	h
    116  1032		       85 dc		      STA	i
    117  1034				   .L011		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    118  1034
    119  1034		       a9 00		      LDA	#0
    120  1036		       85 dd		      STA	j
    121  1038		       85 de		      STA	k
    122  103a		       85 df		      STA	l
    123  103c		       85 e0		      STA	m
    124  103e		       85 e1		      STA	n
    125  1040		       85 e2		      STA	o
    126  1042		       85 e3		      STA	p
    127  1044		       85 e4		      STA	q
    128  1046		       85 e5		      STA	r
    129  1048				   .L012		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0  :	z  =  0
    130  1048
    131  1048		       a9 00		      LDA	#0
    132  104a		       85 e6		      STA	s
    133  104c		       85 e7		      STA	t
    134  104e		       85 e8		      STA	u
    135  1050		       85 e9		      STA	v
    136  1052		       85 ea		      STA	w
    137  1054		       85 eb		      STA	x
    138  1056		       85 ec		      STA	y
    139  1058		       85 ed		      STA	z
    140  105a				   .L013		;  var0  =  0	:  var1  =  0  :  var2	=  0  :  var3  =  0  :	var4  =  0
    141  105a
    142  105a		       a9 00		      LDA	#0
    143  105c		       85 a4		      STA	var0
    144  105e		       85 a5		      STA	var1
    145  1060		       85 a6		      STA	var2
    146  1062		       85 a7		      STA	var3
    147  1064		       85 a8		      STA	var4
    148  1066				   .L014		;  var5  =  0	:  var6  =  0  :  var7	=  0  :  var8  =  0
    149  1066
    150  1066		       a9 00		      LDA	#0
    151  1068		       85 a9		      STA	var5
    152  106a		       85 aa		      STA	var6
    153  106c		       85 ab		      STA	var7
    154  106e		       85 ac		      STA	var8
    155  1070				   .
    156  1070							;
    157  1070
    158  1070				   .L015		;  dim frame = a
    159  1070
    160  1070				   .L016		;  dim addvalue = b
    161  1070
    162  1070				   .L017		;  const logo_color = $4C
    163  1070
    164  1070				   .L018		;  const logo_height = 75
    165  1070
    166  1070				   .L019		;  dim missed = d
    167  1070
    168  1070				   .L020		;  rem ** we define this because player 0 has multiple frames...
    169  1070
    170  1070				   .L021		;  dim bmp_player0_index = c
    171  1070
    172  1070				   .L022		;  dim rand16 = n
    173  1070
    174  1070				   .
    175  1070							;
    176  1070
    177  1070				   .L023		;  dim _Ch0_Sound  =  m
    178  1070
    179  1070				   .L024		;  dim _Ch0_Duration1	=  q
    180  1070
    181  1070				   .L025		;  dim _Ch0_Duration2	=  v
    182  1070
    183  1070				   .L026		;  dim _Ch0_Duration3	=  w
    184  1070
    185  1070				   .L027		;  dim _Ch0_Duration4	=  x
    186  1070
    187  1070				   .
    188  1070							;
    189  1070
    190  1070				   .L028		;  const pfscore  =  1
    191  1070
    192  1070				   .L029		;  COLUP0 = $5C
    193  1070
    194  1070		       a9 5c		      LDA	#$5C
    195  1072		       85 06		      STA	COLUP0
    196  1074				   .L030		;  pfscore1 = %10101010
    197  1074
    198  1074		       a9 aa		      LDA	#%10101010
    199  1076		       85 f2		      STA	pfscore1
    200  1078				   .L031		;  scorecolor = $5C
    201  1078
    202  1078		       a9 5c		      LDA	#$5C
    203  107a		       85 a3		      STA	scorecolor
    204  107c				   .L032		;  pfscorecolor = $5C
    205  107c
    206  107c		       a9 5c		      LDA	#$5C
    207  107e		       85 f4		      STA	pfscorecolor
    208  1080				   .
    209  1080							;
    210  1080
    211  1080				   .titlepage
    212  1080							; titlepage
    213  1080
    214  1080				   .L033		;  gosub titledrawscreen bank2
    215  1080
    216  1080		       85 ee		      sta	temp7
    217  1082		       a9 90		      lda	#>(ret_point2-1)
    218  1084		       48		      pha
    219  1085		       a9 97		      lda	#<(ret_point2-1)
    220  1087		       48		      pha
    221  1088		       a9 b0		      lda	#>(.titledrawscreen-1)
    222  108a		       48		      pha
    223  108b		       a9 05		      lda	#<(.titledrawscreen-1)
    224  108d		       48		      pha
    225  108e		       a5 ee		      lda	temp7
    226  1090		       48		      pha
    227  1091		       8a		      txa
    228  1092		       48		      pha
    229  1093		       a2 02		      ldx	#2
    230  1095		       4c eb ff 	      jmp	BS_jsr
    231  1098				   ret_point2
    232  1098				   .
    233  1098							;
    234  1098
    235  1098				   .L034		;  if joy0fire  ||  switchreset then player0y = 200 : goto gamestart
    236  1098
    237  1098		       24 0c		      bit	INPT4
    238  109a		       30 03		      BMI	.skipL034
    239  109c				   .condpart0
    240  109c		       4c a6 90 	      jmp	.condpart1
    241  109f				   .skipL034
    242  109f		       a9 01		      lda	#1
    243  10a1		       2c 82 02 	      bit	SWCHB
    244  10a4		       d0 07		      BNE	.skip0OR
    245  10a6				   .condpart1
    246  10a6		       a9 c8		      LDA	#200
    247  10a8		       85 85		      STA	player0y
    248  10aa		       4c b0 90 	      jmp	.gamestart
    249  10ad
    250  10ad				   .skip0OR
    251  10ad				   .L035		;  goto titlepage
    252  10ad
    253  10ad		       4c 80 90 	      jmp	.titlepage
    254  10b0
    255  10b0				   .
    256  10b0							;
    257  10b0
    258  10b0				   .gamestart
    259  10b0							; gamestart
    260  10b0
    261  10b0				   .L036		;  _Ch0_Sound	=  0
    262  10b0
    263  10b0		       a9 00		      LDA	#0
    264  10b2		       85 e0		      STA	_Ch0_Sound
    265  10b4				   .L037		;  pfscore1  =  %10101010
    266  10b4
    267  10b4		       a9 aa		      LDA	#%10101010
    268  10b6		       85 f2		      STA	pfscore1
    269  10b8				   .
    270  10b8							;
    271  10b8
    272  10b8				   .L038		;  player0x  =  50
    273  10b8
    274  10b8		       a9 32		      LDA	#50
    275  10ba		       85 80		      STA	player0x
    276  10bc				   .L039		;  player0y  =  80
    277  10bc
    278  10bc		       a9 50		      LDA	#80
    279  10be		       85 85		      STA	player0y
    280  10c0				   .
    281  10c0							;
    282  10c0
    283  10c0				   .L040		;  player1x  =  20
    284  10c0
    285  10c0		       a9 14		      LDA	#20
    286  10c2		       85 81		      STA	player1x
    287  10c4				   .L041		;  player1y  =  20
    288  10c4
    289  10c4		       a9 14		      LDA	#20
    290  10c6		       85 86		      STA	player1y
    291  10c8				   .
    292  10c8							;
    293  10c8
    294  10c8				   .L042		;  playfield:
    295  10c8
    296  10c8				  -	      ifconst	pfres
    297  10c8				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    298  10c8					      else
    299  10c8		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    300  10ca					      endif
    301  10ca		       4c f9 90 	      jmp	pflabel0
    302  10cd				   PF_data0
    303  10cd		       ff ff		      .byte.b	%11111111, %11111111
    304  10cf					      if	(pfwidth>2)
    305  10cf		       ff ff		      .byte.b	%11111111, %11111111
    306  10d1					      endif
    307  10d1		       ff ff		      .byte.b	%11111111, %11111111
    308  10d3					      if	(pfwidth>2)
    309  10d3		       ff ff		      .byte.b	%11111111, %11111111
    310  10d5					      endif
    311  10d5		       ff ff		      .byte.b	%11111111, %11111111
    312  10d7					      if	(pfwidth>2)
    313  10d7		       ff ff		      .byte.b	%11111111, %11111111
    314  10d9					      endif
    315  10d9		       ff ff		      .byte.b	%11111111, %11111111
    316  10db					      if	(pfwidth>2)
    317  10db		       ff ff		      .byte.b	%11111111, %11111111
    318  10dd					      endif
    319  10dd		       ff ff		      .byte.b	%11111111, %11111111
    320  10df					      if	(pfwidth>2)
    321  10df		       ff ff		      .byte.b	%11111111, %11111111
    322  10e1					      endif
    323  10e1		       ff ff		      .byte.b	%11111111, %11111111
    324  10e3					      if	(pfwidth>2)
    325  10e3		       ff ff		      .byte.b	%11111111, %11111111
    326  10e5					      endif
    327  10e5		       ff ff		      .byte.b	%11111111, %11111111
    328  10e7					      if	(pfwidth>2)
    329  10e7		       ff ff		      .byte.b	%11111111, %11111111
    330  10e9					      endif
    331  10e9		       ff ff		      .byte.b	%11111111, %11111111
    332  10eb					      if	(pfwidth>2)
    333  10eb		       ff ff		      .byte.b	%11111111, %11111111
    334  10ed					      endif
    335  10ed		       ff ff		      .byte.b	%11111111, %11111111
    336  10ef					      if	(pfwidth>2)
    337  10ef		       ff ff		      .byte.b	%11111111, %11111111
    338  10f1					      endif
    339  10f1		       ff ff		      .byte.b	%11111111, %11111111
    340  10f3					      if	(pfwidth>2)
    341  10f3		       ff ff		      .byte.b	%11111111, %11111111
    342  10f5					      endif
    343  10f5		       ff ff		      .byte.b	%11111111, %11111111
    344  10f7					      if	(pfwidth>2)
    345  10f7		       ff ff		      .byte.b	%11111111, %11111111
    346  10f9					      endif
    347  10f9				   pflabel0
    348  10f9		       bd cd 90 	      lda	PF_data0,x
    349  10fc		       95 a4		      sta	playfield,x
    350  10fe		       ca		      dex
    351  10ff		       10 f8		      bpl	pflabel0
    352  1101				   .
    353  1101							;
    354  1101
    355  1101				   .L043		;  pfcolors:
    356  1101
    357  1101		       a9 9a		      lda	# $9A
    358  1103		       85 08		      sta	COLUPF
    359  1105				  -	      ifconst	pfres
    360  1105				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
    361  1105					      else
    362  1105		       a9 f5		      lda	#>(pfcolorlabel13-84)
    363  1107					      endif
    364  1107		       85 f1		      sta	pfcolortable+1
    365  1109				  -	      ifconst	pfres
    366  1109				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
    367  1109					      else
    368  1109		       a9 04		      lda	#<(pfcolorlabel13-84)
    369  110b					      endif
    370  110b		       85 f0		      sta	pfcolortable
    371  110d				   .
    372  110d							;
    373  110d
    374  110d				   .L044		;  player0:
    375  110d
    376  110d		       a2 80		      LDX	#<playerL044_0
    377  110f		       86 8a		      STX	player0pointerlo
    378  1111		       a9 f5		      LDA	#>playerL044_0
    379  1113		       85 8b		      STA	player0pointerhi
    380  1115		       a9 09		      LDA	#9
    381  1117		       85 8e		      STA	player0height
    382  1119				   .
    383  1119							;
    384  1119
    385  1119				   .L045		;  player1:
    386  1119
    387  1119		       a2 8a		      LDX	#<playerL045_1
    388  111b		       86 8c		      STX	player1pointerlo
    389  111d		       a9 f5		      LDA	#>playerL045_1
    390  111f		       85 8d		      STA	player1pointerhi
    391  1121		       a9 07		      LDA	#7
    392  1123		       85 8f		      STA	player1height
    393  1125				   .
    394  1125							;
    395  1125
    396  1125				   .L046		;  player1color:
    397  1125
    398  1125		       a2 92		      LDX	#<playercolorL046_1
    399  1127		       86 87		      STX	player1color
    400  1129		       a9 f5		      LDA	#>playercolorL046_1
    401  112b		       85 88		      STA	player1color+1
    402  112d				   .
    403  112d							;
    404  112d
    405  112d				   .gameloop
    406  112d							; gameloop
    407  112d
    408  112d				   .L047		;  f = f + 1
    409  112d
    410  112d		       e6 d9		      INC	f
    411  112f				   .
    412  112f							;
    413  112f
    414  112f				   .L048		;  if f  =  10 then player0:
    415  112f
    416  112f		       a5 d9		      LDA	f
    417  1131		       c9 0a		      CMP	#10
    418  1133		       d0 0c		      BNE	.skipL048
    419  1135				   .condpart2
    420  1135		       a2 9a		      LDX	#<player2then_0
    421  1137		       86 8a		      STX	player0pointerlo
    422  1139		       a9 f5		      LDA	#>player2then_0
    423  113b		       85 8b		      STA	player0pointerhi
    424  113d		       a9 09		      LDA	#9
    425  113f		       85 8e		      STA	player0height
    426  1141				   .skipL048
    427  1141				   .L049		;  if f  =  10 then player0color:
    428  1141
    429  1141		       a5 d9		      LDA	f
    430  1143		       c9 0a		      CMP	#10
    431  1145		       d0 08		      BNE	.skipL049
    432  1147				   .condpart3
    433  1147		       a2 a4		      LDX	#<playercolor3then_0
    434  1149		       86 90		      STX	player0color
    435  114b		       a9 f5		      LDA	#>playercolor3then_0
    436  114d		       85 91		      STA	player0color+1
    437  114f				   .skipL049
    438  114f				   .L050		;  if f  =  20 then player0:
    439  114f
    440  114f		       a5 d9		      LDA	f
    441  1151		       c9 14		      CMP	#20
    442  1153		       d0 0c		      BNE	.skipL050
    443  1155				   .condpart4
    444  1155		       a2 ae		      LDX	#<player4then_0
    445  1157		       86 8a		      STX	player0pointerlo
    446  1159		       a9 f5		      LDA	#>player4then_0
    447  115b		       85 8b		      STA	player0pointerhi
    448  115d		       a9 09		      LDA	#9
    449  115f		       85 8e		      STA	player0height
    450  1161				   .skipL050
    451  1161				   .L051		;  if f  =  20 then player0color:
    452  1161
    453  1161		       a5 d9		      LDA	f
    454  1163		       c9 14		      CMP	#20
    455  1165		       d0 08		      BNE	.skipL051
    456  1167				   .condpart5
    457  1167		       a2 b8		      LDX	#<playercolor5then_0
    458  1169		       86 90		      STX	player0color
    459  116b		       a9 f5		      LDA	#>playercolor5then_0
    460  116d		       85 91		      STA	player0color+1
    461  116f				   .skipL051
    462  116f				   .
    463  116f							;
    464  116f
    465  116f				   .L052		;  if f  =  30 then player0:
    466  116f
    467  116f		       a5 d9		      LDA	f
    468  1171		       c9 1e		      CMP	#30
    469  1173		       d0 0c		      BNE	.skipL052
    470  1175				   .condpart6
    471  1175		       a2 c2		      LDX	#<player6then_0
    472  1177		       86 8a		      STX	player0pointerlo
    473  1179		       a9 f5		      LDA	#>player6then_0
    474  117b		       85 8b		      STA	player0pointerhi
    475  117d		       a9 09		      LDA	#9
    476  117f		       85 8e		      STA	player0height
    477  1181				   .skipL052
    478  1181				   .
    479  1181							;
    480  1181
    481  1181				   .L053		;  player1y  =  player1y  +  1
    482  1181
    483  1181		       e6 86		      INC	player1y
    484  1183				   .L054		;  if f = 30 then f = 0
    485  1183
    486  1183		       a5 d9		      LDA	f
    487  1185		       c9 1e		      CMP	#30
    488  1187		       d0 04		      BNE	.skipL054
    489  1189				   .condpart7
    490  1189		       a9 00		      LDA	#0
    491  118b		       85 d9		      STA	f
    492  118d				   .skipL054
    493  118d				   .
    494  118d							;
    495  118d
    496  118d				   .L055		;  if joy0right then REFP0  =	0
    497  118d
    498  118d		       2c 80 02 	      bit	SWCHA
    499  1190		       30 04		      BMI	.skipL055
    500  1192				   .condpart8
    501  1192		       a9 00		      LDA	#0
    502  1194		       85 0b		      STA	REFP0
    503  1196				   .skipL055
    504  1196				   .L056		;  if joy0left then REFP0  =  8
    505  1196
    506  1196		       2c 80 02 	      bit	SWCHA
    507  1199		       70 04		      BVS	.skipL056
    508  119b				   .condpart9
    509  119b		       a9 08		      LDA	#8
    510  119d		       85 0b		      STA	REFP0
    511  119f				   .skipL056
    512  119f				   .
    513  119f							;
    514  119f
    515  119f				   .L057		;  drawscreen
    516  119f
    517  119f		       85 ee		      sta	temp7
    518  11a1		       a9 91		      lda	#>(ret_point3-1)
    519  11a3		       48		      pha
    520  11a4		       a9 b6		      lda	#<(ret_point3-1)
    521  11a6		       48		      pha
    522  11a7		       a9 f4		      lda	#>(drawscreen-1)
    523  11a9		       48		      pha
    524  11aa		       a9 3b		      lda	#<(drawscreen-1)
    525  11ac		       48		      pha
    526  11ad		       a5 ee		      lda	temp7
    527  11af		       48		      pha
    528  11b0		       8a		      txa
    529  11b1		       48		      pha
    530  11b2		       a2 04		      ldx	#4
    531  11b4		       4c eb ff 	      jmp	BS_jsr
    532  11b7				   ret_point3
    533  11b7				   .
    534  11b7							;
    535  11b7
    536  11b7				   .L058		;  if joy0right then player0x	=  player0x  +	1
    537  11b7
    538  11b7		       2c 80 02 	      bit	SWCHA
    539  11ba		       30 02		      BMI	.skipL058
    540  11bc				   .condpart10
    541  11bc		       e6 80		      INC	player0x
    542  11be				   .skipL058
    543  11be				   .L059		;  if joy0left then player0x  =  player0x  -  1
    544  11be
    545  11be		       2c 80 02 	      bit	SWCHA
    546  11c1		       70 02		      BVS	.skipL059
    547  11c3				   .condpart11
    548  11c3		       c6 80		      DEC	player0x
    549  11c5				   .skipL059
    550  11c5				   .L060		;  if joy0up then player0y  =	player0y  -  1
    551  11c5
    552  11c5		       a9 10		      lda	#$10
    553  11c7		       2c 80 02 	      bit	SWCHA
    554  11ca		       d0 02		      BNE	.skipL060
    555  11cc				   .condpart12
    556  11cc		       c6 85		      DEC	player0y
    557  11ce				   .skipL060
    558  11ce				   .L061		;  if joy0down then player0y  =  player0y  +  1
    559  11ce
    560  11ce		       a9 20		      lda	#$20
    561  11d0		       2c 80 02 	      bit	SWCHA
    562  11d3		       d0 02		      BNE	.skipL061
    563  11d5				   .condpart13
    564  11d5		       e6 85		      INC	player0y
    565  11d7				   .skipL061
    566  11d7				   .L062		;  if player0y  >=  80 then player0y  =  80
    567  11d7
    568  11d7		       a5 85		      LDA	player0y
    569  11d9		       c9 50		      CMP	#80
    570  11db		       90 04		      BCC	.skipL062
    571  11dd				   .condpart14
    572  11dd		       a9 50		      LDA	#80
    573  11df		       85 85		      STA	player0y
    574  11e1				   .skipL062
    575  11e1				   .L063		;  if player0x  <= 1 then player0x  =	1
    576  11e1
    577  11e1		       a9 01		      LDA	#1
    578  11e3		       c5 80		      CMP	player0x
    579  11e5		       90 04		      BCC	.skipL063
    580  11e7				   .condpart15
    581  11e7		       a9 01		      LDA	#1
    582  11e9		       85 80		      STA	player0x
    583  11eb				   .skipL063
    584  11eb				   .L064		;  if player0x  >=  153 then player0x	=  153
    585  11eb
    586  11eb		       a5 80		      LDA	player0x
    587  11ed		       c9 99		      CMP	#153
    588  11ef		       90 04		      BCC	.skipL064
    589  11f1				   .condpart16
    590  11f1		       a9 99		      LDA	#153
    591  11f3		       85 80		      STA	player0x
    592  11f5				   .skipL064
    593  11f5				   .
    594  11f5							;
    595  11f5
    596  11f5				   .L065		;  if collision(player0,player1) then score  =  score	+  10  :  player1y  =  20  :  player1x	=  rand16 & 127  :  goto play_hit_sound
    597  11f5
    598  11f5		       24 07		      bit	CXPPMM
    599  11f7		       10 2d		      BPL	.skipL065
    600  11f9				   .condpart17
    601  11f9		       f8		      SED
    602  11fa		       18		      CLC
    603  11fb		       a5 95		      LDA	score+2
    604  11fd		       69 10		      ADC	#$10
    605  11ff		       85 95		      STA	score+2
    606  1201		       a5 94		      LDA	score+1
    607  1203		       69 00		      ADC	#$00
    608  1205		       85 94		      STA	score+1
    609  1207		       a5 93		      LDA	score
    610  1209		       69 00		      ADC	#$00
    611  120b		       85 93		      STA	score
    612  120d		       d8		      CLD
    613  120e		       a9 14		      LDA	#20
    614  1210		       85 86		      STA	player1y
    615  1212		       a5 a2		      lda	rand
    616  1214		       4a		      lsr
    617  1215					      ifconst	rand16
    618  1215		       26 e1		      rol	rand16
    619  1217					      endif
    620  1217		       90 02		      bcc	*+4
    621  1219		       49 b4		      eor	#$B4
    622  121b		       85 a2		      sta	rand
    623  121d					      ifconst	rand16
    624  121d		       45 e1		      eor	rand16
    625  121f					      endif
    626  121f		       29 7f		      AND	#127
    627  1221		       85 81		      STA	player1x
    628  1223		       4c 6b 92 	      jmp	.play_hit_sound
    629  1226
    630  1226				   .skipL065
    631  1226				   .L066		;  if player1y  =  80	&&  !collision(player0,player1) then missed  =	missed	+  1  :  player1y  =  20  :  player1x  =  rand16 & 127 :  pfscore1  =  pfscore1 / 4 :  goto play_miss_sound
    632  1226
    633  1226		       a5 86		      LDA	player1y
    634  1228		       c9 50		      CMP	#80
    635  122a		       d0 24		      BNE	.skipL066
    636  122c				   .condpart18
    637  122c		       24 07		      bit	CXPPMM
    638  122e		       30 20		      BMI	.skip18then
    639  1230				   .condpart19
    640  1230		       e6 d7		      INC	missed
    641  1232		       a9 14		      LDA	#20
    642  1234		       85 86		      STA	player1y
    643  1236		       a5 a2		      lda	rand
    644  1238		       4a		      lsr
    645  1239					      ifconst	rand16
    646  1239		       26 e1		      rol	rand16
    647  123b					      endif
    648  123b		       90 02		      bcc	*+4
    649  123d		       49 b4		      eor	#$B4
    650  123f		       85 a2		      sta	rand
    651  1241					      ifconst	rand16
    652  1241		       45 e1		      eor	rand16
    653  1243					      endif
    654  1243		       29 7f		      AND	#127
    655  1245		       85 81		      STA	player1x
    656  1247		       a5 f2		      LDA	pfscore1
    657  1249		       4a		      lsr
    658  124a		       4a		      lsr
    659  124b		       85 f2		      STA	pfscore1
    660  124d		       4c 97 92 	      jmp	.play_miss_sound
    661  1250
    662  1250				   .skip18then
    663  1250				   .skipL066
    664  1250				   .L067		;  if missed  =  4 then goto __Game_Over_Setup bank3
    665  1250
    666  1250		       a5 d7		      LDA	missed
    667  1252		       c9 04		      CMP	#4
    668  1254		       d0 12		      BNE	.skipL067
    669  1256				   .condpart20
    670  1256		       85 ee		      sta	temp7
    671  1258		       a9 cf		      lda	#>(.__Game_Over_Setup-1)
    672  125a		       48		      pha
    673  125b		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
    674  125d		       48		      pha
    675  125e		       a5 ee		      lda	temp7
    676  1260		       48		      pha
    677  1261		       8a		      txa
    678  1262		       48		      pha
    679  1263		       a2 03		      ldx	#3
    680  1265		       4c eb ff 	      jmp	BS_jsr
    681  1268				   .skipL067
    682  1268				   .
    683  1268							;
    684  1268
    685  1268				   .L068		;  goto gameloop
    686  1268
    687  1268		       4c 2d 91 	      jmp	.gameloop
    688  126b
    689  126b				   .
    690  126b							;
    691  126b
    692  126b				   .play_hit_sound
    693  126b							; play_hit_sound
    694  126b
    695  126b				   .L069		;  if !_Ch0_Sound then _Ch0_Sound  =  1  :  _Ch0_Duration1  =	255  :	_Ch0_Duration2	=  255	:  _Ch0_Duration3  =  255  :  _Ch0_Duration4  =  255
    696  126b
    697  126b		       a5 e0		      LDA	_Ch0_Sound
    698  126d		       d0 0e		      BNE	.skipL069
    699  126f				   .condpart21
    700  126f		       a9 01		      LDA	#1
    701  1271		       85 e0		      STA	_Ch0_Sound
    702  1273		       a9 ff		      LDA	#255
    703  1275		       85 e4		      STA	_Ch0_Duration1
    704  1277		       85 e9		      STA	_Ch0_Duration2
    705  1279		       85 ea		      STA	_Ch0_Duration3
    706  127b		       85 eb		      STA	_Ch0_Duration4
    707  127d				   .skipL069
    708  127d				   .L070		;  AUDC0  =  4  :  AUDV0  =  15  :  AUDF0  =  24
    709  127d
    710  127d		       a9 04		      LDA	#4
    711  127f		       85 15		      STA	AUDC0
    712  1281		       a9 0f		      LDA	#15
    713  1283		       85 19		      STA	AUDV0
    714  1285		       a9 18		      LDA	#24
    715  1287		       85 17		      STA	AUDF0
    716  1289				   .L071		;  _Ch0_Duration1  =  _Ch0_Duration1  -  1
    717  1289
    718  1289		       c6 e4		      DEC	_Ch0_Duration1
    719  128b				   .L072		;  if _Ch0_Duration1  =  0 then goto minus_dur2
    720  128b
    721  128b		       a5 e4		      LDA	_Ch0_Duration1
    722  128d		       c9 00		      CMP	#0
    723  128f		       d0 03		      BNE	.skipL072
    724  1291				   .condpart22
    725  1291		       4c c3 92 	      jmp	.minus_dur2
    726  1294
    727  1294				   .skipL072
    728  1294				   .L073		;  goto play_hit_sound
    729  1294
    730  1294		       4c 6b 92 	      jmp	.play_hit_sound
    731  1297
    732  1297				   .
    733  1297							;
    734  1297
    735  1297				   .play_miss_sound
    736  1297							; play_miss_sound
    737  1297
    738  1297				   .L074		;  if !_Ch0_Sound then _Ch0_Sound  =  1  :  _Ch0_Duration1  =	255  :	_Ch0_Duration2	=  255	:  _Ch0_Duration3  =  255 :  _Ch0_Duration4  =	255
    739  1297
    740  1297		       a5 e0		      LDA	_Ch0_Sound
    741  1299		       d0 0e		      BNE	.skipL074
    742  129b				   .condpart23
    743  129b		       a9 01		      LDA	#1
    744  129d		       85 e0		      STA	_Ch0_Sound
    745  129f		       a9 ff		      LDA	#255
    746  12a1		       85 e4		      STA	_Ch0_Duration1
    747  12a3		       85 e9		      STA	_Ch0_Duration2
    748  12a5		       85 ea		      STA	_Ch0_Duration3
    749  12a7		       85 eb		      STA	_Ch0_Duration4
    750  12a9				   .skipL074
    751  12a9				   .L075		;  AUDC0  =  12  :  AUDV0  =  15  :  AUDF0  =	26
    752  12a9
    753  12a9		       a9 0c		      LDA	#12
    754  12ab		       85 15		      STA	AUDC0
    755  12ad		       a9 0f		      LDA	#15
    756  12af		       85 19		      STA	AUDV0
    757  12b1		       a9 1a		      LDA	#26
    758  12b3		       85 17		      STA	AUDF0
    759  12b5				   .L076		;  _Ch0_Duration1  =  _Ch0_Duration1  -  1
    760  12b5
    761  12b5		       c6 e4		      DEC	_Ch0_Duration1
    762  12b7				   .L077		;  if _Ch0_Duration1  =  0 then goto minus_dur2
    763  12b7
    764  12b7		       a5 e4		      LDA	_Ch0_Duration1
    765  12b9		       c9 00		      CMP	#0
    766  12bb		       d0 03		      BNE	.skipL077
    767  12bd				   .condpart24
    768  12bd		       4c c3 92 	      jmp	.minus_dur2
    769  12c0
    770  12c0				   .skipL077
    771  12c0				   .L078		;  goto play_miss_sound
    772  12c0
    773  12c0		       4c 97 92 	      jmp	.play_miss_sound
    774  12c3
    775  12c3				   .
    776  12c3							;
    777  12c3
    778  12c3				   .minus_dur2
    779  12c3							; minus_dur2
    780  12c3
    781  12c3				   .L079		;  _Ch0_Duration2  =  _Ch0_Duration2  -  1
    782  12c3
    783  12c3		       c6 e9		      DEC	_Ch0_Duration2
    784  12c5				   .L080		;  if _Ch0_Duration2  =  0 then goto minus_dur3
    785  12c5
    786  12c5		       a5 e9		      LDA	_Ch0_Duration2
    787  12c7		       c9 00		      CMP	#0
    788  12c9		       d0 03		      BNE	.skipL080
    789  12cb				   .condpart25
    790  12cb		       4c d1 92 	      jmp	.minus_dur3
    791  12ce
    792  12ce				   .skipL080
    793  12ce				   .L081		;  goto minus_dur2
    794  12ce
    795  12ce		       4c c3 92 	      jmp	.minus_dur2
    796  12d1
    797  12d1				   .
    798  12d1							;
    799  12d1
    800  12d1				   .minus_dur3
    801  12d1							; minus_dur3
    802  12d1
    803  12d1				   .L082		;  _Ch0_Duration3  =  _Ch0_Duration3  -  1
    804  12d1
    805  12d1		       c6 ea		      DEC	_Ch0_Duration3
    806  12d3				   .L083		;  if _Ch0_Duration3  =  0 then goto minus_dur4
    807  12d3
    808  12d3		       a5 ea		      LDA	_Ch0_Duration3
    809  12d5		       c9 00		      CMP	#0
    810  12d7		       d0 03		      BNE	.skipL083
    811  12d9				   .condpart26
    812  12d9		       4c df 92 	      jmp	.minus_dur4
    813  12dc
    814  12dc				   .skipL083
    815  12dc				   .L084		;  goto minus_dur3
    816  12dc
    817  12dc		       4c d1 92 	      jmp	.minus_dur3
    818  12df
    819  12df				   .
    820  12df							;
    821  12df
    822  12df				   .minus_dur4
    823  12df							; minus_dur4
    824  12df
    825  12df				   .L085		;  _Ch0_Duration4  =  _Ch0_Duration4  -  1
    826  12df
    827  12df		       c6 eb		      DEC	_Ch0_Duration4
    828  12e1				   .L086		;  if _Ch0_Duration4  =  0 then goto __Clear_Ch_0
    829  12e1
    830  12e1		       a5 eb		      LDA	_Ch0_Duration4
    831  12e3		       c9 00		      CMP	#0
    832  12e5		       d0 03		      BNE	.skipL086
    833  12e7				   .condpart27
    834  12e7		       4c ed 92 	      jmp	.__Clear_Ch_0
    835  12ea
    836  12ea				   .skipL086
    837  12ea				   .L087		;  goto minus_dur4
    838  12ea
    839  12ea		       4c df 92 	      jmp	.minus_dur4
    840  12ed
    841  12ed				   .
    842  12ed							;
    843  12ed
    844  12ed				   .__Clear_Ch_0
    845  12ed							; __Clear_Ch_0
    846  12ed
    847  12ed				   .L088		;  _Ch0_Sound	=  0  :  AUDV0	=  0
    848  12ed
    849  12ed		       a9 00		      LDA	#0
    850  12ef		       85 e0		      STA	_Ch0_Sound
    851  12f1		       85 19		      STA	AUDV0
    852  12f3				   .L089		;  goto gameloop
    853  12f3
    854  12f3		       4c 2d 91 	      jmp	.gameloop
    855  12f6
    856  12f6				   .
    857  12f6							;
    858  12f6
    859  12f6				   .L090		;  bank 2
    860  12f6
    861  12f6					      if	ECHO1
      3294 bytes of ROM space left in bank 1
    862  12f6					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
    863  12f6					      endif
    864  12f6		       00 01	   ECHO1      =	1
    865  1fd4					      ORG	$1FF4-bscode_length
    866  1fd4					      RORG	$9FF4-bscode_length
    867  1fd4		       a2 ff	   start_bank1 ldx	#$ff
    868  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
    869  1fd6				  -	      stx	FASTFETCH
    870  1fd6					      endif
    871  1fd6		       9a		      txs
    872  1fd7				  -	      if	bankswitch == 64
    873  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
    874  1fd7					      else
    875  1fd7		       a9 f2		      lda	#>(start-1)
    876  1fd9					      endif
    877  1fd9		       48		      pha
    878  1fda		       a9 51		      lda	#<(start-1)
    879  1fdc		       48		      pha
    880  1fdd		       48		      pha
    881  1fde		       8a		      txa
    882  1fdf		       48		      pha
    883  1fe0		       ba		      tsx
    884  1fe1					      if	bankswitch != 64
    885  1fe1		       b5 04		      lda	4,x	; get high byte of return address
    886  1fe3		       2a		      rol
    887  1fe4		       2a		      rol
    888  1fe5		       2a		      rol
    889  1fe6		       2a		      rol
    890  1fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
    891  1fe9		       aa		      tax
    892  1fea		       e8		      inx
    893  1feb				  -	      else
    894  1feb				  -	      lda	4,x	; get high byte of return address
    895  1feb				  -	      tay
    896  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
    897  1feb				  -	      sta	4,x
    898  1feb				  -	      tya
    899  1feb				  -	      lsr
    900  1feb				  -	      lsr
    901  1feb				  -	      lsr
    902  1feb				  -	      lsr
    903  1feb				  -	      tax
    904  1feb				  -	      inx
    905  1feb					      endif
    906  1feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
    907  1fee		       68		      pla
    908  1fef		       aa		      tax
    909  1ff0		       68		      pla
    910  1ff1		       60		      rts
    911  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
    912  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
    913  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
    914  1ff2					      endif
    915  1ffc					      ORG	$1FFC
    916  1ffc					      RORG	$9FFC
    917  1ffc		       d4 9f		      .word.w	(start_bank1 & $ffff)
    918  1ffe		       d4 9f		      .word.w	(start_bank1 & $ffff)
    919  2000					      ORG	$2000
    920  2000					      RORG	$B000
    921  2000				   .L091		;  _Bit0_Reset_Restrainer{0}  =  1
    922  2000
    923  2000		       a5 ec		      LDA	_Bit0_Reset_Restrainer
    924  2002		       09 01		      ORA	#1
    925  2004		       85 ec		      STA	_Bit0_Reset_Restrainer
    926  2006				   .L092		;  asm
    927  2006
------- FILE titlescreen/asm/titlescreen_pal.asm LEVEL 2 PASS 2
      0  2006					      include	"titlescreen/asm/titlescreen_pal.asm"
      1  2006
------- FILE titlescreen/asm/layoutmacros.asm LEVEL 3 PASS 2
      0  2006					      include	"titlescreen/asm/layoutmacros.asm"
      1  2006
      2  2006							; the macro's used in the "titlescreen_layout.asm" file
      3  2006
      4  2006					      MAC	draw_96x2_1
      5  2006				   mk_96x2_1_on =	1
      6  2006					      jsr	draw_bmp_96x2_1
      7  2006					      ENDM
      8  2006
      9  2006					      MAC	draw_space
     10  2006					      ldy	#{1}
     11  2006				   .loop
     12  2006					      sta	WSYNC
     13  2006					      dey
     14  2006					      bne	.loop
     15  2006					      ENDM
     16  2006
------- FILE titlescreen/asm/titlescreen_pal.asm
      3  2006					      include	"titlescreen/asm/dpcfix.asm"
------- FILE titlescreen/titlescreen_layout.asm LEVEL 3 PASS 2
      0  2006					      include	"titlescreen/titlescreen_layout.asm"
      1  2006					      MAC	titlescreenlayout
      2  2006					      draw_96x2_1
      3  2006					      ENDM
      4  2006
------- FILE titlescreen/asm/titlescreen_pal.asm
      5  2006
      6  2006				   .titledrawscreen
      7  2006				   title_eat_overscan
      8  2006							;bB runs in overscan. Wait for the overscan to run out...
      9  2006		       18		      clc
     10  2007		       ad 84 02 	      lda	INTIM
     11  200a		       30 fa		      bmi	title_eat_overscan
     12  200c		       4c 0f b0 	      jmp	title_do_vertical_sync
     13  200f
     14  200f				   title_do_vertical_sync
     15  200f		       a9 02		      lda	#2
     16  2011		       85 02		      sta	WSYNC	;one line with VSYNC
     17  2013		       85 00		      sta	VSYNC	;enable VSYNC
     18  2015		       85 02		      sta	WSYNC	;one line with VSYNC
     19  2017		       85 02		      sta	WSYNC	;one line with VSYNC
     20  2019		       a9 00		      lda	#0
     21  201b		       85 02		      sta	WSYNC	;one line with VSYNC
     22  201d		       85 00		      sta	VSYNC	;turn off VSYNC
     23  201f
     24  201f							;lda #42+128
     25  201f				  -	      ifnconst	vblank_time
     26  201f				  -	      lda	#42+128
     27  201f					      else
     28  201f		       a9 ba		      lda	#vblank_time+128
     29  2021					      endif
     30  2021
     31  2021		       8d 96 02 	      sta	TIM64T
     32  2024
     33  2024		       00 82	   titleframe =	missile0x
     34  2024		       e6 82		      inc	titleframe	; increment the frame counter
     35  2026
     36  2026				  -	      ifconst	.title_vblank
     37  2026				  -	      jsr	.title_vblank
     38  2026					      endif
     39  2026
     40  2026				   title_vblank_loop
     41  2026		       ad 84 02 	      lda	INTIM
     42  2029		       30 fb		      bmi	title_vblank_loop
     43  202b		       a9 00		      lda	#0
     44  202d		       85 02		      sta	WSYNC
     45  202f		       85 01		      sta	VBLANK
     46  2031		       85 1d		      sta	ENAM0
     47  2033		       85 1f		      sta	ENABL
     48  2035
     49  2035				   title_playfield
     50  2035
     51  2035							; ======== BEGIN of the custom kernel!!!!! All of the work is done in the playfield.
     52  2035
     53  2035		       a9 e6		      lda	#230
     54  2037		       8d 96 02 	      sta	TIM64T
     55  203a
     56  203a		       a9 01		      lda	#1
     57  203c		       85 0a		      sta	CTRLPF
     58  203e		       18		      clc
     59  203f
     60  203f		       a9 00		      lda	#0
     61  2041		       85 0b		      sta	REFP0
     62  2043		       85 0c		      sta	REFP1
     63  2045		       85 02		      sta	WSYNC
     64  2047		       ad 52 b0 	      lda	titlescreencolor
     65  204a		       85 09		      sta	COLUBK
     66  204c
      0  204c					      titlescreenlayout
      0  204c					      draw_96x2_1
      1  204c		       00 01	   mk_96x2_1_on =	1
      2  204c		       20 53 b0 	      jsr	draw_bmp_96x2_1
     68  204f
     69  204f		       4c 71 b2 	      jmp	PFWAIT	; kernel is done. Finish off the screen
     70  2052
------- FILE titlescreen/titlescreen_color.asm LEVEL 3 PASS 2
      0  2052					      include	"titlescreen/titlescreen_color.asm"
      1  2052
      2  2052							; This is where the titlescreen background color gets set. 
      3  2052							; You can also do a "dim titlescreencolor=[letter]" in bB
      4  2052							; if you want to change the color on the fly.
      5  2052
      6  2052				  -	      ifnconst	titlescreencolor
      7  2052				  -titlescreencolor
      8  2052					      endif
      9  2052		       00		      .byte.b	$00
     10  2053
------- FILE titlescreen/asm/titlescreen_pal.asm
     72  2053
     73  2053					      ifconst	mk_96x2_1_on
------- FILE titlescreen/asm/96x2_1_kernel.asm LEVEL 3 PASS 2
      0  2053					      include	"titlescreen/asm/96x2_1_kernel.asm"
      1  2053				   draw_bmp_96x2_1
      2  2053
      3  2053				  -	      ifconst	bmp_96x2_1_index
      4  2053				  -	      lda	#(bmp_96x2_1_height-1)
      5  2053				  -	      sec
      6  2053				  -	      sbc	bmp_96x2_1_index
      7  2053				  -	      tay
      8  2053				  -	      sbc	#bmp_96x2_1_window
      9  2053				  -	      sta	temp1
     10  2053					      else
     11  2053		       a0 54		      ldy	#(bmp_96x2_1_window-1)
     12  2055		       a9 ff		      lda	#255
     13  2057		       85 9c		      sta	temp1
     14  2059					      endif
     15  2059
     16  2059		       a9 03		      lda	#3
     17  205b		       85 04		      sta	NUSIZ0	;3=Player and Missile are drawn twice 32 clocks apart
     18  205d		       85 05		      sta	NUSIZ1	;3=Player and Missile are drawn twice 32 clocks apart
     19  205f		       a9 00		      lda	#0
     20  2061
     21  2061		       b9 87 b2 	      lda	bmp_96x2_1_colors,y	;4
     22  2064				  -	      ifconst	bmp_96x2_1_fade
     23  2064				  -	      and	bmp_96x2_1_fade
     24  2064					      endif
     25  2064		       85 06		      sta	COLUP0	;3
     26  2066		       85 07		      sta	COLUP1	;3
     27  2068		       85 2b		      sta	HMCLR	;3
     28  206a
     29  206a		       a5 82		      lda	titleframe
     30  206c		       29 01		      and	#1
     31  206e		       f0 03		      beq	jmp_pf96x2_1_frame0
     32  2070		       4c 70 b1 	      jmp	pf96x2_1_frame1
     33  2073				   jmp_pf96x2_1_frame0
     34  2073		       4c 76 b0 	      jmp	pf96x2_1_frame0
     35  2076
     36  2076				   pf96x2_1_frame0
     37  2076							;postion P0 and P1
     38  2076		       85 02		      sta	WSYNC
     39  2078		       a9 e0		      lda	#%11100000
     40  207a		       85 20		      sta	HMP0
     41  207c		       a9 10		      lda	#%00010000
     42  207e		       85 21		      sta	HMP1
     43  2080		       85 02		      sta	WSYNC
      0  2082					      sleep	28
      1  2082				   .CYCLES    SET	28
      2  2082
      3  2082				  -	      IF	.CYCLES < 2
      4  2082				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2082				  -	      ERR
      6  2082					      ENDIF
      7  2082
      8  2082				  -	      IF	.CYCLES & 1
      9  2082				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2082				  -	      nop	0
     11  2082				  -	      ELSE
     12  2082				  -	      bit	VSYNC
     13  2082				  -	      ENDIF
     14  2082				  -.CYCLES    SET	.CYCLES - 3
     15  2082					      ENDIF
     16  2082
     17  2082					      REPEAT	.CYCLES / 2
     18  2082		       ea		      nop
     17  2082					      REPEND
     18  2083		       ea		      nop
     17  2083					      REPEND
     18  2084		       ea		      nop
     17  2084					      REPEND
     18  2085		       ea		      nop
     17  2085					      REPEND
     18  2086		       ea		      nop
     17  2086					      REPEND
     18  2087		       ea		      nop
     17  2087					      REPEND
     18  2088		       ea		      nop
     17  2088					      REPEND
     18  2089		       ea		      nop
     17  2089					      REPEND
     18  208a		       ea		      nop
     17  208a					      REPEND
     18  208b		       ea		      nop
     17  208b					      REPEND
     18  208c		       ea		      nop
     17  208c					      REPEND
     18  208d		       ea		      nop
     17  208d					      REPEND
     18  208e		       ea		      nop
     17  208e					      REPEND
     18  208f		       ea		      nop
     19  2090					      REPEND
     45  2090		       85 10		      sta	RESP0
      0  2092					      sleep	14
      1  2092				   .CYCLES    SET	14
      2  2092
      3  2092				  -	      IF	.CYCLES < 2
      4  2092				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2092				  -	      ERR
      6  2092					      ENDIF
      7  2092
      8  2092				  -	      IF	.CYCLES & 1
      9  2092				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2092				  -	      nop	0
     11  2092				  -	      ELSE
     12  2092				  -	      bit	VSYNC
     13  2092				  -	      ENDIF
     14  2092				  -.CYCLES    SET	.CYCLES - 3
     15  2092					      ENDIF
     16  2092
     17  2092					      REPEAT	.CYCLES / 2
     18  2092		       ea		      nop
     17  2092					      REPEND
     18  2093		       ea		      nop
     17  2093					      REPEND
     18  2094		       ea		      nop
     17  2094					      REPEND
     18  2095		       ea		      nop
     17  2095					      REPEND
     18  2096		       ea		      nop
     17  2096					      REPEND
     18  2097		       ea		      nop
     17  2097					      REPEND
     18  2098		       ea		      nop
     19  2099					      REPEND
     47  2099		       85 11		      sta	RESP1
     48  209b		       85 02		      sta	WSYNC
     49  209d		       85 2a		      sta	HMOVE
     50  209f
     51  209f		       85 02		      sta	WSYNC
     52  20a1		       85 2b		      sta	HMCLR
     53  20a3		       85 02		      sta	WSYNC
     54  20a5
      0  20a5					      sleep	4
      1  20a5				   .CYCLES    SET	4
      2  20a5
      3  20a5				  -	      IF	.CYCLES < 2
      4  20a5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20a5				  -	      ERR
      6  20a5					      ENDIF
      7  20a5
      8  20a5				  -	      IF	.CYCLES & 1
      9  20a5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20a5				  -	      nop	0
     11  20a5				  -	      ELSE
     12  20a5				  -	      bit	VSYNC
     13  20a5				  -	      ENDIF
     14  20a5				  -.CYCLES    SET	.CYCLES - 3
     15  20a5					      ENDIF
     16  20a5
     17  20a5					      REPEAT	.CYCLES / 2
     18  20a5		       ea		      nop
     17  20a5					      REPEND
     18  20a6		       ea		      nop
     19  20a7					      REPEND
     56  20a7		       4c 00 b1 	      jmp	pfline_96x2_1_frame0
     57  20aa							;align so our branch doesn't unexpectedly cross a page...
     58  20aa					      if	>. != >[.+$70]
     59  2100		       00 00 00 00*	      align	256
     60  2100					      endif
     61  2100
     62  2100				   pfline_96x2_1_frame0
     63  2100		       a9 80		      lda	#$80	;2
     64  2102		       85 20		      sta	HMP0	;3
     65  2104		       85 21		      sta	HMP1	;3
     66  2106
     67  2106		       b9 00 b5 	      lda	bmp_96x2_1_06,y	;4
     68  2109		       85 1c		      sta	GRP1	;3
     69  210b
     70  210b		       b9 00 b3 	      lda	bmp_96x2_1_00,y
     71  210e		       85 1b		      sta	GRP0
     72  2110		       b9 aa b3 	      lda	bmp_96x2_1_02,y
     73  2113		       85 1b		      sta	GRP0
     74  2115		       b9 55 b4 	      lda	bmp_96x2_1_04,y
     75  2118		       85 1b		      sta	GRP0
     76  211a
      0  211a					      sleep	2
      1  211a				   .CYCLES    SET	2
      2  211a
      3  211a				  -	      IF	.CYCLES < 2
      4  211a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  211a				  -	      ERR
      6  211a					      ENDIF
      7  211a
      8  211a				  -	      IF	.CYCLES & 1
      9  211a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  211a				  -	      nop	0
     11  211a				  -	      ELSE
     12  211a				  -	      bit	VSYNC
     13  211a				  -	      ENDIF
     14  211a				  -.CYCLES    SET	.CYCLES - 3
     15  211a					      ENDIF
     16  211a
     17  211a					      REPEAT	.CYCLES / 2
     18  211a		       ea		      nop
     19  211b					      REPEND
     78  211b
     79  211b		       b9 aa b5 	      lda	bmp_96x2_1_08,y
     80  211e		       85 1c		      sta	GRP1
     81  2120		       b9 55 b6 	      lda	bmp_96x2_1_10,y
     82  2123		       85 1c		      sta	GRP1
     83  2125
     84  2125		       b9 55 b3 	      lda	bmp_96x2_1_01,y
     85  2128		       85 1b		      sta	GRP0
     86  212a
      0  212a					      sleep	8
      1  212a				   .CYCLES    SET	8
      2  212a
      3  212a				  -	      IF	.CYCLES < 2
      4  212a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  212a				  -	      ERR
      6  212a					      ENDIF
      7  212a
      8  212a				  -	      IF	.CYCLES & 1
      9  212a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  212a				  -	      nop	0
     11  212a				  -	      ELSE
     12  212a				  -	      bit	VSYNC
     13  212a				  -	      ENDIF
     14  212a				  -.CYCLES    SET	.CYCLES - 3
     15  212a					      ENDIF
     16  212a
     17  212a					      REPEAT	.CYCLES / 2
     18  212a		       ea		      nop
     17  212a					      REPEND
     18  212b		       ea		      nop
     17  212b					      REPEND
     18  212c		       ea		      nop
     17  212c					      REPEND
     18  212d		       ea		      nop
     19  212e					      REPEND
     88  212e
     89  212e							;sta WSYNC	;=0
     90  212e		       85 2a		      sta	HMOVE	;3 - NORMAL HMOVE
     91  2130
     92  2130		       b9 86 b2 	      lda	bmp_96x2_1_colors-1,y	;4 - get the title color early and store it for later
     93  2133				  -	      ifconst	bmp_96x2_1_fade
     94  2133				  -	      and	bmp_96x2_1_fade
     95  2133					      else
      0  2133					      sleep	3
      1  2133				   .CYCLES    SET	3
      2  2133
      3  2133				  -	      IF	.CYCLES < 2
      4  2133				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2133				  -	      ERR
      6  2133					      ENDIF
      7  2133
      8  2133					      IF	.CYCLES & 1
      9  2133					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2133		       04 00		      nop	0
     11  2135				  -	      ELSE
     12  2135				  -	      bit	VSYNC
     13  2135					      ENDIF
     14  2135				   .CYCLES    SET	.CYCLES - 3
     15  2135					      ENDIF
     16  2135
     17  2135				  -	      REPEAT	.CYCLES / 2
     18  2135				  -	      nop
     19  2135					      REPEND
     97  2135					      endif
     98  2135		       aa		      tax
     99  2136
    100  2136		       a9 00		      lda	#0	;2
    101  2138		       85 20		      sta	HMP0	;3
    102  213a		       85 21		      sta	HMP1	;3
    103  213c
      0  213c					      sleep	7
      1  213c				   .CYCLES    SET	7
      2  213c
      3  213c				  -	      IF	.CYCLES < 2
      4  213c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  213c				  -	      ERR
      6  213c					      ENDIF
      7  213c
      8  213c					      IF	.CYCLES & 1
      9  213c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  213c		       04 00		      nop	0
     11  213e				  -	      ELSE
     12  213e				  -	      bit	VSYNC
     13  213e					      ENDIF
     14  213e				   .CYCLES    SET	.CYCLES - 3
     15  213e					      ENDIF
     16  213e
     17  213e					      REPEAT	.CYCLES / 2
     18  213e		       ea		      nop
     17  213e					      REPEND
     18  213f		       ea		      nop
     19  2140					      REPEND
    105  2140
    106  2140		       b9 55 b5 	      lda	bmp_96x2_1_07,y
    107  2143		       85 1c		      sta	GRP1
    108  2145
    109  2145		       b9 00 b4 	      lda	bmp_96x2_1_03,y	;5
    110  2148		       85 1b		      sta	GRP0	;3 =  8
    111  214a		       b9 aa b4 	      lda	bmp_96x2_1_05,y	;5
    112  214d		       85 1b		      sta	GRP0	;3 =  8
    113  214f
      0  214f					      sleep	2
      1  214f				   .CYCLES    SET	2
      2  214f
      3  214f				  -	      IF	.CYCLES < 2
      4  214f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  214f				  -	      ERR
      6  214f					      ENDIF
      7  214f
      8  214f				  -	      IF	.CYCLES & 1
      9  214f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  214f				  -	      nop	0
     11  214f				  -	      ELSE
     12  214f				  -	      bit	VSYNC
     13  214f				  -	      ENDIF
     14  214f				  -.CYCLES    SET	.CYCLES - 3
     15  214f					      ENDIF
     16  214f
     17  214f					      REPEAT	.CYCLES / 2
     18  214f		       ea		      nop
     19  2150					      REPEND
    115  2150
    116  2150		       b9 00 b6 	      lda	bmp_96x2_1_09,y	;5
    117  2153		       85 1c		      sta	GRP1	;3 =  8
    118  2155		       b9 aa b6 	      lda	bmp_96x2_1_11,y	;5
    119  2158		       85 1c		      sta	GRP1	;3 =  8
    120  215a
      0  215a					      sleep	2
      1  215a				   .CYCLES    SET	2
      2  215a
      3  215a				  -	      IF	.CYCLES < 2
      4  215a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  215a				  -	      ERR
      6  215a					      ENDIF
      7  215a
      8  215a				  -	      IF	.CYCLES & 1
      9  215a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  215a				  -	      nop	0
     11  215a				  -	      ELSE
     12  215a				  -	      bit	VSYNC
     13  215a				  -	      ENDIF
     14  215a				  -.CYCLES    SET	.CYCLES - 3
     15  215a					      ENDIF
     16  215a
     17  215a					      REPEAT	.CYCLES / 2
     18  215a		       ea		      nop
     19  215b					      REPEND
    122  215b		       86 07		      stx	COLUP1
    123  215d		       86 06		      stx	COLUP0
    124  215f
    125  215f		       85 2a		      sta	HMOVE	;3 - CYCLE 74 HMOVE
      0  2161					      sleep	2
      1  2161				   .CYCLES    SET	2
      2  2161
      3  2161				  -	      IF	.CYCLES < 2
      4  2161				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2161				  -	      ERR
      6  2161					      ENDIF
      7  2161
      8  2161				  -	      IF	.CYCLES & 1
      9  2161				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2161				  -	      nop	0
     11  2161				  -	      ELSE
     12  2161				  -	      bit	VSYNC
     13  2161				  -	      ENDIF
     14  2161				  -.CYCLES    SET	.CYCLES - 3
     15  2161					      ENDIF
     16  2161
     17  2161					      REPEAT	.CYCLES / 2
     18  2161		       ea		      nop
     19  2162					      REPEND
    127  2162		       88		      dey
    128  2163
    129  2163		       c4 9c		      cpy	temp1	;3
    130  2165		       d0 99		      bne	pfline_96x2_1_frame0	;2/3
    131  2167
    132  2167				   pf96x2_1_0codeend
    133  2167							;echo "critical code #1 in 96x2_1 is ",(pf96x2_1_0codeend-pfline_96x2_1_frame0), " bytes long."
    134  2167
    135  2167		       a9 00		      lda	#0
    136  2169		       85 1b		      sta	GRP0
    137  216b		       85 1c		      sta	GRP1
    138  216d		       4c 6e b2 	      jmp	pfdone_96x2_1
    139  2170
    140  2170
    141  2170				   pf96x2_1_frame1
    142  2170
    143  2170							;postion P0 and P1
    144  2170		       85 02		      sta	WSYNC
    145  2172		       a9 20		      lda	#%00100000
    146  2174		       85 20		      sta	HMP0
    147  2176		       a9 00		      lda	#0
    148  2178		       a9 f0		      lda	#%11110000
    149  217a		       85 21		      sta	HMP1
    150  217c		       85 02		      sta	WSYNC
      0  217e					      sleep	32
      1  217e				   .CYCLES    SET	32
      2  217e
      3  217e				  -	      IF	.CYCLES < 2
      4  217e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  217e				  -	      ERR
      6  217e					      ENDIF
      7  217e
      8  217e				  -	      IF	.CYCLES & 1
      9  217e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  217e				  -	      nop	0
     11  217e				  -	      ELSE
     12  217e				  -	      bit	VSYNC
     13  217e				  -	      ENDIF
     14  217e				  -.CYCLES    SET	.CYCLES - 3
     15  217e					      ENDIF
     16  217e
     17  217e					      REPEAT	.CYCLES / 2
     18  217e		       ea		      nop
     17  217e					      REPEND
     18  217f		       ea		      nop
     17  217f					      REPEND
     18  2180		       ea		      nop
     17  2180					      REPEND
     18  2181		       ea		      nop
     17  2181					      REPEND
     18  2182		       ea		      nop
     17  2182					      REPEND
     18  2183		       ea		      nop
     17  2183					      REPEND
     18  2184		       ea		      nop
     17  2184					      REPEND
     18  2185		       ea		      nop
     17  2185					      REPEND
     18  2186		       ea		      nop
     17  2186					      REPEND
     18  2187		       ea		      nop
     17  2187					      REPEND
     18  2188		       ea		      nop
     17  2188					      REPEND
     18  2189		       ea		      nop
     17  2189					      REPEND
     18  218a		       ea		      nop
     17  218a					      REPEND
     18  218b		       ea		      nop
     17  218b					      REPEND
     18  218c		       ea		      nop
     17  218c					      REPEND
     18  218d		       ea		      nop
     19  218e					      REPEND
    152  218e		       85 10		      sta	RESP0
      0  2190					      sleep	12
      1  2190				   .CYCLES    SET	12
      2  2190
      3  2190				  -	      IF	.CYCLES < 2
      4  2190				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2190				  -	      ERR
      6  2190					      ENDIF
      7  2190
      8  2190				  -	      IF	.CYCLES & 1
      9  2190				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2190				  -	      nop	0
     11  2190				  -	      ELSE
     12  2190				  -	      bit	VSYNC
     13  2190				  -	      ENDIF
     14  2190				  -.CYCLES    SET	.CYCLES - 3
     15  2190					      ENDIF
     16  2190
     17  2190					      REPEAT	.CYCLES / 2
     18  2190		       ea		      nop
     17  2190					      REPEND
     18  2191		       ea		      nop
     17  2191					      REPEND
     18  2192		       ea		      nop
     17  2192					      REPEND
     18  2193		       ea		      nop
     17  2193					      REPEND
     18  2194		       ea		      nop
     17  2194					      REPEND
     18  2195		       ea		      nop
     19  2196					      REPEND
    154  2196		       85 11		      sta	RESP1
    155  2198		       85 02		      sta	WSYNC
    156  219a		       85 2a		      sta	HMOVE
    157  219c
    158  219c		       85 02		      sta	WSYNC
    159  219e		       85 2b		      sta	HMCLR
    160  21a0
    161  21a0
    162  21a0
    163  21a0		       85 02		      sta	WSYNC
      0  21a2					      sleep	3
      1  21a2				   .CYCLES    SET	3
      2  21a2
      3  21a2				  -	      IF	.CYCLES < 2
      4  21a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21a2				  -	      ERR
      6  21a2					      ENDIF
      7  21a2
      8  21a2					      IF	.CYCLES & 1
      9  21a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  21a2		       04 00		      nop	0
     11  21a4				  -	      ELSE
     12  21a4				  -	      bit	VSYNC
     13  21a4					      ENDIF
     14  21a4				   .CYCLES    SET	.CYCLES - 3
     15  21a4					      ENDIF
     16  21a4
     17  21a4				  -	      REPEAT	.CYCLES / 2
     18  21a4				  -	      nop
     19  21a4					      REPEND
    165  21a4		       4c 00 b2 	      jmp	pfline_96x2_1_frame1
    166  21a7
    167  21a7							;align so our branch doesn't unexpectedly cross a page...
    168  21a7					      if	>. != >[.+$70]
    169  2200		       00 00 00 00*	      align	256
    170  2200					      endif
    171  2200
    172  2200				   pfline_96x2_1_frame1
    173  2200
    174  2200		       85 2a		      sta	HMOVE
    175  2202
    176  2202		       b9 55 b5 	      lda	bmp_96x2_1_07,y	;4
    177  2205		       85 1c		      sta	GRP1	;3
    178  2207
    179  2207		       a9 00		      lda	#$0	;2
    180  2209		       85 20		      sta	HMP0	;3
    181  220b		       85 21		      sta	HMP1	;3
    182  220d
    183  220d		       b9 55 b3 	      lda	bmp_96x2_1_01,y
    184  2210		       8d 1b 00 	      sta.w	GRP0
    185  2213		       b9 00 b4 	      lda	bmp_96x2_1_03,y
    186  2216		       85 1b		      sta	GRP0
    187  2218		       b9 aa b4 	      lda	bmp_96x2_1_05,y
    188  221b		       85 1b		      sta	GRP0
    189  221d
      0  221d					      sleep	2
      1  221d				   .CYCLES    SET	2
      2  221d
      3  221d				  -	      IF	.CYCLES < 2
      4  221d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  221d				  -	      ERR
      6  221d					      ENDIF
      7  221d
      8  221d				  -	      IF	.CYCLES & 1
      9  221d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  221d				  -	      nop	0
     11  221d				  -	      ELSE
     12  221d				  -	      bit	VSYNC
     13  221d				  -	      ENDIF
     14  221d				  -.CYCLES    SET	.CYCLES - 3
     15  221d					      ENDIF
     16  221d
     17  221d					      REPEAT	.CYCLES / 2
     18  221d		       ea		      nop
     19  221e					      REPEND
    191  221e
    192  221e		       b9 00 b6 	      lda	bmp_96x2_1_09,y
    193  2221		       85 1c		      sta	GRP1
    194  2223		       b9 aa b6 	      lda	bmp_96x2_1_11,y
    195  2226		       85 1c		      sta	GRP1
    196  2228
    197  2228		       b9 00 b3 	      lda	bmp_96x2_1_00,y
    198  222b		       85 1b		      sta	GRP0
    199  222d
    200  222d		       8d 2a 00 	      sta.w	HMOVE	;3 - cycle 74
    201  2230
    202  2230							;sta WSYNC	;=0 -----------------------------------------
    203  2230
    204  2230		       b9 00 b5 	      lda	bmp_96x2_1_06,y
    205  2233		       85 1c		      sta	GRP1
    206  2235
      0  2235					      sleep	8
      1  2235				   .CYCLES    SET	8
      2  2235
      3  2235				  -	      IF	.CYCLES < 2
      4  2235				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2235				  -	      ERR
      6  2235					      ENDIF
      7  2235
      8  2235				  -	      IF	.CYCLES & 1
      9  2235				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2235				  -	      nop	0
     11  2235				  -	      ELSE
     12  2235				  -	      bit	VSYNC
     13  2235				  -	      ENDIF
     14  2235				  -.CYCLES    SET	.CYCLES - 3
     15  2235					      ENDIF
     16  2235
     17  2235					      REPEAT	.CYCLES / 2
     18  2235		       ea		      nop
     17  2235					      REPEND
     18  2236		       ea		      nop
     17  2236					      REPEND
     18  2237		       ea		      nop
     17  2237					      REPEND
     18  2238		       ea		      nop
     19  2239					      REPEND
    208  2239
    209  2239		       b9 86 b2 	      lda	bmp_96x2_1_colors-1,y	;get the title color early and store it for later
    210  223c		       aa		      tax		;2
    211  223d
      0  223d					      sleep	3
      1  223d				   .CYCLES    SET	3
      2  223d
      3  223d				  -	      IF	.CYCLES < 2
      4  223d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  223d				  -	      ERR
      6  223d					      ENDIF
      7  223d
      8  223d					      IF	.CYCLES & 1
      9  223d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  223d		       04 00		      nop	0
     11  223f				  -	      ELSE
     12  223f				  -	      bit	VSYNC
     13  223f					      ENDIF
     14  223f				   .CYCLES    SET	.CYCLES - 3
     15  223f					      ENDIF
     16  223f
     17  223f				  -	      REPEAT	.CYCLES / 2
     18  223f				  -	      nop
     19  223f					      REPEND
    213  223f
    214  223f		       a9 80		      lda	#$80	;2
    215  2241		       85 20		      sta	HMP0	;3
    216  2243		       85 21		      sta	HMP1	;3
    217  2245
    218  2245
    219  2245		       b9 aa b3 	      lda	bmp_96x2_1_02,y	;5
    220  2248		       85 1b		      sta	GRP0	;3 =  8
    221  224a
    222  224a		       b9 55 b4 	      lda	bmp_96x2_1_04,y	;5
    223  224d		       85 1b		      sta	GRP0	;3 =  8
    224  224f
      0  224f					      sleep	2
      1  224f				   .CYCLES    SET	2
      2  224f
      3  224f				  -	      IF	.CYCLES < 2
      4  224f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  224f				  -	      ERR
      6  224f					      ENDIF
      7  224f
      8  224f				  -	      IF	.CYCLES & 1
      9  224f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  224f				  -	      nop	0
     11  224f				  -	      ELSE
     12  224f				  -	      bit	VSYNC
     13  224f				  -	      ENDIF
     14  224f				  -.CYCLES    SET	.CYCLES - 3
     15  224f					      ENDIF
     16  224f
     17  224f					      REPEAT	.CYCLES / 2
     18  224f		       ea		      nop
     19  2250					      REPEND
    226  2250
    227  2250		       b9 aa b5 	      lda	bmp_96x2_1_08,y	;5
    228  2253		       85 1c		      sta	GRP1	;3 =  8
    229  2255
    230  2255		       b9 55 b6 	      lda	bmp_96x2_1_10,y	;5
    231  2258		       85 1c		      sta	GRP1	;3 =  8
    232  225a
      0  225a					      sleep	4
      1  225a				   .CYCLES    SET	4
      2  225a
      3  225a				  -	      IF	.CYCLES < 2
      4  225a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  225a				  -	      ERR
      6  225a					      ENDIF
      7  225a
      8  225a				  -	      IF	.CYCLES & 1
      9  225a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  225a				  -	      nop	0
     11  225a				  -	      ELSE
     12  225a				  -	      bit	VSYNC
     13  225a				  -	      ENDIF
     14  225a				  -.CYCLES    SET	.CYCLES - 3
     15  225a					      ENDIF
     16  225a
     17  225a					      REPEAT	.CYCLES / 2
     18  225a		       ea		      nop
     17  225a					      REPEND
     18  225b		       ea		      nop
     19  225c					      REPEND
    234  225c
    235  225c		       88		      dey
    236  225d
    237  225d		       8a		      txa
    238  225e				  -	      ifconst	bmp_96x2_1_fade
    239  225e				  -	      and	bmp_96x2_1_fade
    240  225e					      else
      0  225e					      sleep	3
      1  225e				   .CYCLES    SET	3
      2  225e
      3  225e				  -	      IF	.CYCLES < 2
      4  225e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  225e				  -	      ERR
      6  225e					      ENDIF
      7  225e
      8  225e					      IF	.CYCLES & 1
      9  225e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  225e		       04 00		      nop	0
     11  2260				  -	      ELSE
     12  2260				  -	      bit	VSYNC
     13  2260					      ENDIF
     14  2260				   .CYCLES    SET	.CYCLES - 3
     15  2260					      ENDIF
     16  2260
     17  2260				  -	      REPEAT	.CYCLES / 2
     18  2260				  -	      nop
     19  2260					      REPEND
    242  2260					      endif
    243  2260		       85 07		      sta	COLUP1	;3
    244  2262		       85 06		      sta	COLUP0	;3
    245  2264
    246  2264		       c4 9c		      cpy	temp1	;2
    247  2266		       d0 98		      bne	pfline_96x2_1_frame1	;2/3
    248  2268
    249  2268				   pf96x2_1_1codeend
    250  2268							;echo "critical code #2 in 96x2_1 is ",(pf96x2_1_1codeend-pfline_96x2_1_frame1), " bytes long."
    251  2268
    252  2268		       a9 00		      lda	#0
    253  226a		       85 1b		      sta	GRP0
    254  226c		       85 1c		      sta	GRP1
    255  226e
    256  226e				   pfdone_96x2_1
    257  226e		       85 02		      sta	WSYNC	; debug
    258  2270
    259  2270		       60		      rts
------- FILE titlescreen/asm/titlescreen_pal.asm
     75  2271					      endif		;mk_96x2_1_on
     76  2271
     77  2271				  -	      ifconst	mk_96x2_2_on
     78  2271				  -	      include	"titlescreen/asm/96x2_2_kernel.asm"
     79  2271					      endif		;mk_96x2_2_on
     80  2271
     81  2271				  -	      ifconst	mk_score_on
     82  2271				  -	      include	"titlescreen/asm/score_kernel.asm"
     83  2271					      endif		;mk_score_on
     84  2271
     85  2271				  -	      ifconst	mk_gameselect_on
     86  2271				  -	      include	"titlescreen/asm/gameselect_kernel.asm"
     87  2271					      endif		;mk_gameselect_on
     88  2271
     89  2271				   PFWAIT
     90  2271		       ad 84 02 	      lda	INTIM
     91  2274		       d0 fb		      bne	PFWAIT
     92  2276		       85 02		      sta	WSYNC
     93  2278
     94  2278				   OVERSCAN
     95  2278				  -	      ifnconst	overscan_time
     96  2278				  -	      lda	#34+128
     97  2278					      else
     98  2278		       a9 cd		      lda	#overscan_time+128-5
     99  227a					      endif
    100  227a		       8d 96 02 	      sta	TIM64T
    101  227d
    102  227d							;fix height variables we borrowed, so DPC doesn't crash on drawscreen...
    103  227d				  -	      ifconst	player9height
    104  227d				  -	      ldy	#8
    105  227d				  -	      lda	#0
    106  227d				  -	      sta	player0height
    107  227d				  -.playerheightfixloop
    108  227d				  -	      sta	player1height,y
    109  227d				  -	      ifconst	_NUSIZ1
    110  227d				  -	      sta	_NUSIZ1,y
    111  227d				  -	      endif
    112  227d				  -	      dey
    113  227d				  -	      bpl	.playerheightfixloop
    114  227d					      endif
    115  227d
    116  227d		       a9 c2		      lda	#%11000010
    117  227f		       85 02		      sta	WSYNC
    118  2281		       85 01		      sta	VBLANK
      0  2283					      RETURN
      1  2283				  -	      ifnconst	bankswitch
      2  2283				  -	      rts
      3  2283					      else
      4  2283		       4c dd ff 	      jmp	BS_return
      5  2286					      endif
    120  2286
    121  2286
    122  2286
    123  2286					      ifconst	mk_96x2_1_on
------- FILE titlescreen/96x2_1_image_PAL.asm LEVEL 3 PASS 2
      0  2286					      include	"titlescreen/96x2_1_image_PAL.asm"
      1  2286							;*** The height of the displayed data...
      2  2286		       00 55	   bmp_96x2_1_window =	85
      3  2286
      4  2286							;*** The height of the bitmap data. This can be larger than
      5  2286							;*** the displayed data height, if you're scrolling or animating
      6  2286							;*** the data...
      7  2286		       00 55	   bmp_96x2_1_height =	85
      8  2286
      9  2286
     10  2286				  -	      if	>. != >[.+(bmp_96x2_1_height)]
     11  2286				  -	      align	256
     12  2286					      endif
     13  2286		       00		      BYTE.b	$00	; leave this here!
     14  2287
     15  2287
     16  2287							;*** The color of each line in the bitmap, in reverse order...
     17  2287				   bmp_96x2_1_colors
     18  2287		       0e		      .byte.b	$0E
     19  2288		       0e		      .byte.b	$0E
     20  2289		       0e		      .byte.b	$0E
     21  228a		       0e		      .byte.b	$0E
     22  228b		       0e		      .byte.b	$0E
     23  228c		       0e		      .byte.b	$0E
     24  228d		       0e		      .byte.b	$0E
     25  228e		       0e		      .byte.b	$0E
     26  228f		       0e		      .byte.b	$0E
     27  2290		       0e		      .byte.b	$0E
     28  2291		       0e		      .byte.b	$0E
     29  2292		       0e		      .byte.b	$0E
     30  2293		       0e		      .byte.b	$0E
     31  2294		       0e		      .byte.b	$0E
     32  2295		       0e		      .byte.b	$0E
     33  2296		       0e		      .byte.b	$0E
     34  2297		       0e		      .byte.b	$0E
     35  2298		       0e		      .byte.b	$0E
     36  2299		       0e		      .byte.b	$0E
     37  229a		       0e		      .byte.b	$0E
     38  229b		       0e		      .byte.b	$0E
     39  229c		       66		      .byte.b	$66
     40  229d		       66		      .byte.b	$66
     41  229e		       66		      .byte.b	$66
     42  229f		       66		      .byte.b	$66
     43  22a0		       66		      .byte.b	$66
     44  22a1		       66		      .byte.b	$66
     45  22a2		       66		      .byte.b	$66
     46  22a3		       66		      .byte.b	$66
     47  22a4		       66		      .byte.b	$66
     48  22a5		       66		      .byte.b	$66
     49  22a6		       66		      .byte.b	$66
     50  22a7		       66		      .byte.b	$66
     51  22a8		       0e		      .byte.b	$0E
     52  22a9		       0e		      .byte.b	$0E
     53  22aa		       0e		      .byte.b	$0E
     54  22ab		       0e		      .byte.b	$0E
     55  22ac		       0e		      .byte.b	$0E
     56  22ad		       0e		      .byte.b	$0E
     57  22ae		       0e		      .byte.b	$0E
     58  22af		       0e		      .byte.b	$0E
     59  22b0		       2c		      .byte.b	$2C
     60  22b1		       2c		      .byte.b	$2C
     61  22b2		       2c		      .byte.b	$2C
     62  22b3		       2c		      .byte.b	$2C
     63  22b4		       2c		      .byte.b	$2C
     64  22b5		       2c		      .byte.b	$2C
     65  22b6		       2c		      .byte.b	$2C
     66  22b7		       2c		      .byte.b	$2C
     67  22b8		       2c		      .byte.b	$2C
     68  22b9		       2c		      .byte.b	$2C
     69  22ba		       2c		      .byte.b	$2C
     70  22bb		       2c		      .byte.b	$2C
     71  22bc		       0e		      .byte.b	$0E
     72  22bd		       0e		      .byte.b	$0E
     73  22be		       2c		      .byte.b	$2C
     74  22bf		       2c		      .byte.b	$2C
     75  22c0		       2c		      .byte.b	$2C
     76  22c1		       2c		      .byte.b	$2C
     77  22c2		       2c		      .byte.b	$2C
     78  22c3		       2c		      .byte.b	$2C
     79  22c4		       2c		      .byte.b	$2C
     80  22c5		       2c		      .byte.b	$2C
     81  22c6		       2c		      .byte.b	$2C
     82  22c7		       2c		      .byte.b	$2C
     83  22c8		       2c		      .byte.b	$2C
     84  22c9		       2c		      .byte.b	$2C
     85  22ca		       0e		      .byte.b	$0E
     86  22cb		       0e		      .byte.b	$0E
     87  22cc		       0e		      .byte.b	$0E
     88  22cd		       2c		      .byte.b	$2C
     89  22ce		       2c		      .byte.b	$2C
     90  22cf		       2c		      .byte.b	$2C
     91  22d0		       2c		      .byte.b	$2C
     92  22d1		       2c		      .byte.b	$2C
     93  22d2		       2c		      .byte.b	$2C
     94  22d3		       2c		      .byte.b	$2C
     95  22d4		       2c		      .byte.b	$2C
     96  22d5		       2c		      .byte.b	$2C
     97  22d6		       2c		      .byte.b	$2C
     98  22d7		       2c		      .byte.b	$2C
     99  22d8		       2c		      .byte.b	$2C
    100  22d9		       0e		      .byte.b	$0E
    101  22da		       0e		      .byte.b	$0E
    102  22db		       0e		      .byte.b	$0E
    103  22dc
    104  22dc
    105  22dc					      if	>. != >[.+(bmp_96x2_1_height)]
    106  2300		       00 00 00 00*	      align	256
    107  2300					      endif
    108  2300
    109  2300
    110  2300				   bmp_96x2_1_00
    111  2300							; *** replace this block with your bimap_00 data block...
    112  2300		       00		      BYTE.b	%00000000
    113  2301		       00		      BYTE.b	%00000000
    114  2302		       00		      BYTE.b	%00000000
    115  2303		       00		      BYTE.b	%00000000
    116  2304		       00		      BYTE.b	%00000000
    117  2305		       00		      BYTE.b	%00000000
    118  2306		       00		      BYTE.b	%00000000
    119  2307		       00		      BYTE.b	%00000000
    120  2308		       00		      BYTE.b	%00000000
    121  2309		       00		      BYTE.b	%00000000
    122  230a		       00		      BYTE.b	%00000000
    123  230b		       00		      BYTE.b	%00000000
    124  230c		       00		      BYTE.b	%00000000
    125  230d		       00		      BYTE.b	%00000000
    126  230e		       00		      BYTE.b	%00000000
    127  230f		       00		      BYTE.b	%00000000
    128  2310		       00		      BYTE.b	%00000000
    129  2311		       00		      BYTE.b	%00000000
    130  2312		       00		      BYTE.b	%00000000
    131  2313		       00		      BYTE.b	%00000000
    132  2314		       00		      BYTE.b	%00000000
    133  2315		       00		      BYTE.b	%00000000
    134  2316		       00		      BYTE.b	%00000000
    135  2317		       00		      BYTE.b	%00000000
    136  2318		       00		      BYTE.b	%00000000
    137  2319		       00		      BYTE.b	%00000000
    138  231a		       00		      BYTE.b	%00000000
    139  231b		       00		      BYTE.b	%00000000
    140  231c		       00		      BYTE.b	%00000000
    141  231d		       00		      BYTE.b	%00000000
    142  231e		       00		      BYTE.b	%00000000
    143  231f		       00		      BYTE.b	%00000000
    144  2320		       00		      BYTE.b	%00000000
    145  2321		       00		      BYTE.b	%00000000
    146  2322		       00		      BYTE.b	%00000000
    147  2323		       00		      BYTE.b	%00000000
    148  2324		       00		      BYTE.b	%00000000
    149  2325		       00		      BYTE.b	%00000000
    150  2326		       00		      BYTE.b	%00000000
    151  2327		       00		      BYTE.b	%00000000
    152  2328		       00		      BYTE.b	%00000000
    153  2329		       7c		      BYTE.b	%01111100
    154  232a		       7c		      BYTE.b	%01111100
    155  232b		       7c		      BYTE.b	%01111100
    156  232c		       7c		      BYTE.b	%01111100
    157  232d		       7c		      BYTE.b	%01111100
    158  232e		       7c		      BYTE.b	%01111100
    159  232f		       7f		      BYTE.b	%01111111
    160  2330		       7f		      BYTE.b	%01111111
    161  2331		       7f		      BYTE.b	%01111111
    162  2332		       7f		      BYTE.b	%01111111
    163  2333		       7c		      BYTE.b	%01111100
    164  2334		       00		      BYTE.b	%00000000
    165  2335		       00		      BYTE.b	%00000000
    166  2336		       00		      BYTE.b	%00000000
    167  2337		       00		      BYTE.b	%00000000
    168  2338		       00		      BYTE.b	%00000000
    169  2339		       00		      BYTE.b	%00000000
    170  233a		       00		      BYTE.b	%00000000
    171  233b		       00		      BYTE.b	%00000000
    172  233c		       00		      BYTE.b	%00000000
    173  233d		       00		      BYTE.b	%00000000
    174  233e		       00		      BYTE.b	%00000000
    175  233f		       00		      BYTE.b	%00000000
    176  2340		       00		      BYTE.b	%00000000
    177  2341		       00		      BYTE.b	%00000000
    178  2342		       00		      BYTE.b	%00000000
    179  2343		       00		      BYTE.b	%00000000
    180  2344		       00		      BYTE.b	%00000000
    181  2345		       00		      BYTE.b	%00000000
    182  2346		       00		      BYTE.b	%00000000
    183  2347		       00		      BYTE.b	%00000000
    184  2348		       00		      BYTE.b	%00000000
    185  2349		       00		      BYTE.b	%00000000
    186  234a		       00		      BYTE.b	%00000000
    187  234b		       00		      BYTE.b	%00000000
    188  234c		       00		      BYTE.b	%00000000
    189  234d		       00		      BYTE.b	%00000000
    190  234e		       00		      BYTE.b	%00000000
    191  234f		       00		      BYTE.b	%00000000
    192  2350		       00		      BYTE.b	%00000000
    193  2351		       00		      BYTE.b	%00000000
    194  2352		       00		      BYTE.b	%00000000
    195  2353		       00		      BYTE.b	%00000000
    196  2354		       00		      BYTE.b	%00000000
    197  2355
    198  2355				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    199  2355				  -	      align	256
    200  2355					      endif
    201  2355
    202  2355
    203  2355				   bmp_96x2_1_01
    204  2355							; *** replace this block with your bimap_01 data block...
    205  2355		       00		      BYTE.b	%00000000
    206  2356		       00		      BYTE.b	%00000000
    207  2357		       00		      BYTE.b	%00000000
    208  2358		       00		      BYTE.b	%00000000
    209  2359		       00		      BYTE.b	%00000000
    210  235a		       00		      BYTE.b	%00000000
    211  235b		       00		      BYTE.b	%00000000
    212  235c		       00		      BYTE.b	%00000000
    213  235d		       00		      BYTE.b	%00000000
    214  235e		       00		      BYTE.b	%00000000
    215  235f		       00		      BYTE.b	%00000000
    216  2360		       00		      BYTE.b	%00000000
    217  2361		       00		      BYTE.b	%00000000
    218  2362		       00		      BYTE.b	%00000000
    219  2363		       00		      BYTE.b	%00000000
    220  2364		       00		      BYTE.b	%00000000
    221  2365		       00		      BYTE.b	%00000000
    222  2366		       00		      BYTE.b	%00000000
    223  2367		       00		      BYTE.b	%00000000
    224  2368		       00		      BYTE.b	%00000000
    225  2369		       00		      BYTE.b	%00000000
    226  236a		       00		      BYTE.b	%00000000
    227  236b		       00		      BYTE.b	%00000000
    228  236c		       00		      BYTE.b	%00000000
    229  236d		       00		      BYTE.b	%00000000
    230  236e		       00		      BYTE.b	%00000000
    231  236f		       00		      BYTE.b	%00000000
    232  2370		       00		      BYTE.b	%00000000
    233  2371		       00		      BYTE.b	%00000000
    234  2372		       00		      BYTE.b	%00000000
    235  2373		       00		      BYTE.b	%00000000
    236  2374		       00		      BYTE.b	%00000000
    237  2375		       00		      BYTE.b	%00000000
    238  2376		       00		      BYTE.b	%00000000
    239  2377		       00		      BYTE.b	%00000000
    240  2378		       00		      BYTE.b	%00000000
    241  2379		       00		      BYTE.b	%00000000
    242  237a		       00		      BYTE.b	%00000000
    243  237b		       00		      BYTE.b	%00000000
    244  237c		       00		      BYTE.b	%00000000
    245  237d		       00		      BYTE.b	%00000000
    246  237e		       0f		      BYTE.b	%00001111
    247  237f		       0f		      BYTE.b	%00001111
    248  2380		       0f		      BYTE.b	%00001111
    249  2381		       cf		      BYTE.b	%11001111
    250  2382		       cf		      BYTE.b	%11001111
    251  2383		       cf		      BYTE.b	%11001111
    252  2384		       ff		      BYTE.b	%11111111
    253  2385		       ff		      BYTE.b	%11111111
    254  2386		       3f		      BYTE.b	%00111111
    255  2387		       3f		      BYTE.b	%00111111
    256  2388		       0f		      BYTE.b	%00001111
    257  2389		       00		      BYTE.b	%00000000
    258  238a		       00		      BYTE.b	%00000000
    259  238b		       00		      BYTE.b	%00000000
    260  238c		       00		      BYTE.b	%00000000
    261  238d		       1f		      BYTE.b	%00011111
    262  238e		       1f		      BYTE.b	%00011111
    263  238f		       1f		      BYTE.b	%00011111
    264  2390		       1f		      BYTE.b	%00011111
    265  2391		       1f		      BYTE.b	%00011111
    266  2392		       1f		      BYTE.b	%00011111
    267  2393		       1f		      BYTE.b	%00011111
    268  2394		       1f		      BYTE.b	%00011111
    269  2395		       1f		      BYTE.b	%00011111
    270  2396		       1f		      BYTE.b	%00011111
    271  2397		       1f		      BYTE.b	%00011111
    272  2398		       00		      BYTE.b	%00000000
    273  2399		       00		      BYTE.b	%00000000
    274  239a		       00		      BYTE.b	%00000000
    275  239b		       00		      BYTE.b	%00000000
    276  239c		       00		      BYTE.b	%00000000
    277  239d		       00		      BYTE.b	%00000000
    278  239e		       00		      BYTE.b	%00000000
    279  239f		       00		      BYTE.b	%00000000
    280  23a0		       00		      BYTE.b	%00000000
    281  23a1		       00		      BYTE.b	%00000000
    282  23a2		       00		      BYTE.b	%00000000
    283  23a3		       00		      BYTE.b	%00000000
    284  23a4		       00		      BYTE.b	%00000000
    285  23a5		       00		      BYTE.b	%00000000
    286  23a6		       00		      BYTE.b	%00000000
    287  23a7		       00		      BYTE.b	%00000000
    288  23a8		       00		      BYTE.b	%00000000
    289  23a9		       00		      BYTE.b	%00000000
    290  23aa
    291  23aa				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    292  23aa				  -	      align	256
    293  23aa					      endif
    294  23aa
    295  23aa
    296  23aa				   bmp_96x2_1_02
    297  23aa							; *** replace this block with your bimap_02 data block...
    298  23aa		       00		      BYTE.b	%00000000
    299  23ab		       00		      BYTE.b	%00000000
    300  23ac		       00		      BYTE.b	%00000000
    301  23ad		       00		      BYTE.b	%00000000
    302  23ae		       00		      BYTE.b	%00000000
    303  23af		       00		      BYTE.b	%00000000
    304  23b0		       34		      BYTE.b	%00110100
    305  23b1		       44		      BYTE.b	%01000100
    306  23b2		       46		      BYTE.b	%01000110
    307  23b3		       30		      BYTE.b	%00110000
    308  23b4		       00		      BYTE.b	%00000000
    309  23b5		       00		      BYTE.b	%00000000
    310  23b6		       00		      BYTE.b	%00000000
    311  23b7		       00		      BYTE.b	%00000000
    312  23b8		       00		      BYTE.b	%00000000
    313  23b9		       00		      BYTE.b	%00000000
    314  23ba		       00		      BYTE.b	%00000000
    315  23bb		       00		      BYTE.b	%00000000
    316  23bc		       00		      BYTE.b	%00000000
    317  23bd		       00		      BYTE.b	%00000000
    318  23be		       00		      BYTE.b	%00000000
    319  23bf		       00		      BYTE.b	%00000000
    320  23c0		       00		      BYTE.b	%00000000
    321  23c1		       00		      BYTE.b	%00000000
    322  23c2		       00		      BYTE.b	%00000000
    323  23c3		       00		      BYTE.b	%00000000
    324  23c4		       00		      BYTE.b	%00000000
    325  23c5		       00		      BYTE.b	%00000000
    326  23c6		       00		      BYTE.b	%00000000
    327  23c7		       00		      BYTE.b	%00000000
    328  23c8		       00		      BYTE.b	%00000000
    329  23c9		       00		      BYTE.b	%00000000
    330  23ca		       00		      BYTE.b	%00000000
    331  23cb		       00		      BYTE.b	%00000000
    332  23cc		       00		      BYTE.b	%00000000
    333  23cd		       00		      BYTE.b	%00000000
    334  23ce		       00		      BYTE.b	%00000000
    335  23cf		       00		      BYTE.b	%00000000
    336  23d0		       00		      BYTE.b	%00000000
    337  23d1		       00		      BYTE.b	%00000000
    338  23d2		       00		      BYTE.b	%00000000
    339  23d3		       87		      BYTE.b	%10000111
    340  23d4		       87		      BYTE.b	%10000111
    341  23d5		       87		      BYTE.b	%10000111
    342  23d6		       87		      BYTE.b	%10000111
    343  23d7		       87		      BYTE.b	%10000111
    344  23d8		       87		      BYTE.b	%10000111
    345  23d9		       87		      BYTE.b	%10000111
    346  23da		       87		      BYTE.b	%10000111
    347  23db		       81		      BYTE.b	%10000001
    348  23dc		       81		      BYTE.b	%10000001
    349  23dd		       80		      BYTE.b	%10000000
    350  23de		       00		      BYTE.b	%00000000
    351  23df		       00		      BYTE.b	%00000000
    352  23e0		       00		      BYTE.b	%00000000
    353  23e1		       00		      BYTE.b	%00000000
    354  23e2		       ff		      BYTE.b	%11111111
    355  23e3		       ff		      BYTE.b	%11111111
    356  23e4		       03		      BYTE.b	%00000011
    357  23e5		       03		      BYTE.b	%00000011
    358  23e6		       03		      BYTE.b	%00000011
    359  23e7		       ff		      BYTE.b	%11111111
    360  23e8		       ff		      BYTE.b	%11111111
    361  23e9		       03		      BYTE.b	%00000011
    362  23ea		       03		      BYTE.b	%00000011
    363  23eb		       ff		      BYTE.b	%11111111
    364  23ec		       ff		      BYTE.b	%11111111
    365  23ed		       00		      BYTE.b	%00000000
    366  23ee		       00		      BYTE.b	%00000000
    367  23ef		       00		      BYTE.b	%00000000
    368  23f0		       00		      BYTE.b	%00000000
    369  23f1		       00		      BYTE.b	%00000000
    370  23f2		       00		      BYTE.b	%00000000
    371  23f3		       00		      BYTE.b	%00000000
    372  23f4		       00		      BYTE.b	%00000000
    373  23f5		       00		      BYTE.b	%00000000
    374  23f6		       00		      BYTE.b	%00000000
    375  23f7		       00		      BYTE.b	%00000000
    376  23f8		       00		      BYTE.b	%00000000
    377  23f9		       00		      BYTE.b	%00000000
    378  23fa		       00		      BYTE.b	%00000000
    379  23fb		       00		      BYTE.b	%00000000
    380  23fc		       00		      BYTE.b	%00000000
    381  23fd		       00		      BYTE.b	%00000000
    382  23fe		       00		      BYTE.b	%00000000
    383  23ff
    384  23ff					      if	>. != >[.+(bmp_96x2_1_height)]
    385  2400		       00		      align	256
    386  2400					      endif
    387  2400
    388  2400
    389  2400				   bmp_96x2_1_03
    390  2400							; *** replace this block with your bimap_03 data block...
    391  2400		       00		      BYTE.b	%00000000
    392  2401		       00		      BYTE.b	%00000000
    393  2402		       00		      BYTE.b	%00000000
    394  2403		       00		      BYTE.b	%00000000
    395  2404		       00		      BYTE.b	%00000000
    396  2405		       00		      BYTE.b	%00000000
    397  2406		       e6		      BYTE.b	%11100110
    398  2407		       ca		      BYTE.b	%11001010
    399  2408		       e6		      BYTE.b	%11100110
    400  2409		       00		      BYTE.b	%00000000
    401  240a		       00		      BYTE.b	%00000000
    402  240b		       00		      BYTE.b	%00000000
    403  240c		       00		      BYTE.b	%00000000
    404  240d		       00		      BYTE.b	%00000000
    405  240e		       00		      BYTE.b	%00000000
    406  240f		       00		      BYTE.b	%00000000
    407  2410		       00		      BYTE.b	%00000000
    408  2411		       00		      BYTE.b	%00000000
    409  2412		       00		      BYTE.b	%00000000
    410  2413		       00		      BYTE.b	%00000000
    411  2414		       00		      BYTE.b	%00000000
    412  2415		       00		      BYTE.b	%00000000
    413  2416		       00		      BYTE.b	%00000000
    414  2417		       00		      BYTE.b	%00000000
    415  2418		       00		      BYTE.b	%00000000
    416  2419		       00		      BYTE.b	%00000000
    417  241a		       00		      BYTE.b	%00000000
    418  241b		       00		      BYTE.b	%00000000
    419  241c		       02		      BYTE.b	%00000010
    420  241d		       03		      BYTE.b	%00000011
    421  241e		       02		      BYTE.b	%00000010
    422  241f		       03		      BYTE.b	%00000011
    423  2420		       00		      BYTE.b	%00000000
    424  2421		       00		      BYTE.b	%00000000
    425  2422		       00		      BYTE.b	%00000000
    426  2423		       00		      BYTE.b	%00000000
    427  2424		       00		      BYTE.b	%00000000
    428  2425		       00		      BYTE.b	%00000000
    429  2426		       00		      BYTE.b	%00000000
    430  2427		       00		      BYTE.b	%00000000
    431  2428		       00		      BYTE.b	%00000000
    432  2429		       80		      BYTE.b	%10000000
    433  242a		       80		      BYTE.b	%10000000
    434  242b		       80		      BYTE.b	%10000000
    435  242c		       ff		      BYTE.b	%11111111
    436  242d		       ff		      BYTE.b	%11111111
    437  242e		       80		      BYTE.b	%10000000
    438  242f		       80		      BYTE.b	%10000000
    439  2430		       c1		      BYTE.b	%11000001
    440  2431		       f7		      BYTE.b	%11110111
    441  2432		       ff		      BYTE.b	%11111111
    442  2433		       7f		      BYTE.b	%01111111
    443  2434		       00		      BYTE.b	%00000000
    444  2435		       00		      BYTE.b	%00000000
    445  2436		       00		      BYTE.b	%00000000
    446  2437		       00		      BYTE.b	%00000000
    447  2438		       83		      BYTE.b	%10000011
    448  2439		       83		      BYTE.b	%10000011
    449  243a		       e3		      BYTE.b	%11100011
    450  243b		       e3		      BYTE.b	%11100011
    451  243c		       e3		      BYTE.b	%11100011
    452  243d		       83		      BYTE.b	%10000011
    453  243e		       e3		      BYTE.b	%11100011
    454  243f		       e3		      BYTE.b	%11100011
    455  2440		       e3		      BYTE.b	%11100011
    456  2441		       c3		      BYTE.b	%11000011
    457  2442		       83		      BYTE.b	%10000011
    458  2443		       00		      BYTE.b	%00000000
    459  2444		       00		      BYTE.b	%00000000
    460  2445		       00		      BYTE.b	%00000000
    461  2446		       00		      BYTE.b	%00000000
    462  2447		       00		      BYTE.b	%00000000
    463  2448		       00		      BYTE.b	%00000000
    464  2449		       00		      BYTE.b	%00000000
    465  244a		       00		      BYTE.b	%00000000
    466  244b		       00		      BYTE.b	%00000000
    467  244c		       00		      BYTE.b	%00000000
    468  244d		       00		      BYTE.b	%00000000
    469  244e		       00		      BYTE.b	%00000000
    470  244f		       00		      BYTE.b	%00000000
    471  2450		       00		      BYTE.b	%00000000
    472  2451		       00		      BYTE.b	%00000000
    473  2452		       00		      BYTE.b	%00000000
    474  2453		       00		      BYTE.b	%00000000
    475  2454		       00		      BYTE.b	%00000000
    476  2455
    477  2455				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    478  2455				  -	      align	256
    479  2455					      endif
    480  2455
    481  2455
    482  2455				   bmp_96x2_1_04
    483  2455							; *** replace this block with your bimap_04 data block...
    484  2455		       00		      BYTE.b	%00000000
    485  2456		       00		      BYTE.b	%00000000
    486  2457		       00		      BYTE.b	%00000000
    487  2458		       00		      BYTE.b	%00000000
    488  2459		       00		      BYTE.b	%00000000
    489  245a		       00		      BYTE.b	%00000000
    490  245b		       4e		      BYTE.b	%01001110
    491  245c		       4c		      BYTE.b	%01001100
    492  245d		       ee		      BYTE.b	%11101110
    493  245e		       40		      BYTE.b	%01000000
    494  245f		       00		      BYTE.b	%00000000
    495  2460		       00		      BYTE.b	%00000000
    496  2461		       00		      BYTE.b	%00000000
    497  2462		       00		      BYTE.b	%00000000
    498  2463		       00		      BYTE.b	%00000000
    499  2464		       00		      BYTE.b	%00000000
    500  2465		       00		      BYTE.b	%00000000
    501  2466		       00		      BYTE.b	%00000000
    502  2467		       00		      BYTE.b	%00000000
    503  2468		       00		      BYTE.b	%00000000
    504  2469		       00		      BYTE.b	%00000000
    505  246a		       11		      BYTE.b	%00010001
    506  246b		       12		      BYTE.b	%00010010
    507  246c		       12		      BYTE.b	%00010010
    508  246d		       39		      BYTE.b	%00111001
    509  246e		       00		      BYTE.b	%00000000
    510  246f		       00		      BYTE.b	%00000000
    511  2470		       00		      BYTE.b	%00000000
    512  2471		       2b		      BYTE.b	%00101011
    513  2472		       32		      BYTE.b	%00110010
    514  2473		       ab		      BYTE.b	%10101011
    515  2474		       33		      BYTE.b	%00110011
    516  2475		       00		      BYTE.b	%00000000
    517  2476		       00		      BYTE.b	%00000000
    518  2477		       00		      BYTE.b	%00000000
    519  2478		       00		      BYTE.b	%00000000
    520  2479		       00		      BYTE.b	%00000000
    521  247a		       00		      BYTE.b	%00000000
    522  247b		       00		      BYTE.b	%00000000
    523  247c		       00		      BYTE.b	%00000000
    524  247d		       00		      BYTE.b	%00000000
    525  247e		       f8		      BYTE.b	%11111000
    526  247f		       f8		      BYTE.b	%11111000
    527  2480		       f8		      BYTE.b	%11111000
    528  2481		       f8		      BYTE.b	%11111000
    529  2482		       f8		      BYTE.b	%11111000
    530  2483		       f8		      BYTE.b	%11111000
    531  2484		       f8		      BYTE.b	%11111000
    532  2485		       f8		      BYTE.b	%11111000
    533  2486		       c0		      BYTE.b	%11000000
    534  2487		       c0		      BYTE.b	%11000000
    535  2488		       00		      BYTE.b	%00000000
    536  2489		       00		      BYTE.b	%00000000
    537  248a		       00		      BYTE.b	%00000000
    538  248b		       00		      BYTE.b	%00000000
    539  248c		       00		      BYTE.b	%00000000
    540  248d		       ff		      BYTE.b	%11111111
    541  248e		       ff		      BYTE.b	%11111111
    542  248f		       e0		      BYTE.b	%11100000
    543  2490		       e0		      BYTE.b	%11100000
    544  2491		       e0		      BYTE.b	%11100000
    545  2492		       ff		      BYTE.b	%11111111
    546  2493		       ff		      BYTE.b	%11111111
    547  2494		       e0		      BYTE.b	%11100000
    548  2495		       e0		      BYTE.b	%11100000
    549  2496		       ff		      BYTE.b	%11111111
    550  2497		       ff		      BYTE.b	%11111111
    551  2498		       00		      BYTE.b	%00000000
    552  2499		       00		      BYTE.b	%00000000
    553  249a		       00		      BYTE.b	%00000000
    554  249b		       00		      BYTE.b	%00000000
    555  249c		       00		      BYTE.b	%00000000
    556  249d		       00		      BYTE.b	%00000000
    557  249e		       00		      BYTE.b	%00000000
    558  249f		       00		      BYTE.b	%00000000
    559  24a0		       00		      BYTE.b	%00000000
    560  24a1		       00		      BYTE.b	%00000000
    561  24a2		       00		      BYTE.b	%00000000
    562  24a3		       00		      BYTE.b	%00000000
    563  24a4		       00		      BYTE.b	%00000000
    564  24a5		       00		      BYTE.b	%00000000
    565  24a6		       00		      BYTE.b	%00000000
    566  24a7		       00		      BYTE.b	%00000000
    567  24a8		       00		      BYTE.b	%00000000
    568  24a9		       00		      BYTE.b	%00000000
    569  24aa
    570  24aa				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    571  24aa				  -	      align	256
    572  24aa					      endif
    573  24aa
    574  24aa
    575  24aa				   bmp_96x2_1_05
    576  24aa							; *** replace this block with your bimap_05 data block...
    577  24aa		       00		      BYTE.b	%00000000
    578  24ab		       00		      BYTE.b	%00000000
    579  24ac		       00		      BYTE.b	%00000000
    580  24ad		       00		      BYTE.b	%00000000
    581  24ae		       00		      BYTE.b	%00000000
    582  24af		       00		      BYTE.b	%00000000
    583  24b0		       63		      BYTE.b	%01100011
    584  24b1		       a2		      BYTE.b	%10100010
    585  24b2		       63		      BYTE.b	%01100011
    586  24b3		       22		      BYTE.b	%00100010
    587  24b4		       00		      BYTE.b	%00000000
    588  24b5		       00		      BYTE.b	%00000000
    589  24b6		       00		      BYTE.b	%00000000
    590  24b7		       00		      BYTE.b	%00000000
    591  24b8		       00		      BYTE.b	%00000000
    592  24b9		       00		      BYTE.b	%00000000
    593  24ba		       00		      BYTE.b	%00000000
    594  24bb		       00		      BYTE.b	%00000000
    595  24bc		       00		      BYTE.b	%00000000
    596  24bd		       00		      BYTE.b	%00000000
    597  24be		       00		      BYTE.b	%00000000
    598  24bf		       0c		      BYTE.b	%00001100
    599  24c0		       82		      BYTE.b	%10000010
    600  24c1		       8c		      BYTE.b	%10001100
    601  24c2		       06		      BYTE.b	%00000110
    602  24c3		       00		      BYTE.b	%00000000
    603  24c4		       00		      BYTE.b	%00000000
    604  24c5		       00		      BYTE.b	%00000000
    605  24c6		       b3		      BYTE.b	%10110011
    606  24c7		       08		      BYTE.b	%00001000
    607  24c8		       33		      BYTE.b	%00110011
    608  24c9		       99		      BYTE.b	%10011001
    609  24ca		       00		      BYTE.b	%00000000
    610  24cb		       00		      BYTE.b	%00000000
    611  24cc		       00		      BYTE.b	%00000000
    612  24cd		       00		      BYTE.b	%00000000
    613  24ce		       00		      BYTE.b	%00000000
    614  24cf		       00		      BYTE.b	%00000000
    615  24d0		       00		      BYTE.b	%00000000
    616  24d1		       00		      BYTE.b	%00000000
    617  24d2		       00		      BYTE.b	%00000000
    618  24d3		       f8		      BYTE.b	%11111000
    619  24d4		       f8		      BYTE.b	%11111000
    620  24d5		       f8		      BYTE.b	%11111000
    621  24d6		       f8		      BYTE.b	%11111000
    622  24d7		       f8		      BYTE.b	%11111000
    623  24d8		       f9		      BYTE.b	%11111001
    624  24d9		       ff		      BYTE.b	%11111111
    625  24da		       ff		      BYTE.b	%11111111
    626  24db		       fe		      BYTE.b	%11111110
    627  24dc		       fe		      BYTE.b	%11111110
    628  24dd		       f8		      BYTE.b	%11111000
    629  24de		       00		      BYTE.b	%00000000
    630  24df		       00		      BYTE.b	%00000000
    631  24e0		       00		      BYTE.b	%00000000
    632  24e1		       00		      BYTE.b	%00000000
    633  24e2		       fc		      BYTE.b	%11111100
    634  24e3		       fc		      BYTE.b	%11111100
    635  24e4		       00		      BYTE.b	%00000000
    636  24e5		       00		      BYTE.b	%00000000
    637  24e6		       00		      BYTE.b	%00000000
    638  24e7		       f0		      BYTE.b	%11110000
    639  24e8		       f0		      BYTE.b	%11110000
    640  24e9		       00		      BYTE.b	%00000000
    641  24ea		       00		      BYTE.b	%00000000
    642  24eb		       fc		      BYTE.b	%11111100
    643  24ec		       fc		      BYTE.b	%11111100
    644  24ed		       00		      BYTE.b	%00000000
    645  24ee		       00		      BYTE.b	%00000000
    646  24ef		       00		      BYTE.b	%00000000
    647  24f0		       0f		      BYTE.b	%00001111
    648  24f1		       0f		      BYTE.b	%00001111
    649  24f2		       0f		      BYTE.b	%00001111
    650  24f3		       0f		      BYTE.b	%00001111
    651  24f4		       0f		      BYTE.b	%00001111
    652  24f5		       0f		      BYTE.b	%00001111
    653  24f6		       0f		      BYTE.b	%00001111
    654  24f7		       0f		      BYTE.b	%00001111
    655  24f8		       0f		      BYTE.b	%00001111
    656  24f9		       0f		      BYTE.b	%00001111
    657  24fa		       0f		      BYTE.b	%00001111
    658  24fb		       0f		      BYTE.b	%00001111
    659  24fc		       0f		      BYTE.b	%00001111
    660  24fd		       0f		      BYTE.b	%00001111
    661  24fe		       00		      BYTE.b	%00000000
    662  24ff
    663  24ff					      if	>. != >[.+(bmp_96x2_1_height)]
    664  2500		       00		      align	256
    665  2500					      endif
    666  2500
    667  2500
    668  2500				   bmp_96x2_1_06
    669  2500							; *** replace this block with your bimap_06 data block...
    670  2500		       00		      BYTE.b	%00000000
    671  2501		       00		      BYTE.b	%00000000
    672  2502		       00		      BYTE.b	%00000000
    673  2503		       00		      BYTE.b	%00000000
    674  2504		       00		      BYTE.b	%00000000
    675  2505		       00		      BYTE.b	%00000000
    676  2506		       20		      BYTE.b	%00100000
    677  2507		       90		      BYTE.b	%10010000
    678  2508		       28		      BYTE.b	%00101000
    679  2509		       00		      BYTE.b	%00000000
    680  250a		       00		      BYTE.b	%00000000
    681  250b		       00		      BYTE.b	%00000000
    682  250c		       00		      BYTE.b	%00000000
    683  250d		       00		      BYTE.b	%00000000
    684  250e		       00		      BYTE.b	%00000000
    685  250f		       00		      BYTE.b	%00000000
    686  2510		       00		      BYTE.b	%00000000
    687  2511		       00		      BYTE.b	%00000000
    688  2512		       00		      BYTE.b	%00000000
    689  2513		       00		      BYTE.b	%00000000
    690  2514		       00		      BYTE.b	%00000000
    691  2515		       4a		      BYTE.b	%01001010
    692  2516		       4e		      BYTE.b	%01001110
    693  2517		       4a		      BYTE.b	%01001010
    694  2518		       e4		      BYTE.b	%11100100
    695  2519		       00		      BYTE.b	%00000000
    696  251a		       00		      BYTE.b	%00000000
    697  251b		       00		      BYTE.b	%00000000
    698  251c		       08		      BYTE.b	%00001000
    699  251d		       88		      BYTE.b	%10001000
    700  251e		       0c		      BYTE.b	%00001100
    701  251f		       8e		      BYTE.b	%10001110
    702  2520		       00		      BYTE.b	%00000000
    703  2521		       00		      BYTE.b	%00000000
    704  2522		       00		      BYTE.b	%00000000
    705  2523		       00		      BYTE.b	%00000000
    706  2524		       00		      BYTE.b	%00000000
    707  2525		       00		      BYTE.b	%00000000
    708  2526		       00		      BYTE.b	%00000000
    709  2527		       00		      BYTE.b	%00000000
    710  2528		       00		      BYTE.b	%00000000
    711  2529		       1f		      BYTE.b	%00011111
    712  252a		       1f		      BYTE.b	%00011111
    713  252b		       1f		      BYTE.b	%00011111
    714  252c		       7f		      BYTE.b	%01111111
    715  252d		       7f		      BYTE.b	%01111111
    716  252e		       ff		      BYTE.b	%11111111
    717  252f		       ff		      BYTE.b	%11111111
    718  2530		       9f		      BYTE.b	%10011111
    719  2531		       1f		      BYTE.b	%00011111
    720  2532		       1f		      BYTE.b	%00011111
    721  2533		       1f		      BYTE.b	%00011111
    722  2534		       00		      BYTE.b	%00000000
    723  2535		       00		      BYTE.b	%00000000
    724  2536		       00		      BYTE.b	%00000000
    725  2537		       00		      BYTE.b	%00000000
    726  2538		       3f		      BYTE.b	%00111111
    727  2539		       3f		      BYTE.b	%00111111
    728  253a		       3e		      BYTE.b	%00111110
    729  253b		       3e		      BYTE.b	%00111110
    730  253c		       3e		      BYTE.b	%00111110
    731  253d		       3f		      BYTE.b	%00111111
    732  253e		       3f		      BYTE.b	%00111111
    733  253f		       3e		      BYTE.b	%00111110
    734  2540		       3e		      BYTE.b	%00111110
    735  2541		       3f		      BYTE.b	%00111111
    736  2542		       3f		      BYTE.b	%00111111
    737  2543		       00		      BYTE.b	%00000000
    738  2544		       00		      BYTE.b	%00000000
    739  2545		       00		      BYTE.b	%00000000
    740  2546		       fc		      BYTE.b	%11111100
    741  2547		       fc		      BYTE.b	%11111100
    742  2548		       ff		      BYTE.b	%11111111
    743  2549		       fc		      BYTE.b	%11111100
    744  254a		       fc		      BYTE.b	%11111100
    745  254b		       fc		      BYTE.b	%11111100
    746  254c		       fc		      BYTE.b	%11111100
    747  254d		       fc		      BYTE.b	%11111100
    748  254e		       ff		      BYTE.b	%11111111
    749  254f		       fc		      BYTE.b	%11111100
    750  2550		       fc		      BYTE.b	%11111100
    751  2551		       fc		      BYTE.b	%11111100
    752  2552		       fc		      BYTE.b	%11111100
    753  2553		       fc		      BYTE.b	%11111100
    754  2554		       00		      BYTE.b	%00000000
    755  2555
    756  2555				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    757  2555				  -	      align	256
    758  2555					      endif
    759  2555
    760  2555
    761  2555				   bmp_96x2_1_07
    762  2555							; *** replace this block with your bimap_07 data block...
    763  2555		       00		      BYTE.b	%00000000
    764  2556		       00		      BYTE.b	%00000000
    765  2557		       00		      BYTE.b	%00000000
    766  2558		       00		      BYTE.b	%00000000
    767  2559		       00		      BYTE.b	%00000000
    768  255a		       00		      BYTE.b	%00000000
    769  255b		       8c		      BYTE.b	%10001100
    770  255c		       c2		      BYTE.b	%11000010
    771  255d		       ac		      BYTE.b	%10101100
    772  255e		       c6		      BYTE.b	%11000110
    773  255f		       00		      BYTE.b	%00000000
    774  2560		       00		      BYTE.b	%00000000
    775  2561		       00		      BYTE.b	%00000000
    776  2562		       00		      BYTE.b	%00000000
    777  2563		       00		      BYTE.b	%00000000
    778  2564		       00		      BYTE.b	%00000000
    779  2565		       00		      BYTE.b	%00000000
    780  2566		       00		      BYTE.b	%00000000
    781  2567		       00		      BYTE.b	%00000000
    782  2568		       00		      BYTE.b	%00000000
    783  2569		       00		      BYTE.b	%00000000
    784  256a		       a4		      BYTE.b	%10100100
    785  256b		       c4		      BYTE.b	%11000100
    786  256c		       a4		      BYTE.b	%10100100
    787  256d		       ce		      BYTE.b	%11001110
    788  256e		       00		      BYTE.b	%00000000
    789  256f		       00		      BYTE.b	%00000000
    790  2570		       00		      BYTE.b	%00000000
    791  2571		       ab		      BYTE.b	%10101011
    792  2572		       b2		      BYTE.b	%10110010
    793  2573		       ab		      BYTE.b	%10101011
    794  2574		       b3		      BYTE.b	%10110011
    795  2575		       00		      BYTE.b	%00000000
    796  2576		       00		      BYTE.b	%00000000
    797  2577		       00		      BYTE.b	%00000000
    798  2578		       00		      BYTE.b	%00000000
    799  2579		       00		      BYTE.b	%00000000
    800  257a		       00		      BYTE.b	%00000000
    801  257b		       00		      BYTE.b	%00000000
    802  257c		       00		      BYTE.b	%00000000
    803  257d		       00		      BYTE.b	%00000000
    804  257e		       03		      BYTE.b	%00000011
    805  257f		       03		      BYTE.b	%00000011
    806  2580		       00		      BYTE.b	%00000000
    807  2581		       00		      BYTE.b	%00000000
    808  2582		       00		      BYTE.b	%00000000
    809  2583		       00		      BYTE.b	%00000000
    810  2584		       00		      BYTE.b	%00000000
    811  2585		       00		      BYTE.b	%00000000
    812  2586		       00		      BYTE.b	%00000000
    813  2587		       03		      BYTE.b	%00000011
    814  2588		       03		      BYTE.b	%00000011
    815  2589		       00		      BYTE.b	%00000000
    816  258a		       00		      BYTE.b	%00000000
    817  258b		       00		      BYTE.b	%00000000
    818  258c		       00		      BYTE.b	%00000000
    819  258d		       ff		      BYTE.b	%11111111
    820  258e		       ff		      BYTE.b	%11111111
    821  258f		       00		      BYTE.b	%00000000
    822  2590		       00		      BYTE.b	%00000000
    823  2591		       00		      BYTE.b	%00000000
    824  2592		       ff		      BYTE.b	%11111111
    825  2593		       fe		      BYTE.b	%11111110
    826  2594		       00		      BYTE.b	%00000000
    827  2595		       00		      BYTE.b	%00000000
    828  2596		       ff		      BYTE.b	%11111111
    829  2597		       ff		      BYTE.b	%11111111
    830  2598		       00		      BYTE.b	%00000000
    831  2599		       00		      BYTE.b	%00000000
    832  259a		       00		      BYTE.b	%00000000
    833  259b		       00		      BYTE.b	%00000000
    834  259c		       00		      BYTE.b	%00000000
    835  259d		       c0		      BYTE.b	%11000000
    836  259e		       40		      BYTE.b	%01000000
    837  259f		       40		      BYTE.b	%01000000
    838  25a0		       40		      BYTE.b	%01000000
    839  25a1		       40		      BYTE.b	%01000000
    840  25a2		       40		      BYTE.b	%01000000
    841  25a3		       c0		      BYTE.b	%11000000
    842  25a4		       00		      BYTE.b	%00000000
    843  25a5		       00		      BYTE.b	%00000000
    844  25a6		       00		      BYTE.b	%00000000
    845  25a7		       00		      BYTE.b	%00000000
    846  25a8		       00		      BYTE.b	%00000000
    847  25a9		       00		      BYTE.b	%00000000
    848  25aa
    849  25aa				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    850  25aa				  -	      align	256
    851  25aa					      endif
    852  25aa
    853  25aa
    854  25aa				   bmp_96x2_1_08
    855  25aa							; *** replace this block with your bimap_08 data block...
    856  25aa		       00		      BYTE.b	%00000000
    857  25ab		       00		      BYTE.b	%00000000
    858  25ac		       00		      BYTE.b	%00000000
    859  25ad		       00		      BYTE.b	%00000000
    860  25ae		       00		      BYTE.b	%00000000
    861  25af		       00		      BYTE.b	%00000000
    862  25b0		       ce		      BYTE.b	%11001110
    863  25b1		       a8		      BYTE.b	%10101000
    864  25b2		       ac		      BYTE.b	%10101100
    865  25b3		       ce		      BYTE.b	%11001110
    866  25b4		       00		      BYTE.b	%00000000
    867  25b5		       00		      BYTE.b	%00000000
    868  25b6		       00		      BYTE.b	%00000000
    869  25b7		       00		      BYTE.b	%00000000
    870  25b8		       00		      BYTE.b	%00000000
    871  25b9		       00		      BYTE.b	%00000000
    872  25ba		       00		      BYTE.b	%00000000
    873  25bb		       00		      BYTE.b	%00000000
    874  25bc		       00		      BYTE.b	%00000000
    875  25bd		       00		      BYTE.b	%00000000
    876  25be		       00		      BYTE.b	%00000000
    877  25bf		       00		      BYTE.b	%00000000
    878  25c0		       00		      BYTE.b	%00000000
    879  25c1		       00		      BYTE.b	%00000000
    880  25c2		       00		      BYTE.b	%00000000
    881  25c3		       00		      BYTE.b	%00000000
    882  25c4		       00		      BYTE.b	%00000000
    883  25c5		       00		      BYTE.b	%00000000
    884  25c6		       80		      BYTE.b	%10000000
    885  25c7		       00		      BYTE.b	%00000000
    886  25c8		       00		      BYTE.b	%00000000
    887  25c9		       80		      BYTE.b	%10000000
    888  25ca		       00		      BYTE.b	%00000000
    889  25cb		       00		      BYTE.b	%00000000
    890  25cc		       00		      BYTE.b	%00000000
    891  25cd		       00		      BYTE.b	%00000000
    892  25ce		       00		      BYTE.b	%00000000
    893  25cf		       00		      BYTE.b	%00000000
    894  25d0		       00		      BYTE.b	%00000000
    895  25d1		       00		      BYTE.b	%00000000
    896  25d2		       00		      BYTE.b	%00000000
    897  25d3		       ff		      BYTE.b	%11111111
    898  25d4		       ff		      BYTE.b	%11111111
    899  25d5		       3e		      BYTE.b	%00111110
    900  25d6		       3e		      BYTE.b	%00111110
    901  25d7		       3e		      BYTE.b	%00111110
    902  25d8		       3e		      BYTE.b	%00111110
    903  25d9		       3e		      BYTE.b	%00111110
    904  25da		       3e		      BYTE.b	%00111110
    905  25db		       3e		      BYTE.b	%00111110
    906  25dc		       ff		      BYTE.b	%11111111
    907  25dd		       ff		      BYTE.b	%11111111
    908  25de		       00		      BYTE.b	%00000000
    909  25df		       00		      BYTE.b	%00000000
    910  25e0		       00		      BYTE.b	%00000000
    911  25e1		       00		      BYTE.b	%00000000
    912  25e2		       c3		      BYTE.b	%11000011
    913  25e3		       c3		      BYTE.b	%11000011
    914  25e4		       03		      BYTE.b	%00000011
    915  25e5		       03		      BYTE.b	%00000011
    916  25e6		       03		      BYTE.b	%00000011
    917  25e7		       03		      BYTE.b	%00000011
    918  25e8		       03		      BYTE.b	%00000011
    919  25e9		       03		      BYTE.b	%00000011
    920  25ea		       03		      BYTE.b	%00000011
    921  25eb		       c3		      BYTE.b	%11000011
    922  25ec		       c3		      BYTE.b	%11000011
    923  25ed		       00		      BYTE.b	%00000000
    924  25ee		       00		      BYTE.b	%00000000
    925  25ef		       00		      BYTE.b	%00000000
    926  25f0		       00		      BYTE.b	%00000000
    927  25f1		       00		      BYTE.b	%00000000
    928  25f2		       00		      BYTE.b	%00000000
    929  25f3		       00		      BYTE.b	%00000000
    930  25f4		       00		      BYTE.b	%00000000
    931  25f5		       00		      BYTE.b	%00000000
    932  25f6		       00		      BYTE.b	%00000000
    933  25f7		       00		      BYTE.b	%00000000
    934  25f8		       00		      BYTE.b	%00000000
    935  25f9		       00		      BYTE.b	%00000000
    936  25fa		       00		      BYTE.b	%00000000
    937  25fb		       00		      BYTE.b	%00000000
    938  25fc		       00		      BYTE.b	%00000000
    939  25fd		       00		      BYTE.b	%00000000
    940  25fe		       00		      BYTE.b	%00000000
    941  25ff
    942  25ff					      if	>. != >[.+(bmp_96x2_1_height)]
    943  2600		       00		      align	256
    944  2600					      endif
    945  2600
    946  2600
    947  2600				   bmp_96x2_1_09
    948  2600							; *** replace this block with your bimap_09 data block...
    949  2600		       00		      BYTE.b	%00000000
    950  2601		       00		      BYTE.b	%00000000
    951  2602		       00		      BYTE.b	%00000000
    952  2603		       00		      BYTE.b	%00000000
    953  2604		       00		      BYTE.b	%00000000
    954  2605		       00		      BYTE.b	%00000000
    955  2606		       ae		      BYTE.b	%10101110
    956  2607		       a8		      BYTE.b	%10101000
    957  2608		       ec		      BYTE.b	%11101100
    958  2609		       ee		      BYTE.b	%11101110
    959  260a		       00		      BYTE.b	%00000000
    960  260b		       00		      BYTE.b	%00000000
    961  260c		       00		      BYTE.b	%00000000
    962  260d		       00		      BYTE.b	%00000000
    963  260e		       00		      BYTE.b	%00000000
    964  260f		       00		      BYTE.b	%00000000
    965  2610		       00		      BYTE.b	%00000000
    966  2611		       00		      BYTE.b	%00000000
    967  2612		       00		      BYTE.b	%00000000
    968  2613		       00		      BYTE.b	%00000000
    969  2614		       00		      BYTE.b	%00000000
    970  2615		       00		      BYTE.b	%00000000
    971  2616		       00		      BYTE.b	%00000000
    972  2617		       00		      BYTE.b	%00000000
    973  2618		       00		      BYTE.b	%00000000
    974  2619		       00		      BYTE.b	%00000000
    975  261a		       00		      BYTE.b	%00000000
    976  261b		       00		      BYTE.b	%00000000
    977  261c		       00		      BYTE.b	%00000000
    978  261d		       00		      BYTE.b	%00000000
    979  261e		       00		      BYTE.b	%00000000
    980  261f		       00		      BYTE.b	%00000000
    981  2620		       00		      BYTE.b	%00000000
    982  2621		       00		      BYTE.b	%00000000
    983  2622		       00		      BYTE.b	%00000000
    984  2623		       00		      BYTE.b	%00000000
    985  2624		       00		      BYTE.b	%00000000
    986  2625		       00		      BYTE.b	%00000000
    987  2626		       00		      BYTE.b	%00000000
    988  2627		       00		      BYTE.b	%00000000
    989  2628		       00		      BYTE.b	%00000000
    990  2629		       f1		      BYTE.b	%11110001
    991  262a		       f1		      BYTE.b	%11110001
    992  262b		       01		      BYTE.b	%00000001
    993  262c		       01		      BYTE.b	%00000001
    994  262d		       01		      BYTE.b	%00000001
    995  262e		       01		      BYTE.b	%00000001
    996  262f		       01		      BYTE.b	%00000001
    997  2630		       01		      BYTE.b	%00000001
    998  2631		       00		      BYTE.b	%00000000
    999  2632		       f0		      BYTE.b	%11110000
   1000  2633		       f0		      BYTE.b	%11110000
   1001  2634		       00		      BYTE.b	%00000000
   1002  2635		       00		      BYTE.b	%00000000
   1003  2636		       00		      BYTE.b	%00000000
   1004  2637		       00		      BYTE.b	%00000000
   1005  2638		       c1		      BYTE.b	%11000001
   1006  2639		       c3		      BYTE.b	%11000011
   1007  263a		       cf		      BYTE.b	%11001111
   1008  263b		       ff		      BYTE.b	%11111111
   1009  263c		       ff		      BYTE.b	%11111111
   1010  263d		       c3		      BYTE.b	%11000011
   1011  263e		       c1		      BYTE.b	%11000001
   1012  263f		       c0		      BYTE.b	%11000000
   1013  2640		       c0		      BYTE.b	%11000000
   1014  2641		       ff		      BYTE.b	%11111111
   1015  2642		       ff		      BYTE.b	%11111111
   1016  2643		       00		      BYTE.b	%00000000
   1017  2644		       00		      BYTE.b	%00000000
   1018  2645		       00		      BYTE.b	%00000000
   1019  2646		       00		      BYTE.b	%00000000
   1020  2647		       00		      BYTE.b	%00000000
   1021  2648		       00		      BYTE.b	%00000000
   1022  2649		       00		      BYTE.b	%00000000
   1023  264a		       00		      BYTE.b	%00000000
   1024  264b		       00		      BYTE.b	%00000000
   1025  264c		       00		      BYTE.b	%00000000
   1026  264d		       00		      BYTE.b	%00000000
   1027  264e		       00		      BYTE.b	%00000000
   1028  264f		       00		      BYTE.b	%00000000
   1029  2650		       00		      BYTE.b	%00000000
   1030  2651		       00		      BYTE.b	%00000000
   1031  2652		       00		      BYTE.b	%00000000
   1032  2653		       00		      BYTE.b	%00000000
   1033  2654		       00		      BYTE.b	%00000000
   1034  2655
   1035  2655				  -	      if	>. != >[.+(bmp_96x2_1_height)]
   1036  2655				  -	      align	256
   1037  2655					      endif
   1038  2655
   1039  2655
   1040  2655				   bmp_96x2_1_10
   1041  2655							; *** replace this block with your bimap_10 data block...
   1042  2655		       00		      BYTE.b	%00000000
   1043  2656		       00		      BYTE.b	%00000000
   1044  2657		       00		      BYTE.b	%00000000
   1045  2658		       00		      BYTE.b	%00000000
   1046  2659		       00		      BYTE.b	%00000000
   1047  265a		       00		      BYTE.b	%00000000
   1048  265b		       00		      BYTE.b	%00000000
   1049  265c		       00		      BYTE.b	%00000000
   1050  265d		       00		      BYTE.b	%00000000
   1051  265e		       00		      BYTE.b	%00000000
   1052  265f		       00		      BYTE.b	%00000000
   1053  2660		       00		      BYTE.b	%00000000
   1054  2661		       00		      BYTE.b	%00000000
   1055  2662		       00		      BYTE.b	%00000000
   1056  2663		       00		      BYTE.b	%00000000
   1057  2664		       00		      BYTE.b	%00000000
   1058  2665		       00		      BYTE.b	%00000000
   1059  2666		       00		      BYTE.b	%00000000
   1060  2667		       00		      BYTE.b	%00000000
   1061  2668		       00		      BYTE.b	%00000000
   1062  2669		       00		      BYTE.b	%00000000
   1063  266a		       00		      BYTE.b	%00000000
   1064  266b		       00		      BYTE.b	%00000000
   1065  266c		       00		      BYTE.b	%00000000
   1066  266d		       00		      BYTE.b	%00000000
   1067  266e		       00		      BYTE.b	%00000000
   1068  266f		       00		      BYTE.b	%00000000
   1069  2670		       00		      BYTE.b	%00000000
   1070  2671		       00		      BYTE.b	%00000000
   1071  2672		       00		      BYTE.b	%00000000
   1072  2673		       00		      BYTE.b	%00000000
   1073  2674		       00		      BYTE.b	%00000000
   1074  2675		       00		      BYTE.b	%00000000
   1075  2676		       00		      BYTE.b	%00000000
   1076  2677		       00		      BYTE.b	%00000000
   1077  2678		       00		      BYTE.b	%00000000
   1078  2679		       00		      BYTE.b	%00000000
   1079  267a		       00		      BYTE.b	%00000000
   1080  267b		       00		      BYTE.b	%00000000
   1081  267c		       00		      BYTE.b	%00000000
   1082  267d		       00		      BYTE.b	%00000000
   1083  267e		       f0		      BYTE.b	%11110000
   1084  267f		       f0		      BYTE.b	%11110000
   1085  2680		       f0		      BYTE.b	%11110000
   1086  2681		       ff		      BYTE.b	%11111111
   1087  2682		       ff		      BYTE.b	%11111111
   1088  2683		       f0		      BYTE.b	%11110000
   1089  2684		       f0		      BYTE.b	%11110000
   1090  2685		       f0		      BYTE.b	%11110000
   1091  2686		       3c		      BYTE.b	%00111100
   1092  2687		       3f		      BYTE.b	%00111111
   1093  2688		       0f		      BYTE.b	%00001111
   1094  2689		       00		      BYTE.b	%00000000
   1095  268a		       00		      BYTE.b	%00000000
   1096  268b		       00		      BYTE.b	%00000000
   1097  268c		       00		      BYTE.b	%00000000
   1098  268d		       fc		      BYTE.b	%11111100
   1099  268e		       fc		      BYTE.b	%11111100
   1100  268f		       e0		      BYTE.b	%11100000
   1101  2690		       e0		      BYTE.b	%11100000
   1102  2691		       80		      BYTE.b	%10000000
   1103  2692		       fc		      BYTE.b	%11111100
   1104  2693		       fc		      BYTE.b	%11111100
   1105  2694		       7c		      BYTE.b	%01111100
   1106  2695		       7c		      BYTE.b	%01111100
   1107  2696		       f8		      BYTE.b	%11111000
   1108  2697		       e0		      BYTE.b	%11100000
   1109  2698		       00		      BYTE.b	%00000000
   1110  2699		       00		      BYTE.b	%00000000
   1111  269a		       00		      BYTE.b	%00000000
   1112  269b		       00		      BYTE.b	%00000000
   1113  269c		       00		      BYTE.b	%00000000
   1114  269d		       00		      BYTE.b	%00000000
   1115  269e		       00		      BYTE.b	%00000000
   1116  269f		       00		      BYTE.b	%00000000
   1117  26a0		       00		      BYTE.b	%00000000
   1118  26a1		       00		      BYTE.b	%00000000
   1119  26a2		       00		      BYTE.b	%00000000
   1120  26a3		       00		      BYTE.b	%00000000
   1121  26a4		       00		      BYTE.b	%00000000
   1122  26a5		       00		      BYTE.b	%00000000
   1123  26a6		       00		      BYTE.b	%00000000
   1124  26a7		       00		      BYTE.b	%00000000
   1125  26a8		       00		      BYTE.b	%00000000
   1126  26a9		       00		      BYTE.b	%00000000
   1127  26aa
   1128  26aa				  -	      if	>. != >[.+(bmp_96x2_1_height)]
   1129  26aa				  -	      align	256
   1130  26aa					      endif
   1131  26aa
   1132  26aa
   1133  26aa				   bmp_96x2_1_11
   1134  26aa							; *** replace this block with your bimap_11 data block...
   1135  26aa		       00		      BYTE.b	%00000000
   1136  26ab		       00		      BYTE.b	%00000000
   1137  26ac		       00		      BYTE.b	%00000000
   1138  26ad		       00		      BYTE.b	%00000000
   1139  26ae		       00		      BYTE.b	%00000000
   1140  26af		       00		      BYTE.b	%00000000
   1141  26b0		       00		      BYTE.b	%00000000
   1142  26b1		       00		      BYTE.b	%00000000
   1143  26b2		       00		      BYTE.b	%00000000
   1144  26b3		       00		      BYTE.b	%00000000
   1145  26b4		       00		      BYTE.b	%00000000
   1146  26b5		       00		      BYTE.b	%00000000
   1147  26b6		       00		      BYTE.b	%00000000
   1148  26b7		       00		      BYTE.b	%00000000
   1149  26b8		       00		      BYTE.b	%00000000
   1150  26b9		       00		      BYTE.b	%00000000
   1151  26ba		       00		      BYTE.b	%00000000
   1152  26bb		       00		      BYTE.b	%00000000
   1153  26bc		       00		      BYTE.b	%00000000
   1154  26bd		       00		      BYTE.b	%00000000
   1155  26be		       00		      BYTE.b	%00000000
   1156  26bf		       00		      BYTE.b	%00000000
   1157  26c0		       00		      BYTE.b	%00000000
   1158  26c1		       00		      BYTE.b	%00000000
   1159  26c2		       00		      BYTE.b	%00000000
   1160  26c3		       00		      BYTE.b	%00000000
   1161  26c4		       00		      BYTE.b	%00000000
   1162  26c5		       00		      BYTE.b	%00000000
   1163  26c6		       00		      BYTE.b	%00000000
   1164  26c7		       00		      BYTE.b	%00000000
   1165  26c8		       00		      BYTE.b	%00000000
   1166  26c9		       00		      BYTE.b	%00000000
   1167  26ca		       00		      BYTE.b	%00000000
   1168  26cb		       00		      BYTE.b	%00000000
   1169  26cc		       00		      BYTE.b	%00000000
   1170  26cd		       00		      BYTE.b	%00000000
   1171  26ce		       00		      BYTE.b	%00000000
   1172  26cf		       00		      BYTE.b	%00000000
   1173  26d0		       00		      BYTE.b	%00000000
   1174  26d1		       00		      BYTE.b	%00000000
   1175  26d2		       00		      BYTE.b	%00000000
   1176  26d3		       3e		      BYTE.b	%00111110
   1177  26d4		       3e		      BYTE.b	%00111110
   1178  26d5		       3e		      BYTE.b	%00111110
   1179  26d6		       fe		      BYTE.b	%11111110
   1180  26d7		       fe		      BYTE.b	%11111110
   1181  26d8		       3e		      BYTE.b	%00111110
   1182  26d9		       3e		      BYTE.b	%00111110
   1183  26da		       3e		      BYTE.b	%00111110
   1184  26db		       f8		      BYTE.b	%11111000
   1185  26dc		       f8		      BYTE.b	%11111000
   1186  26dd		       e0		      BYTE.b	%11100000
   1187  26de		       00		      BYTE.b	%00000000
   1188  26df		       00		      BYTE.b	%00000000
   1189  26e0		       00		      BYTE.b	%00000000
   1190  26e1		       00		      BYTE.b	%00000000
   1191  26e2		       00		      BYTE.b	%00000000
   1192  26e3		       00		      BYTE.b	%00000000
   1193  26e4		       00		      BYTE.b	%00000000
   1194  26e5		       00		      BYTE.b	%00000000
   1195  26e6		       00		      BYTE.b	%00000000
   1196  26e7		       00		      BYTE.b	%00000000
   1197  26e8		       00		      BYTE.b	%00000000
   1198  26e9		       00		      BYTE.b	%00000000
   1199  26ea		       00		      BYTE.b	%00000000
   1200  26eb		       00		      BYTE.b	%00000000
   1201  26ec		       00		      BYTE.b	%00000000
   1202  26ed		       00		      BYTE.b	%00000000
   1203  26ee		       00		      BYTE.b	%00000000
   1204  26ef		       00		      BYTE.b	%00000000
   1205  26f0		       00		      BYTE.b	%00000000
   1206  26f1		       00		      BYTE.b	%00000000
   1207  26f2		       00		      BYTE.b	%00000000
   1208  26f3		       00		      BYTE.b	%00000000
   1209  26f4		       00		      BYTE.b	%00000000
   1210  26f5		       00		      BYTE.b	%00000000
   1211  26f6		       00		      BYTE.b	%00000000
   1212  26f7		       00		      BYTE.b	%00000000
   1213  26f8		       00		      BYTE.b	%00000000
   1214  26f9		       00		      BYTE.b	%00000000
   1215  26fa		       00		      BYTE.b	%00000000
   1216  26fb		       00		      BYTE.b	%00000000
   1217  26fc		       00		      BYTE.b	%00000000
   1218  26fd		       00		      BYTE.b	%00000000
   1219  26fe		       00		      BYTE.b	%00000000
------- FILE titlescreen/asm/titlescreen_pal.asm
    125  26ff					      endif
    126  26ff				  -	      ifconst	mk_96x2_2_on
    127  26ff				  -	      include	"titlescreen/96x2_2_image.asm"
    128  26ff					      endif
    129  26ff				  -	      ifconst	mk_96x2_3_on
    130  26ff				  -	      include	"titlescreen/96x2_3_image.asm"
    131  26ff					      endif
    132  26ff				  -	      ifconst	mk_96x2_4_on
    133  26ff				  -	      include	"titlescreen/96x2_4_image.asm"
    134  26ff					      endif
    135  26ff				  -	      ifconst	mk_96x2_5_on
    136  26ff				  -	      include	"titlescreen/96x2_5_image.asm"
    137  26ff					      endif
    138  26ff				  -	      ifconst	mk_96x2_6_on
    139  26ff				  -	      include	"titlescreen/96x2_6_image.asm"
    140  26ff					      endif
    141  26ff				  -	      ifconst	mk_96x2_7_on
    142  26ff				  -	      include	"titlescreen/96x2_7_image.asm"
    143  26ff					      endif
    144  26ff				  -	      ifconst	mk_96x2_8_on
    145  26ff				  -	      include	"titlescreen/96x2_8_image.asm"
    146  26ff					      endif
    147  26ff
    148  26ff				  -	      ifconst	mk_player_on
    149  26ff				  -	      include	"titlescreen/player_image.asm"
    150  26ff					      endif
    151  26ff
    152  26ff				  -	      ifconst	mk_score_on
    153  26ff				  -	      include	"titlescreen/score_image.asm"
    154  26ff					      endif
    155  26ff
    156  26ff				  -	      ifconst	mk_gameselect_on
    157  26ff				  -	      include	"titlescreen/gameselect_image.asm"
    158  26ff					      endif
    159  26ff
    160  26ff				  -	      ifconst	mk_player_on
    161  26ff				  -	      include	"titlescreen/asm/player_kernel.asm"
    162  26ff					      endif		;mk_player_on
    163  26ff
    164  26ff
------- FILE beer_mania_PAL.bas.asm
    929  26ff
    930  26ff				   .
    931  26ff							;
    932  26ff
    933  26ff				   .L093		;  bank 3
    934  26ff
    935  26ff					      if	ECHO2
      2261 bytes of ROM space left in bank 2
    936  26ff					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
    937  26ff					      endif
    938  26ff		       00 01	   ECHO2      =	1
    939  2fd4					      ORG	$2FF4-bscode_length
    940  2fd4					      RORG	$BFF4-bscode_length
    941  2fd4		       a2 ff	   start_bank2 ldx	#$ff
    942  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
    943  2fd6				  -	      stx	FASTFETCH
    944  2fd6					      endif
    945  2fd6		       9a		      txs
    946  2fd7				  -	      if	bankswitch == 64
    947  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
    948  2fd7					      else
    949  2fd7		       a9 f2		      lda	#>(start-1)
    950  2fd9					      endif
    951  2fd9		       48		      pha
    952  2fda		       a9 51		      lda	#<(start-1)
    953  2fdc		       48		      pha
    954  2fdd		       48		      pha
    955  2fde		       8a		      txa
    956  2fdf		       48		      pha
    957  2fe0		       ba		      tsx
    958  2fe1					      if	bankswitch != 64
    959  2fe1		       b5 04		      lda	4,x	; get high byte of return address
    960  2fe3		       2a		      rol
    961  2fe4		       2a		      rol
    962  2fe5		       2a		      rol
    963  2fe6		       2a		      rol
    964  2fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
    965  2fe9		       aa		      tax
    966  2fea		       e8		      inx
    967  2feb				  -	      else
    968  2feb				  -	      lda	4,x	; get high byte of return address
    969  2feb				  -	      tay
    970  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
    971  2feb				  -	      sta	4,x
    972  2feb				  -	      tya
    973  2feb				  -	      lsr
    974  2feb				  -	      lsr
    975  2feb				  -	      lsr
    976  2feb				  -	      lsr
    977  2feb				  -	      tax
    978  2feb				  -	      inx
    979  2feb					      endif
    980  2feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
    981  2fee		       68		      pla
    982  2fef		       aa		      tax
    983  2ff0		       68		      pla
    984  2ff1		       60		      rts
    985  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
    986  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
    987  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
    988  2ff2					      endif
    989  2ffc					      ORG	$2FFC
    990  2ffc					      RORG	$BFFC
    991  2ffc		       d4 bf		      .word.w	(start_bank2 & $ffff)
    992  2ffe		       d4 bf		      .word.w	(start_bank2 & $ffff)
    993  3000					      ORG	$3000
    994  3000					      RORG	$D000
    995  3000				   .__Game_Over_Setup
    996  3000							; __Game_Over_Setup
    997  3000
    998  3000				   .L094		;  player0y  =  200 :	player1y  =  200
    999  3000
   1000  3000		       a9 c8		      LDA	#200
   1001  3002		       85 85		      STA	player0y
   1002  3004		       85 86		      STA	player1y
   1003  3006				   .
   1004  3006							;
   1005  3006
   1006  3006				   .L095		;  playfield:
   1007  3006
   1008  3006				  -	      ifconst	pfres
   1009  3006				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   1010  3006					      else
   1011  3006		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   1012  3008					      endif
   1013  3008		       4c 37 d0 	      jmp	pflabel1
   1014  300b				   PF_data1
   1015  300b		       7e bf		      .byte.b	%01111110, %10111111
   1016  300d					      if	(pfwidth>2)
   1017  300d		       ff 7d		      .byte.b	%11111111, %01111101
   1018  300f					      endif
   1019  300f		       60 b3		      .byte.b	%01100000, %10110011
   1020  3011					      if	(pfwidth>2)
   1021  3011		       99 0d		      .byte.b	%10011001, %00001101
   1022  3013					      endif
   1023  3013		       6e bf		      .byte.b	%01101110, %10111111
   1024  3015					      if	(pfwidth>2)
   1025  3015		       99 3d		      .byte.b	%10011001, %00111101
   1026  3017					      endif
   1027  3017		       66 b3		      .byte.b	%01100110, %10110011
   1028  3019					      if	(pfwidth>2)
   1029  3019		       99 0d		      .byte.b	%10011001, %00001101
   1030  301b					      endif
   1031  301b		       7e b3		      .byte.b	%01111110, %10110011
   1032  301d					      if	(pfwidth>2)
   1033  301d		       99 7d		      .byte.b	%10011001, %01111101
   1034  301f					      endif
   1035  301f		       00 00		      .byte.b	%00000000, %00000000
   1036  3021					      if	(pfwidth>2)
   1037  3021		       00 00		      .byte.b	%00000000, %00000000
   1038  3023					      endif
   1039  3023		       1f cd		      .byte.b	%00011111, %11001101
   1040  3025					      if	(pfwidth>2)
   1041  3025		       7d 1f		      .byte.b	%01111101, %00011111
   1042  3027					      endif
   1043  3027		       19 cd		      .byte.b	%00011001, %11001101
   1044  3029					      if	(pfwidth>2)
   1045  3029		       61 19		      .byte.b	%01100001, %00011001
   1046  302b					      endif
   1047  302b		       19 cd		      .byte.b	%00011001, %11001101
   1048  302d					      if	(pfwidth>2)
   1049  302d		       79 0f		      .byte.b	%01111001, %00001111
   1050  302f					      endif
   1051  302f		       19 cd		      .byte.b	%00011001, %11001101
   1052  3031					      if	(pfwidth>2)
   1053  3031		       61 19		      .byte.b	%01100001, %00011001
   1054  3033					      endif
   1055  3033		       1f 31		      .byte.b	%00011111, %00110001
   1056  3035					      if	(pfwidth>2)
   1057  3035		       7d 19		      .byte.b	%01111101, %00011001
   1058  3037					      endif
   1059  3037				   pflabel1
   1060  3037		       bd 0b d0 	      lda	PF_data1,x
   1061  303a		       95 a4		      sta	playfield,x
   1062  303c		       ca		      dex
   1063  303d		       10 f8		      bpl	pflabel1
   1064  303f				   .
   1065  303f							;
   1066  303f
   1067  303f				   .pfcolors
   1068  303f							; pfcolors:
   1069  303f
   1070  303f				   .$9C
   1071  303f							; $9C
   1072  303f
   1073  303f				   .$9C
   1074  303f							; $9C
   1075  303f
   1076  303f				   .$9C
   1077  303f							; $9C
   1078  303f
   1079  303f				   .$9C
   1080  303f							; $9C
   1081  303f
   1082  303f				   .$9C
   1083  303f							; $9C
   1084  303f
   1085  303f				   .$9C
   1086  303f							; $9C
   1087  303f
   1088  303f				   .$9C
   1089  303f							; $9C
   1090  303f
   1091  303f				   .$9C
   1092  303f							; $9C
   1093  303f
   1094  303f				   .$9C
   1095  303f							; $9C
   1096  303f
   1097  303f				   .$9C
   1098  303f							; $9C
   1099  303f
   1100  303f				   .$9C
   1101  303f							; $9C
   1102  303f
   1103  303f				   .
   1104  303f							;
   1105  303f
   1106  303f				   .gameover_loop
   1107  303f							; gameover_loop
   1108  303f
   1109  303f				   .L096		;  drawscreen
   1110  303f
   1111  303f		       85 ee		      sta	temp7
   1112  3041		       a9 d0		      lda	#>(ret_point4-1)
   1113  3043		       48		      pha
   1114  3044		       a9 56		      lda	#<(ret_point4-1)
   1115  3046		       48		      pha
   1116  3047		       a9 f4		      lda	#>(drawscreen-1)
   1117  3049		       48		      pha
   1118  304a		       a9 3b		      lda	#<(drawscreen-1)
   1119  304c		       48		      pha
   1120  304d		       a5 ee		      lda	temp7
   1121  304f		       48		      pha
   1122  3050		       8a		      txa
   1123  3051		       48		      pha
   1124  3052		       a2 04		      ldx	#4
   1125  3054		       4c eb ff 	      jmp	BS_jsr
   1126  3057				   ret_point4
   1127  3057				   .L097		;  if joy0fire  ||  switchreset then goto gamestart
   1128  3057
   1129  3057		       24 0c		      bit	INPT4
   1130  3059		       30 03		      BMI	.skipL097
   1131  305b				   .condpart28
   1132  305b		       4c 65 d0 	      jmp	.condpart29
   1133  305e				   .skipL097
   1134  305e		       a9 01		      lda	#1
   1135  3060		       2c 82 02 	      bit	SWCHB
   1136  3063		       d0 03		      BNE	.skip2OR
   1137  3065				   .condpart29
   1138  3065		       4c b0 90 	      jmp	.gamestart
   1139  3068
   1140  3068				   .skip2OR
   1141  3068				   .L098		;  goto gameover_loop
   1142  3068		       4c 3f d0 	      jmp	.gameover_loop
   1143  306b					      if	ECHO3
      3945 bytes of ROM space left in bank 3
   1144  306b					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   1145  306b					      endif
   1146  306b		       00 01	   ECHO3      =	1
   1147  3fd4					      ORG	$3FF4-bscode_length
   1148  3fd4					      RORG	$DFF4-bscode_length
   1149  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   1150  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1151  3fd6				  -	      stx	FASTFETCH
   1152  3fd6					      endif
   1153  3fd6		       9a		      txs
   1154  3fd7				  -	      if	bankswitch == 64
   1155  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1156  3fd7					      else
   1157  3fd7		       a9 f2		      lda	#>(start-1)
   1158  3fd9					      endif
   1159  3fd9		       48		      pha
   1160  3fda		       a9 51		      lda	#<(start-1)
   1161  3fdc		       48		      pha
   1162  3fdd		       48		      pha
   1163  3fde		       8a		      txa
   1164  3fdf		       48		      pha
   1165  3fe0		       ba		      tsx
   1166  3fe1					      if	bankswitch != 64
   1167  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   1168  3fe3		       2a		      rol
   1169  3fe4		       2a		      rol
   1170  3fe5		       2a		      rol
   1171  3fe6		       2a		      rol
   1172  3fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1173  3fe9		       aa		      tax
   1174  3fea		       e8		      inx
   1175  3feb				  -	      else
   1176  3feb				  -	      lda	4,x	; get high byte of return address
   1177  3feb				  -	      tay
   1178  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1179  3feb				  -	      sta	4,x
   1180  3feb				  -	      tya
   1181  3feb				  -	      lsr
   1182  3feb				  -	      lsr
   1183  3feb				  -	      lsr
   1184  3feb				  -	      lsr
   1185  3feb				  -	      tax
   1186  3feb				  -	      inx
   1187  3feb					      endif
   1188  3feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1189  3fee		       68		      pla
   1190  3fef		       aa		      tax
   1191  3ff0		       68		      pla
   1192  3ff1		       60		      rts
   1193  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1194  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1195  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1196  3ff2					      endif
   1197  3ffc					      ORG	$3FFC
   1198  3ffc					      RORG	$DFFC
   1199  3ffc		       d4 df		      .word.w	(start_bank3 & $ffff)
   1200  3ffe		       d4 df		      .word.w	(start_bank3 & $ffff)
   1201  4000					      ORG	$4000
   1202  4000					      RORG	$F000
   1203  4000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1204  4000
   1205  4000							; This is a 2-line kernel!
   1206  4000					      ifnconst	vertical_reflect
   1207  4000				   kernel
   1208  4000					      endif
   1209  4000		       85 02		      sta	WSYNC
   1210  4002		       a9 ff		      lda	#255
   1211  4004		       8d 96 02 	      sta	TIM64T
   1212  4007
   1213  4007		       a9 01		      lda	#1
   1214  4009		       85 27		      sta	VDELBL
   1215  400b		       85 25		      sta	VDELP0
   1216  400d		       a6 92		      ldx	ballheight
   1217  400f		       e8		      inx
   1218  4010		       e8		      inx
   1219  4011		       86 9f		      stx	temp4
   1220  4013		       a5 86		      lda	player1y
   1221  4015		       85 9e		      sta	temp3
   1222  4017
   1223  4017				  -	      ifconst	shakescreen
   1224  4017				  -	      jsr	doshakescreen
   1225  4017					      else
   1226  4017		       a6 90		      ldx	missile0height
   1227  4019		       e8		      inx
   1228  401a					      endif
   1229  401a
   1230  401a		       e8		      inx
   1231  401b		       86 f6		      stx	stack1
   1232  401d
   1233  401d		       a5 89		      lda	bally
   1234  401f		       85 f7		      sta	stack2
   1235  4021
   1236  4021		       a5 85		      lda	player0y
   1237  4023		       a2 00		      ldx	#0
   1238  4025		       85 02		      sta	WSYNC
   1239  4027		       86 1b		      stx	GRP0
   1240  4029		       86 1c		      stx	GRP1
   1241  402b		       86 0e		      stx	PF1L
   1242  402d		       86 0f		      stx	PF2
   1243  402f		       86 2c		      stx	CXCLR
   1244  4031				  -	      ifconst	readpaddle
   1245  4031				  -	      stx	paddle
   1246  4031					      else
      0  4031					      sleep	3
      1  4031				   .CYCLES    SET	3
      2  4031
      3  4031				  -	      IF	.CYCLES < 2
      4  4031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4031				  -	      ERR
      6  4031					      ENDIF
      7  4031
      8  4031					      IF	.CYCLES & 1
      9  4031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4031		       04 00		      nop	0
     11  4033				  -	      ELSE
     12  4033				  -	      bit	VSYNC
     13  4033					      ENDIF
     14  4033				   .CYCLES    SET	.CYCLES - 3
     15  4033					      ENDIF
     16  4033
     17  4033				  -	      REPEAT	.CYCLES / 2
     18  4033				  -	      nop
     19  4033					      REPEND
   1248  4033					      endif
   1249  4033
   1250  4033		       95 9d		      sta	temp2,x
   1251  4035
   1252  4035							;store these so they can be retrieved later
   1253  4035					      ifnconst	pfres
   1254  4035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   1255  4037				  -	      else
   1256  4037				  -	      ldx	#132-pfres*pfwidth
   1257  4037					      endif
   1258  4037
   1259  4037		       c6 85		      dec	player0y
   1260  4039
   1261  4039		       a5 91		      lda	missile0y
   1262  403b		       85 a0		      sta	temp5
   1263  403d		       a5 88		      lda	missile1y
   1264  403f		       85 a1		      sta	temp6
   1265  4041
   1266  4041		       a5 ef		      lda	playfieldpos
   1267  4043		       85 9c		      sta	temp1
   1268  4045
   1269  4045				  -	      ifconst	pfrowheight
   1270  4045				  -	      lda	#pfrowheight+2
   1271  4045					      else
   1272  4045					      ifnconst	pfres
   1273  4045		       a9 0a		      lda	#10
   1274  4047				  -	      else
   1275  4047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1276  4047					      endif
   1277  4047					      endif
   1278  4047		       18		      clc
   1279  4048		       e5 ef		      sbc	playfieldpos
   1280  404a		       85 ef		      sta	playfieldpos
   1281  404c		       4c 74 f0 	      jmp	.startkernel
   1282  404f
   1283  404f				   .skipDrawP0
   1284  404f		       a9 00		      lda	#0
   1285  4051		       a8		      tay
   1286  4052		       4c a2 f0 	      jmp	.continueP0
   1287  4055
   1288  4055				   .skipDrawP1
   1289  4055		       a9 00		      lda	#0
   1290  4057		       a8		      tay
   1291  4058		       4c 7e f0 	      jmp	.continueP1
   1292  405b
   1293  405b				   .kerloop		; enter at cycle 59??
   1294  405b
   1295  405b				   continuekernel
      0  405b					      sleep	2
      1  405b				   .CYCLES    SET	2
      2  405b
      3  405b				  -	      IF	.CYCLES < 2
      4  405b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  405b				  -	      ERR
      6  405b					      ENDIF
      7  405b
      8  405b				  -	      IF	.CYCLES & 1
      9  405b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  405b				  -	      nop	0
     11  405b				  -	      ELSE
     12  405b				  -	      bit	VSYNC
     13  405b				  -	      ENDIF
     14  405b				  -.CYCLES    SET	.CYCLES - 3
     15  405b					      ENDIF
     16  405b
     17  405b					      REPEAT	.CYCLES / 2
     18  405b		       ea		      nop
     19  405c					      REPEND
   1297  405c				   continuekernel2
   1298  405c		       a5 92		      lda	ballheight
   1299  405e
   1300  405e				  -	      ifconst	pfres
   1301  405e				  -	      ldy	playfield+pfres*pfwidth-132,x
   1302  405e				  -	      sty	PF1L	;3
   1303  405e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   1304  405e				  -	      sty	PF2L	;3
   1305  405e				  -	      ldy	playfield+pfres*pfwidth-129,x
   1306  405e				  -	      sty	PF1R	; 3 too early?
   1307  405e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   1308  405e				  -	      sty	PF2R	;3
   1309  405e					      else
   1310  405e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   1311  4060		       84 0e		      sty	PF1L	;3
   1312  4062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1313  4064		       84 0f		      sty	PF2L	;3
   1314  4066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   1315  4068		       84 0e		      sty	PF1R	; 3 too early?
   1316  406a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1317  406c		       84 0f		      sty	PF2R	;3
   1318  406e					      endif
   1319  406e
   1320  406e							; should be playfield+$38 for width=2
   1321  406e
   1322  406e		       c7 89		      dcp	bally
   1323  4070		       2a		      rol
   1324  4071		       2a		      rol
   1325  4072							; rol
   1326  4072							; rol
   1327  4072				   goback
   1328  4072		       85 1f		      sta	ENABL
   1329  4074				   .startkernel
   1330  4074		       a5 8f		      lda	player1height	;3
   1331  4076		       c7 86		      dcp	player1y	;5
   1332  4078		       90 db		      bcc	.skipDrawP1	;2
   1333  407a		       a4 86		      ldy	player1y	;3
   1334  407c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1335  407e							; so it doesn't cross a page boundary!
   1336  407e
   1337  407e				   .continueP1
   1338  407e		       85 1c		      sta	GRP1	;3
   1339  4080
   1340  4080				  -	      ifnconst	player1colors
   1341  4080				  -	      lda	missile1height	;3
   1342  4080				  -	      dcp	missile1y	;5
   1343  4080				  -	      rol		;2
   1344  4080				  -	      rol		;2
   1345  4080				  -	      sta	ENAM1	;3
   1346  4080					      else
   1347  4080		       b1 87		      lda	(player1color),y
   1348  4082		       85 07		      sta	COLUP1
   1349  4084					      ifnconst	playercolors
      0  4084					      sleep	7
      1  4084				   .CYCLES    SET	7
      2  4084
      3  4084				  -	      IF	.CYCLES < 2
      4  4084				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4084				  -	      ERR
      6  4084					      ENDIF
      7  4084
      8  4084					      IF	.CYCLES & 1
      9  4084					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4084		       04 00		      nop	0
     11  4086				  -	      ELSE
     12  4086				  -	      bit	VSYNC
     13  4086					      ENDIF
     14  4086				   .CYCLES    SET	.CYCLES - 3
     15  4086					      ENDIF
     16  4086
     17  4086					      REPEAT	.CYCLES / 2
     18  4086		       ea		      nop
     17  4086					      REPEND
     18  4087		       ea		      nop
     19  4088					      REPEND
   1351  4088				  -	      else
   1352  4088				  -	      lda.w	player0colorstore
   1353  4088				  -	      sta	COLUP0
   1354  4088					      endif
   1355  4088					      endif
   1356  4088
   1357  4088				  -	      ifconst	pfres
   1358  4088				  -	      lda	playfield+pfres*pfwidth-132,x
   1359  4088				  -	      sta	PF1L	;3
   1360  4088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   1361  4088				  -	      sta	PF2L	;3
   1362  4088				  -	      lda	playfield+pfres*pfwidth-129,x
   1363  4088				  -	      sta	PF1R	; 3 too early?
   1364  4088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   1365  4088				  -	      sta	PF2R	;3
   1366  4088					      else
   1367  4088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   1368  408a		       85 0e		      sta	PF1L	;3
   1369  408c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1370  408e		       85 0f		      sta	PF2L	;3
   1371  4090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   1372  4092		       85 0e		      sta	PF1R	; 3 too early?
   1373  4094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1374  4096		       85 0f		      sta	PF2R	;3
   1375  4098					      endif
   1376  4098							; sleep 3
   1377  4098
   1378  4098		       a5 8e		      lda	player0height
   1379  409a		       c7 85		      dcp	player0y
   1380  409c		       90 b1		      bcc	.skipDrawP0
   1381  409e		       a4 85		      ldy	player0y
   1382  40a0		       b1 8a		      lda	(player0pointer),y
   1383  40a2				   .continueP0
   1384  40a2		       85 1b		      sta	GRP0
   1385  40a4
   1386  40a4				  -	      ifnconst	no_blank_lines
   1387  40a4				  -	      ifnconst	playercolors
   1388  40a4				  -	      lda	missile0height	;3
   1389  40a4				  -	      dcp	missile0y	;5
   1390  40a4				  -	      sbc	stack1
   1391  40a4				  -	      sta	ENAM0	;3
   1392  40a4				  -	      else
   1393  40a4				  -	      lda	(player0color),y
   1394  40a4				  -	      sta	player0colorstore
   1395  40a4				  -	      sleep	6
   1396  40a4				  -	      endif
   1397  40a4				  -	      dec	temp1
   1398  40a4				  -	      bne	continuekernel
   1399  40a4					      else
   1400  40a4		       c6 9c		      dec	temp1
   1401  40a6		       f0 0c		      beq	altkernel2
   1402  40a8				  -	      ifconst	readpaddle
   1403  40a8				  -	      ldy	currentpaddle
   1404  40a8				  -	      lda	INPT0,y
   1405  40a8				  -	      bpl	noreadpaddle
   1406  40a8				  -	      inc	paddle
   1407  40a8				  -	      jmp	continuekernel2
   1408  40a8				  -noreadpaddle
   1409  40a8				  -	      sleep	2
   1410  40a8				  -	      jmp	continuekernel
   1411  40a8					      else
   1412  40a8					      ifnconst	playercolors
   1413  40a8					      ifconst	PFcolors
   1414  40a8		       8a		      txa
   1415  40a9		       a8		      tay
   1416  40aa		       b1 f0		      lda	(pfcolortable),y
   1417  40ac					      ifnconst	backgroundchange
   1418  40ac		       85 08		      sta	COLUPF
   1419  40ae				  -	      else
   1420  40ae				  -	      sta	COLUBK
   1421  40ae					      endif
   1422  40ae		       4c 5b f0 	      jmp	continuekernel
   1423  40b1				  -	      else
   1424  40b1				  -	      ifconst	kernelmacrodef
   1425  40b1				  -	      kernelmacro
   1426  40b1				  -	      else
   1427  40b1				  -	      sleep	12
   1428  40b1				  -	      endif
   1429  40b1					      endif
   1430  40b1				  -	      else
   1431  40b1				  -	      lda	(player0color),y
   1432  40b1				  -	      sta	player0colorstore
   1433  40b1				  -	      sleep	4
   1434  40b1					      endif
   1435  40b1		       4c 5b f0 	      jmp	continuekernel
   1436  40b4					      endif
   1437  40b4				   altkernel2
   1438  40b4		       8a		      txa
   1439  40b5					      ifnconst	vertical_reflect
   1440  40b5		       cb fc		      sbx	#256-pfwidth
   1441  40b7				  -	      else
   1442  40b7				  -	      sbx	#256-pfwidth/2
   1443  40b7					      endif
   1444  40b7		       30 24		      bmi	lastkernelline
   1445  40b9				  -	      ifconst	pfrowheight
   1446  40b9				  -	      lda	#pfrowheight
   1447  40b9					      else
   1448  40b9					      ifnconst	pfres
   1449  40b9		       a9 08		      lda	#8
   1450  40bb				  -	      else
   1451  40bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   1452  40bb					      endif
   1453  40bb					      endif
   1454  40bb		       85 9c		      sta	temp1
   1455  40bd		       4c 5b f0 	      jmp	continuekernel
   1456  40c0					      endif
   1457  40c0
   1458  40c0				   altkernel
   1459  40c0
   1460  40c0				  -	      ifconst	PFmaskvalue
   1461  40c0				  -	      lda	#PFmaskvalue
   1462  40c0					      else
   1463  40c0		       a9 00		      lda	#0
   1464  40c2					      endif
   1465  40c2		       85 0e		      sta	PF1L
   1466  40c4		       85 0f		      sta	PF2
   1467  40c6
   1468  40c6
   1469  40c6							;sleep 3
   1470  40c6
   1471  40c6							;28 cycles to fix things
   1472  40c6							;minus 11=17
   1473  40c6
   1474  40c6							; lax temp4
   1475  40c6							; clc
   1476  40c6		       8a		      txa
   1477  40c7					      ifnconst	vertical_reflect
   1478  40c7		       cb fc		      sbx	#256-pfwidth
   1479  40c9				  -	      else
   1480  40c9				  -	      sbx	#256-pfwidth/2
   1481  40c9					      endif
   1482  40c9
   1483  40c9		       30 12		      bmi	lastkernelline
   1484  40cb
   1485  40cb				  -	      ifconst	PFcolorandheight
   1486  40cb				  -	      ifconst	pfres
   1487  40cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   1488  40cb				  -	      else
   1489  40cb				  -	      ldy	playfieldcolorandheight-87,x
   1490  40cb				  -	      endif
   1491  40cb				  -	      ifnconst	backgroundchange
   1492  40cb				  -	      sty	COLUPF
   1493  40cb				  -	      else
   1494  40cb				  -	      sty	COLUBK
   1495  40cb				  -	      endif
   1496  40cb				  -	      ifconst	pfres
   1497  40cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   1498  40cb				  -	      else
   1499  40cb				  -	      lda	playfieldcolorandheight-88,x
   1500  40cb				  -	      endif
   1501  40cb				  -	      sta.w	temp1
   1502  40cb					      endif
   1503  40cb				  -	      ifconst	PFheights
   1504  40cb				  -	      lsr
   1505  40cb				  -	      lsr
   1506  40cb				  -	      tay
   1507  40cb				  -	      lda	(pfheighttable),y
   1508  40cb				  -	      sta.w	temp1
   1509  40cb					      endif
   1510  40cb					      ifconst	PFcolors
   1511  40cb		       a8		      tay
   1512  40cc		       b1 f0		      lda	(pfcolortable),y
   1513  40ce					      ifnconst	backgroundchange
   1514  40ce		       85 08		      sta	COLUPF
   1515  40d0				  -	      else
   1516  40d0				  -	      sta	COLUBK
   1517  40d0					      endif
   1518  40d0				  -	      ifconst	pfrowheight
   1519  40d0				  -	      lda	#pfrowheight
   1520  40d0					      else
   1521  40d0					      ifnconst	pfres
   1522  40d0		       a9 08		      lda	#8
   1523  40d2				  -	      else
   1524  40d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   1525  40d2					      endif
   1526  40d2					      endif
   1527  40d2		       85 9c		      sta	temp1
   1528  40d4					      endif
   1529  40d4					      ifnconst	PFcolorandheight
   1530  40d4				  -	      ifnconst	PFcolors
   1531  40d4				  -	      ifnconst	PFheights
   1532  40d4				  -	      ifnconst	no_blank_lines
   1533  40d4				  -			; read paddle 0
   1534  40d4				  -			; lo-res paddle read
   1535  40d4				  -			; bit INPT0
   1536  40d4				  -			; bmi paddleskipread
   1537  40d4				  -			; inc paddle0
   1538  40d4				  -			;donepaddleskip
   1539  40d4				  -	      sleep	10
   1540  40d4				  -	      ifconst	pfrowheight
   1541  40d4				  -	      lda	#pfrowheight
   1542  40d4				  -	      else
   1543  40d4				  -	      ifnconst	pfres
   1544  40d4				  -	      lda	#8
   1545  40d4				  -	      else
   1546  40d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   1547  40d4				  -	      endif
   1548  40d4				  -	      endif
   1549  40d4				  -	      sta	temp1
   1550  40d4				  -	      endif
   1551  40d4				  -	      endif
   1552  40d4					      endif
   1553  40d4					      endif
   1554  40d4
   1555  40d4
   1556  40d4		       a5 92		      lda	ballheight
   1557  40d6		       c7 89		      dcp	bally
   1558  40d8		       e5 9f		      sbc	temp4
   1559  40da
   1560  40da
   1561  40da		       4c 72 f0 	      jmp	goback
   1562  40dd
   1563  40dd
   1564  40dd				  -	      ifnconst	no_blank_lines
   1565  40dd				  -lastkernelline
   1566  40dd				  -	      ifnconst	PFcolors
   1567  40dd				  -	      sleep	10
   1568  40dd				  -	      else
   1569  40dd				  -	      ldy	#124
   1570  40dd				  -	      lda	(pfcolortable),y
   1571  40dd				  -	      sta	COLUPF
   1572  40dd				  -	      endif
   1573  40dd				  -
   1574  40dd				  -	      ifconst	PFheights
   1575  40dd				  -	      ldx	#1
   1576  40dd				  -			;sleep 4
   1577  40dd				  -	      sleep	3	; this was over 1 cycle
   1578  40dd				  -	      else
   1579  40dd				  -	      ldx	playfieldpos
   1580  40dd				  -			;sleep 3
   1581  40dd				  -	      sleep	2	; this was over 1 cycle
   1582  40dd				  -	      endif
   1583  40dd				  -
   1584  40dd				  -	      jmp	enterlastkernel
   1585  40dd				  -
   1586  40dd					      else
   1587  40dd				   lastkernelline
   1588  40dd
   1589  40dd				  -	      ifconst	PFheights
   1590  40dd				  -	      ldx	#1
   1591  40dd				  -			;sleep 5
   1592  40dd				  -	      sleep	4	; this was over 1 cycle
   1593  40dd					      else
   1594  40dd		       a6 ef		      ldx	playfieldpos
   1595  40df							;sleep 4
      0  40df					      sleep	3	; this was over 1 cycle
      1  40df				   .CYCLES    SET	3
      2  40df
      3  40df				  -	      IF	.CYCLES < 2
      4  40df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  40df				  -	      ERR
      6  40df					      ENDIF
      7  40df
      8  40df					      IF	.CYCLES & 1
      9  40df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  40df		       04 00		      nop	0
     11  40e1				  -	      ELSE
     12  40e1				  -	      bit	VSYNC
     13  40e1					      ENDIF
     14  40e1				   .CYCLES    SET	.CYCLES - 3
     15  40e1					      ENDIF
     16  40e1
     17  40e1				  -	      REPEAT	.CYCLES / 2
     18  40e1				  -	      nop
     19  40e1					      REPEND
   1597  40e1					      endif
   1598  40e1
   1599  40e1		       e0 00		      cpx	#0
   1600  40e3		       d0 22		      bne	.enterfromNBL
   1601  40e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   1602  40e8					      endif
   1603  40e8
   1604  40e8					      if	((<*)>$d5)
   1605  4100		       00 00 00 00*	      align	256
   1606  4100					      endif
   1607  4100							; this is a kludge to prevent page wrapping - fix!!!
   1608  4100
   1609  4100				   .skipDrawlastP1
   1610  4100		       a9 00		      lda	#0
   1611  4102		       a8		      tay		; added so we don't cross a page
   1612  4103		       4c 2d f1 	      jmp	.continuelastP1
   1613  4106
   1614  4106				   .endkerloop		; enter at cycle 59??
   1615  4106
   1616  4106		       ea		      nop
   1617  4107
   1618  4107				   .enterfromNBL
   1619  4107				  -	      ifconst	pfres
   1620  4107				  -	      ldy.w	playfield+pfres*pfwidth-4
   1621  4107				  -	      sty	PF1L	;3
   1622  4107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1623  4107				  -	      sty	PF2L	;3
   1624  4107				  -	      ldy.w	playfield+pfres*pfwidth-1
   1625  4107				  -	      sty	PF1R	; possibly too early?
   1626  4107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1627  4107				  -	      sty	PF2R	;3
   1628  4107					      else
   1629  4107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1630  410a		       84 0e		      sty	PF1L	;3
   1631  410c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1632  410f		       84 0f		      sty	PF2L	;3
   1633  4111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1634  4114		       84 0e		      sty	PF1R	; possibly too early?
   1635  4116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1636  4119		       84 0f		      sty	PF2R	;3
   1637  411b					      endif
   1638  411b
   1639  411b				   enterlastkernel
   1640  411b		       a5 92		      lda	ballheight
   1641  411d
   1642  411d							; tya
   1643  411d		       c7 89		      dcp	bally
   1644  411f							; sleep 4
   1645  411f
   1646  411f							; sbc stack3
   1647  411f		       2a		      rol
   1648  4120		       2a		      rol
   1649  4121		       85 1f		      sta	ENABL
   1650  4123
   1651  4123		       a5 8f		      lda	player1height	;3
   1652  4125		       c7 86		      dcp	player1y	;5
   1653  4127		       90 d7		      bcc	.skipDrawlastP1
   1654  4129		       a4 86		      ldy	player1y	;3
   1655  412b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1656  412d							; so it doesn't cross a page boundary!
   1657  412d
   1658  412d				   .continuelastP1
   1659  412d		       85 1c		      sta	GRP1	;3
   1660  412f
   1661  412f				  -	      ifnconst	player1colors
   1662  412f				  -	      lda	missile1height	;3
   1663  412f				  -	      dcp	missile1y	;5
   1664  412f					      else
   1665  412f		       b1 87		      lda	(player1color),y
   1666  4131		       85 07		      sta	COLUP1
   1667  4133					      endif
   1668  4133
   1669  4133		       ca		      dex
   1670  4134							;dec temp4 ; might try putting this above PF writes
   1671  4134		       f0 34		      beq	endkernel
   1672  4136
   1673  4136
   1674  4136				  -	      ifconst	pfres
   1675  4136				  -	      ldy.w	playfield+pfres*pfwidth-4
   1676  4136				  -	      sty	PF1L	;3
   1677  4136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1678  4136				  -	      sty	PF2L	;3
   1679  4136				  -	      ldy.w	playfield+pfres*pfwidth-1
   1680  4136				  -	      sty	PF1R	; possibly too early?
   1681  4136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1682  4136				  -	      sty	PF2R	;3
   1683  4136					      else
   1684  4136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1685  4139		       84 0e		      sty	PF1L	;3
   1686  413b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1687  413e		       84 0f		      sty	PF2L	;3
   1688  4140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1689  4143		       84 0e		      sty	PF1R	; possibly too early?
   1690  4145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1691  4148		       84 0f		      sty	PF2R	;3
   1692  414a					      endif
   1693  414a
   1694  414a				  -	      ifnconst	player1colors
   1695  414a				  -	      rol		;2
   1696  414a				  -	      rol		;2
   1697  414a				  -	      sta	ENAM1	;3
   1698  414a					      else
   1699  414a					      ifnconst	playercolors
      0  414a					      sleep	7
      1  414a				   .CYCLES    SET	7
      2  414a
      3  414a				  -	      IF	.CYCLES < 2
      4  414a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  414a				  -	      ERR
      6  414a					      ENDIF
      7  414a
      8  414a					      IF	.CYCLES & 1
      9  414a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  414a		       04 00		      nop	0
     11  414c				  -	      ELSE
     12  414c				  -	      bit	VSYNC
     13  414c					      ENDIF
     14  414c				   .CYCLES    SET	.CYCLES - 3
     15  414c					      ENDIF
     16  414c
     17  414c					      REPEAT	.CYCLES / 2
     18  414c		       ea		      nop
     17  414c					      REPEND
     18  414d		       ea		      nop
     19  414e					      REPEND
   1701  414e				  -	      else
   1702  414e				  -	      lda.w	player0colorstore
   1703  414e				  -	      sta	COLUP0
   1704  414e					      endif
   1705  414e					      endif
   1706  414e
   1707  414e		       ad 8e 00 	      lda.w	player0height
   1708  4151		       c7 85		      dcp	player0y
   1709  4153		       90 0d		      bcc	.skipDrawlastP0
   1710  4155		       a4 85		      ldy	player0y
   1711  4157		       b1 8a		      lda	(player0pointer),y
   1712  4159				   .continuelastP0
   1713  4159		       85 1b		      sta	GRP0
   1714  415b
   1715  415b
   1716  415b
   1717  415b				  -	      ifnconst	no_blank_lines
   1718  415b				  -	      lda	missile0height	;3
   1719  415b				  -	      dcp	missile0y	;5
   1720  415b				  -	      sbc	stack1
   1721  415b				  -	      sta	ENAM0	;3
   1722  415b				  -	      jmp	.endkerloop
   1723  415b					      else
   1724  415b				  -	      ifconst	readpaddle
   1725  415b				  -	      ldy	currentpaddle
   1726  415b				  -	      lda	INPT0,y
   1727  415b				  -	      bpl	noreadpaddle2
   1728  415b				  -	      inc	paddle
   1729  415b				  -	      jmp	.endkerloop
   1730  415b				  -noreadpaddle2
   1731  415b				  -	      sleep	4
   1732  415b				  -	      jmp	.endkerloop
   1733  415b					      else		; no_blank_lines and no paddle reading
   1734  415b		       68		      pla
   1735  415c		       48		      pha		; 14 cycles in 4 bytes
   1736  415d		       68		      pla
   1737  415e		       48		      pha
   1738  415f							; sleep 14
   1739  415f		       4c 06 f1 	      jmp	.endkerloop
   1740  4162					      endif
   1741  4162					      endif
   1742  4162
   1743  4162
   1744  4162							; ifconst donepaddleskip
   1745  4162							;paddleskipread
   1746  4162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   1747  4162							; plus we get a lo-res paddle read
   1748  4162							; bmi donepaddleskip
   1749  4162							; endif
   1750  4162
   1751  4162				   .skipDrawlastP0
   1752  4162		       a9 00		      lda	#0
   1753  4164		       a8		      tay
   1754  4165		       4c 59 f1 	      jmp	.continuelastP0
   1755  4168
   1756  4168					      ifconst	no_blank_lines
   1757  4168				   no_blank_lines_bailout
   1758  4168		       a2 00		      ldx	#0
   1759  416a					      endif
   1760  416a
   1761  416a				   endkernel
   1762  416a							; 6 digit score routine
   1763  416a		       86 0e		      stx	PF1
   1764  416c		       86 0f		      stx	PF2
   1765  416e		       86 0d		      stx	PF0
   1766  4170		       18		      clc
   1767  4171
   1768  4171				  -	      ifconst	pfrowheight
   1769  4171				  -	      lda	#pfrowheight+2
   1770  4171					      else
   1771  4171					      ifnconst	pfres
   1772  4171		       a9 0a		      lda	#10
   1773  4173				  -	      else
   1774  4173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1775  4173					      endif
   1776  4173					      endif
   1777  4173
   1778  4173		       e5 ef		      sbc	playfieldpos
   1779  4175		       85 ef		      sta	playfieldpos
   1780  4177		       8a		      txa
   1781  4178
   1782  4178				  -	      ifconst	shakescreen
   1783  4178				  -	      bit	shakescreen
   1784  4178				  -	      bmi	noshakescreen2
   1785  4178				  -	      ldx	#$3D
   1786  4178				  -noshakescreen2
   1787  4178					      endif
   1788  4178
   1789  4178		       95 02		      sta	WSYNC,x
   1790  417a
   1791  417a							; STA WSYNC ;first one, need one more
   1792  417a		       85 0b		      sta	REFP0
   1793  417c		       85 0c		      sta	REFP1
   1794  417e		       85 1b		      STA	GRP0
   1795  4180		       85 1c		      STA	GRP1
   1796  4182							; STA PF1
   1797  4182							; STA PF2
   1798  4182		       85 2b		      sta	HMCLR
   1799  4184		       85 1d		      sta	ENAM0
   1800  4186		       85 1e		      sta	ENAM1
   1801  4188		       85 1f		      sta	ENABL
   1802  418a
   1803  418a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   1804  418c		       85 85		      sta	player0y
   1805  418e		       a5 9e		      lda	temp3
   1806  4190		       85 86		      sta	player1y
   1807  4192				  -	      ifnconst	player1colors
   1808  4192				  -	      lda	temp6
   1809  4192				  -	      sta	missile1y
   1810  4192					      endif
   1811  4192					      ifnconst	playercolors
   1812  4192					      ifnconst	readpaddle
   1813  4192		       a5 a0		      lda	temp5
   1814  4194		       85 91		      sta	missile0y
   1815  4196					      endif
   1816  4196					      endif
   1817  4196		       a5 f7		      lda	stack2
   1818  4198		       85 89		      sta	bally
   1819  419a
   1820  419a							; strangely, this isn't required any more. might have
   1821  419a							; resulted from the no_blank_lines score bounce fix
   1822  419a							;ifconst no_blank_lines
   1823  419a							;sta WSYNC
   1824  419a							;endif
   1825  419a
   1826  419a		       ad 84 02 	      lda	INTIM
   1827  419d		       18		      clc
   1828  419e				  -	      ifnconst	vblank_time
   1829  419e				  -	      adc	#43+12+87
   1830  419e					      else
   1831  419e		       69 9d		      adc	#vblank_time+12+87
   1832  41a0
   1833  41a0					      endif
   1834  41a0							; sta WSYNC
   1835  41a0		       8d 96 02 	      sta	TIM64T
   1836  41a3
   1837  41a3				  -	      ifconst	minikernel
   1838  41a3				  -	      jsr	minikernel
   1839  41a3					      endif
   1840  41a3
   1841  41a3							; now reassign temp vars for score pointers
   1842  41a3
   1843  41a3							; score pointers contain:
   1844  41a3							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   1845  41a3							; swap lo2->temp1
   1846  41a3							; swap lo4->temp3
   1847  41a3							; swap lo6->temp5
   1848  41a3					      ifnconst	noscore
   1849  41a3		       a5 97		      lda	scorepointers+1
   1850  41a5							; ldy temp1
   1851  41a5		       85 9c		      sta	temp1
   1852  41a7							; sty scorepointers+1
   1853  41a7
   1854  41a7		       a5 99		      lda	scorepointers+3
   1855  41a9							; ldy temp3
   1856  41a9		       85 9e		      sta	temp3
   1857  41ab							; sty scorepointers+3
   1858  41ab
   1859  41ab
   1860  41ab		       85 2b		      sta	HMCLR
   1861  41ad		       ba		      tsx
   1862  41ae		       86 f6		      stx	stack1
   1863  41b0		       a2 e0		      ldx	#$E0
   1864  41b2		       86 20		      stx	HMP0
   1865  41b4
   1866  41b4		       a5 a3		      LDA	scorecolor
   1867  41b6		       85 06		      STA	COLUP0
   1868  41b8		       85 07		      STA	COLUP1
   1869  41ba				  -	      ifconst	scorefade
   1870  41ba				  -	      STA	stack2
   1871  41ba					      endif
   1872  41ba					      ifconst	pfscore
   1873  41ba		       a5 f4		      lda	pfscorecolor
   1874  41bc		       85 08		      sta	COLUPF
   1875  41be					      endif
   1876  41be		       85 02		      sta	WSYNC
   1877  41c0		       a2 00		      ldx	#0
   1878  41c2		       86 1b		      STx	GRP0
   1879  41c4		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1880  41c6
   1881  41c6		       a5 9b		      lda	scorepointers+5
   1882  41c8							; ldy temp5
   1883  41c8		       95 a0		      sta	temp5,x
   1884  41ca							; sty scorepointers+5
   1885  41ca		       a9 ff		      lda	#>scoretable
   1886  41cc		       85 97		      sta	scorepointers+1
   1887  41ce		       85 99		      sta	scorepointers+3
   1888  41d0		       85 9b		      sta	scorepointers+5
   1889  41d2		       85 9d		      sta	temp2
   1890  41d4		       85 9f		      sta	temp4
   1891  41d6		       85 a1		      sta	temp6
   1892  41d8		       a0 07		      LDY	#7
   1893  41da		       84 25		      STY	VDELP0
   1894  41dc		       85 10		      STA	RESP0
   1895  41de		       85 11		      STA	RESP1
   1896  41e0
   1897  41e0
   1898  41e0		       a9 03		      LDA	#$03
   1899  41e2		       85 04		      STA	NUSIZ0
   1900  41e4		       85 05		      STA	NUSIZ1
   1901  41e6		       85 26		      STA	VDELP1
   1902  41e8		       a9 f0		      LDA	#$F0
   1903  41ea		       85 21		      STA	HMP1
   1904  41ec		       b1 96		      lda	(scorepointers),y
   1905  41ee		       85 1b		      sta	GRP0
   1906  41f0		       85 2a		      STA	HMOVE	; cycle 73 ?
   1907  41f2		       4c 09 f2 	      jmp	beginscore
   1908  41f5
   1909  41f5
   1910  41f5					      if	((<*)>$d4)
   1911  4200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   1912  4200					      endif
   1913  4200
   1914  4200				   loop2
   1915  4200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   1916  4202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   1917  4204					      ifconst	pfscore
   1918  4204		       ad f2 00 	      lda.w	pfscore1
   1919  4207		       85 0e		      sta	PF1
   1920  4209				  -	      else
   1921  4209				  -	      ifconst	scorefade
   1922  4209				  -	      sleep	2
   1923  4209				  -	      dec	stack2	; decrement the temporary scorecolor
   1924  4209				  -	      else
   1925  4209				  -	      sleep	7
   1926  4209				  -	      endif
   1927  4209					      endif
   1928  4209							; cycle 0
   1929  4209				   beginscore
   1930  4209		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   1931  420b		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   1932  420d		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   1933  420f		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   1934  4211		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   1935  4213		       9a		      txs
   1936  4214		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   1937  4216				  -	      ifconst	scorefade
   1938  4216				  -	      lda	stack2
   1939  4216					      else
      0  4216					      sleep	3
      1  4216				   .CYCLES    SET	3
      2  4216
      3  4216				  -	      IF	.CYCLES < 2
      4  4216				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4216				  -	      ERR
      6  4216					      ENDIF
      7  4216
      8  4216					      IF	.CYCLES & 1
      9  4216					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4216		       04 00		      nop	0
     11  4218				  -	      ELSE
     12  4218				  -	      bit	VSYNC
     13  4218					      ENDIF
     14  4218				   .CYCLES    SET	.CYCLES - 3
     15  4218					      ENDIF
     16  4218
     17  4218				  -	      REPEAT	.CYCLES / 2
     18  4218				  -	      nop
     19  4218					      REPEND
   1941  4218					      endif
   1942  4218
   1943  4218					      ifconst	pfscore
   1944  4218		       a5 f3		      lda	pfscore2
   1945  421a		       85 0e		      sta	PF1
   1946  421c				  -	      else
   1947  421c				  -	      ifconst	scorefade
   1948  421c				  -	      sta	COLUP0
   1949  421c				  -	      sta	COLUP1
   1950  421c				  -	      else
   1951  421c				  -	      sleep	6
   1952  421c				  -	      endif
   1953  421c					      endif
   1954  421c
   1955  421c		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   1956  421e		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   1957  4220		       ba		      tsx
   1958  4221		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   1959  4223		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   1960  4225		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   1961  4227		       88		      dey
   1962  4228		       10 d6		      bpl	loop2	;+2 60 180
   1963  422a
   1964  422a		       a6 f6		      ldx	stack1
   1965  422c		       9a		      txs
   1966  422d							; lda scorepointers+1
   1967  422d		       a4 9c		      ldy	temp1
   1968  422f							; sta temp1
   1969  422f		       84 97		      sty	scorepointers+1
   1970  4231
   1971  4231		       a9 00		      LDA	#0
   1972  4233		       85 0e		      sta	PF1
   1973  4235		       85 1b		      STA	GRP0
   1974  4237		       85 1c		      STA	GRP1
   1975  4239		       85 25		      STA	VDELP0
   1976  423b		       85 26		      STA	VDELP1	;do we need these
   1977  423d		       85 04		      STA	NUSIZ0
   1978  423f		       85 05		      STA	NUSIZ1
   1979  4241
   1980  4241							; lda scorepointers+3
   1981  4241		       a4 9e		      ldy	temp3
   1982  4243							; sta temp3
   1983  4243		       84 99		      sty	scorepointers+3
   1984  4245
   1985  4245							; lda scorepointers+5
   1986  4245		       a4 a0		      ldy	temp5
   1987  4247							; sta temp5
   1988  4247		       84 9b		      sty	scorepointers+5
   1989  4249					      endif		;noscore
   1990  4249		       a9 c2		      LDA	#%11000010
   1991  424b		       85 02		      sta	WSYNC
   1992  424d		       85 01		      STA	VBLANK
      0  424f					      RETURN
      1  424f				  -	      ifnconst	bankswitch
      2  424f				  -	      rts
      3  424f					      else
      4  424f		       4c dd ff 	      jmp	BS_return
      5  4252					      endif
   1994  4252
   1995  4252				  -	      ifconst	shakescreen
   1996  4252				  -doshakescreen
   1997  4252				  -	      bit	shakescreen
   1998  4252				  -	      bmi	noshakescreen
   1999  4252				  -	      sta	WSYNC
   2000  4252				  -noshakescreen
   2001  4252				  -	      ldx	missile0height
   2002  4252				  -	      inx
   2003  4252				  -	      rts
   2004  4252					      endif
   2005  4252
   2006  4252							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2007  4252
   2008  4252				   start
   2009  4252		       78		      sei
   2010  4253		       d8		      cld
   2011  4254		       a0 00		      ldy	#0
   2012  4256		       a5 d0		      lda	$D0
   2013  4258		       c9 2c		      cmp	#$2C	;check RAM location #1
   2014  425a		       d0 07		      bne	MachineIs2600
   2015  425c		       a5 d1		      lda	$D1
   2016  425e		       c9 a9		      cmp	#$A9	;check RAM location #2
   2017  4260		       d0 01		      bne	MachineIs2600
   2018  4262		       88		      dey
   2019  4263				   MachineIs2600
   2020  4263		       a2 00		      ldx	#0
   2021  4265		       8a		      txa
   2022  4266				   clearmem
   2023  4266		       e8		      inx
   2024  4267		       9a		      txs
   2025  4268		       48		      pha
   2026  4269		       d0 fb		      bne	clearmem
   2027  426b		       84 9c		      sty	temp1
   2028  426d					      ifnconst	multisprite
   2029  426d				  -	      ifconst	pfrowheight
   2030  426d				  -	      lda	#pfrowheight
   2031  426d					      else
   2032  426d				  -	      ifconst	pfres
   2033  426d				  -	      lda	#(96/pfres)
   2034  426d					      else
   2035  426d		       a9 08		      lda	#8
   2036  426f					      endif
   2037  426f					      endif
   2038  426f		       85 ef		      sta	playfieldpos
   2039  4271					      endif
   2040  4271		       a2 05		      ldx	#5
   2041  4273				   initscore
   2042  4273		       a9 74		      lda	#<scoretable
   2043  4275		       95 96		      sta	scorepointers,x
   2044  4277		       ca		      dex
   2045  4278		       10 f9		      bpl	initscore
   2046  427a		       a9 01		      lda	#1
   2047  427c		       85 0a		      sta	CTRLPF
   2048  427e		       0d 84 02 	      ora	INTIM
   2049  4281		       85 a2		      sta	rand
   2050  4283
   2051  4283				  -	      ifconst	multisprite
   2052  4283				  -	      jsr	multisprite_setup
   2053  4283					      endif
   2054  4283
   2055  4283				  -	      ifnconst	bankswitch
   2056  4283				  -	      jmp	game
   2057  4283					      else
   2058  4283		       a9 8f		      lda	#>(game-1)
   2059  4285		       48		      pha
   2060  4286		       a9 ff		      lda	#<(game-1)
   2061  4288		       48		      pha
   2062  4289		       48		      pha
   2063  428a		       48		      pha
   2064  428b		       a2 01		      ldx	#1
   2065  428d		       4c eb ff 	      jmp	BS_jsr
   2066  4290					      endif
   2067  4290							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2068  4290
   2069  4290							; playfield drawing routines
   2070  4290							; you get a 32x12 bitmapped display in a single color :)
   2071  4290							; 0-31 and 0-11
   2072  4290
   2073  4290				   pfclear		; clears playfield - or fill with pattern
   2074  4290				  -	      ifconst	pfres
   2075  4290				  -	      ldx	#pfres*pfwidth-1
   2076  4290					      else
   2077  4290		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   2078  4292					      endif
   2079  4292				   pfclear_loop
   2080  4292					      ifnconst	superchip
   2081  4292		       95 a4		      sta	playfield,x
   2082  4294				  -	      else
   2083  4294				  -	      sta	playfield-128,x
   2084  4294					      endif
   2085  4294		       ca		      dex
   2086  4295		       10 fb		      bpl	pfclear_loop
      0  4297					      RETURN
      1  4297				  -	      ifnconst	bankswitch
      2  4297				  -	      rts
      3  4297					      else
      4  4297		       4c dd ff 	      jmp	BS_return
      5  429a					      endif
   2088  429a
   2089  429a				   setuppointers
   2090  429a		       86 9d		      stx	temp2	; store on.off.flip value
   2091  429c		       aa		      tax		; put x-value in x 
   2092  429d		       4a		      lsr
   2093  429e		       4a		      lsr
   2094  429f		       4a		      lsr		; divide x pos by 8 
   2095  42a0		       85 9c		      sta	temp1
   2096  42a2		       98		      tya
   2097  42a3		       0a		      asl
   2098  42a4					      if	pfwidth=4
   2099  42a4		       0a		      asl		; multiply y pos by 4
   2100  42a5					      endif		; else multiply by 2
   2101  42a5		       18		      clc
   2102  42a6		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   2103  42a8		       a8		      tay		; put the value in y
   2104  42a9		       a5 9d		      lda	temp2	; restore on.off.flip value
   2105  42ab		       60		      rts
   2106  42ac
   2107  42ac				   pfread
   2108  42ac							;x=xvalue, y=yvalue
   2109  42ac		       20 9a f2 	      jsr	setuppointers
   2110  42af		       bd 44 f3 	      lda	setbyte,x
   2111  42b2		       39 a4 00 	      and	playfield,y
   2112  42b5		       5d 44 f3 	      eor	setbyte,x
   2113  42b8							; beq readzero
   2114  42b8							; lda #1
   2115  42b8							; readzero
      0  42b8					      RETURN
      1  42b8				  -	      ifnconst	bankswitch
      2  42b8				  -	      rts
      3  42b8					      else
      4  42b8		       4c dd ff 	      jmp	BS_return
      5  42bb					      endif
   2117  42bb
   2118  42bb				   pfpixel
   2119  42bb							;x=xvalue, y=yvalue, a=0,1,2
   2120  42bb		       20 9a f2 	      jsr	setuppointers
   2121  42be
   2122  42be					      ifconst	bankswitch
   2123  42be		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2124  42c0		       f0 0f		      beq	pixelon_r	; if "on" go to on
   2125  42c2		       4a		      lsr
   2126  42c3		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   2127  42c5		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2128  42c8		       5d 44 f3 	      eor	setbyte,x
   2129  42cb				  -	      ifconst	superchip
   2130  42cb				  -	      sta	playfield-128,y
   2131  42cb					      else
   2132  42cb		       99 a4 00 	      sta	playfield,y
   2133  42ce					      endif
      0  42ce					      RETURN
      1  42ce				  -	      ifnconst	bankswitch
      2  42ce				  -	      rts
      3  42ce					      else
      4  42ce		       4c dd ff 	      jmp	BS_return
      5  42d1					      endif
   2135  42d1				   pixelon_r
   2136  42d1		       b9 a4 00 	      lda	playfield,y
   2137  42d4		       1d 44 f3 	      ora	setbyte,x
   2138  42d7				  -	      ifconst	superchip
   2139  42d7				  -	      sta	playfield-128,y
   2140  42d7					      else
   2141  42d7		       99 a4 00 	      sta	playfield,y
   2142  42da					      endif
      0  42da					      RETURN
      1  42da				  -	      ifnconst	bankswitch
      2  42da				  -	      rts
      3  42da					      else
      4  42da		       4c dd ff 	      jmp	BS_return
      5  42dd					      endif
   2144  42dd				   pixeloff_r
   2145  42dd		       bd 44 f3 	      lda	setbyte,x
   2146  42e0		       49 ff		      eor	#$ff
   2147  42e2		       39 a4 00 	      and	playfield,y
   2148  42e5				  -	      ifconst	superchip
   2149  42e5				  -	      sta	playfield-128,y
   2150  42e5					      else
   2151  42e5		       99 a4 00 	      sta	playfield,y
   2152  42e8					      endif
      0  42e8					      RETURN
      1  42e8				  -	      ifnconst	bankswitch
      2  42e8				  -	      rts
      3  42e8					      else
      4  42e8		       4c dd ff 	      jmp	BS_return
      5  42eb					      endif
   2154  42eb
   2155  42eb				  -	      else
   2156  42eb				  -	      jmp	plotpoint
   2157  42eb					      endif
   2158  42eb
   2159  42eb				   pfhline
   2160  42eb							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2161  42eb		       20 9a f2 	      jsr	setuppointers
   2162  42ee		       4c f8 f2 	      jmp	noinc
   2163  42f1				   keepgoing
   2164  42f1		       e8		      inx
   2165  42f2		       8a		      txa
   2166  42f3		       29 07		      and	#7
   2167  42f5		       d0 01		      bne	noinc
   2168  42f7		       c8		      iny
   2169  42f8				   noinc
   2170  42f8		       20 1d f3 	      jsr	plotpoint
   2171  42fb		       e4 9e		      cpx	temp3
   2172  42fd		       30 f2		      bmi	keepgoing
      0  42ff					      RETURN
      1  42ff				  -	      ifnconst	bankswitch
      2  42ff				  -	      rts
      3  42ff					      else
      4  42ff		       4c dd ff 	      jmp	BS_return
      5  4302					      endif
   2174  4302
   2175  4302				   pfvline
   2176  4302							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2177  4302		       20 9a f2 	      jsr	setuppointers
   2178  4305		       84 9c		      sty	temp1	; store memory location offset
   2179  4307		       e6 9e		      inc	temp3	; increase final x by 1 
   2180  4309		       a5 9e		      lda	temp3
   2181  430b		       0a		      asl
   2182  430c					      if	pfwidth=4
   2183  430c		       0a		      asl		; multiply by 4
   2184  430d					      endif		; else multiply by 2
   2185  430d		       85 9e		      sta	temp3	; store it
   2186  430f							; Thanks to Michael Rideout for fixing a bug in this code
   2187  430f							; right now, temp1=y=starting memory location, temp3=final
   2188  430f							; x should equal original x value
   2189  430f				   keepgoingy
   2190  430f		       20 1d f3 	      jsr	plotpoint
   2191  4312		       c8		      iny
   2192  4313		       c8		      iny
   2193  4314					      if	pfwidth=4
   2194  4314		       c8		      iny
   2195  4315		       c8		      iny
   2196  4316					      endif
   2197  4316		       c4 9e		      cpy	temp3
   2198  4318		       30 f5		      bmi	keepgoingy
      0  431a					      RETURN
      1  431a				  -	      ifnconst	bankswitch
      2  431a				  -	      rts
      3  431a					      else
      4  431a		       4c dd ff 	      jmp	BS_return
      5  431d					      endif
   2200  431d
   2201  431d				   plotpoint
   2202  431d		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2203  431f		       f0 0d		      beq	pixelon	; if "on" go to on
   2204  4321		       4a		      lsr
   2205  4322		       b0 14		      bcs	pixeloff	; value is 1 if true
   2206  4324		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2207  4327		       5d 44 f3 	      eor	setbyte,x
   2208  432a				  -	      ifconst	superchip
   2209  432a				  -	      sta	playfield-128,y
   2210  432a					      else
   2211  432a		       99 a4 00 	      sta	playfield,y
   2212  432d					      endif
   2213  432d		       60		      rts
   2214  432e				   pixelon
   2215  432e		       b9 a4 00 	      lda	playfield,y
   2216  4331		       1d 44 f3 	      ora	setbyte,x
   2217  4334				  -	      ifconst	superchip
   2218  4334				  -	      sta	playfield-128,y
   2219  4334					      else
   2220  4334		       99 a4 00 	      sta	playfield,y
   2221  4337					      endif
   2222  4337		       60		      rts
   2223  4338				   pixeloff
   2224  4338		       bd 44 f3 	      lda	setbyte,x
   2225  433b		       49 ff		      eor	#$ff
   2226  433d		       39 a4 00 	      and	playfield,y
   2227  4340				  -	      ifconst	superchip
   2228  4340				  -	      sta	playfield-128,y
   2229  4340					      else
   2230  4340		       99 a4 00 	      sta	playfield,y
   2231  4343					      endif
   2232  4343		       60		      rts
   2233  4344
   2234  4344				   setbyte
   2235  4344					      ifnconst	pfcenter
   2236  4344		       80		      .byte.b	$80
   2237  4345		       40		      .byte.b	$40
   2238  4346		       20		      .byte.b	$20
   2239  4347		       10		      .byte.b	$10
   2240  4348		       08		      .byte.b	$08
   2241  4349		       04		      .byte.b	$04
   2242  434a		       02		      .byte.b	$02
   2243  434b		       01		      .byte.b	$01
   2244  434c					      endif
   2245  434c		       01		      .byte.b	$01
   2246  434d		       02		      .byte.b	$02
   2247  434e		       04		      .byte.b	$04
   2248  434f		       08		      .byte.b	$08
   2249  4350		       10		      .byte.b	$10
   2250  4351		       20		      .byte.b	$20
   2251  4352		       40		      .byte.b	$40
   2252  4353		       80		      .byte.b	$80
   2253  4354		       80		      .byte.b	$80
   2254  4355		       40		      .byte.b	$40
   2255  4356		       20		      .byte.b	$20
   2256  4357		       10		      .byte.b	$10
   2257  4358		       08		      .byte.b	$08
   2258  4359		       04		      .byte.b	$04
   2259  435a		       02		      .byte.b	$02
   2260  435b		       01		      .byte.b	$01
   2261  435c		       01		      .byte.b	$01
   2262  435d		       02		      .byte.b	$02
   2263  435e		       04		      .byte.b	$04
   2264  435f		       08		      .byte.b	$08
   2265  4360		       10		      .byte.b	$10
   2266  4361		       20		      .byte.b	$20
   2267  4362		       40		      .byte.b	$40
   2268  4363		       80		      .byte.b	$80
   2269  4364							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2270  4364
   2271  4364				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   2272  4364		       d0 15		      bne	notleft
   2273  4366							;left
   2274  4366				  -	      ifconst	pfres
   2275  4366				  -	      ldx	#pfres*4
   2276  4366					      else
   2277  4366		       a2 30		      ldx	#48
   2278  4368					      endif
   2279  4368				   leftloop
   2280  4368		       b5 a3		      lda	playfield-1,x
   2281  436a		       4a		      lsr
   2282  436b
   2283  436b				  -	      ifconst	superchip
   2284  436b				  -	      lda	playfield-2,x
   2285  436b				  -	      rol
   2286  436b				  -	      sta	playfield-130,x
   2287  436b				  -	      lda	playfield-3,x
   2288  436b				  -	      ror
   2289  436b				  -	      sta	playfield-131,x
   2290  436b				  -	      lda	playfield-4,x
   2291  436b				  -	      rol
   2292  436b				  -	      sta	playfield-132,x
   2293  436b				  -	      lda	playfield-1,x
   2294  436b				  -	      ror
   2295  436b				  -	      sta	playfield-129,x
   2296  436b					      else
   2297  436b		       36 a2		      rol	playfield-2,x
   2298  436d		       76 a1		      ror	playfield-3,x
   2299  436f		       36 a0		      rol	playfield-4,x
   2300  4371		       76 a3		      ror	playfield-1,x
   2301  4373					      endif
   2302  4373
   2303  4373		       8a		      txa
   2304  4374		       cb 04		      sbx	#4
   2305  4376		       d0 f0		      bne	leftloop
      0  4378					      RETURN
      1  4378				  -	      ifnconst	bankswitch
      2  4378				  -	      rts
      3  4378					      else
      4  4378		       4c dd ff 	      jmp	BS_return
      5  437b					      endif
   2307  437b
   2308  437b				   notleft
   2309  437b		       4a		      lsr
   2310  437c		       90 15		      bcc	notright
   2311  437e							;right
   2312  437e
   2313  437e				  -	      ifconst	pfres
   2314  437e				  -	      ldx	#pfres*4
   2315  437e					      else
   2316  437e		       a2 30		      ldx	#48
   2317  4380					      endif
   2318  4380				   rightloop
   2319  4380		       b5 a0		      lda	playfield-4,x
   2320  4382		       4a		      lsr
   2321  4383				  -	      ifconst	superchip
   2322  4383				  -	      lda	playfield-3,x
   2323  4383				  -	      rol
   2324  4383				  -	      sta	playfield-131,x
   2325  4383				  -	      lda	playfield-2,x
   2326  4383				  -	      ror
   2327  4383				  -	      sta	playfield-130,x
   2328  4383				  -	      lda	playfield-1,x
   2329  4383				  -	      rol
   2330  4383				  -	      sta	playfield-129,x
   2331  4383				  -	      lda	playfield-4,x
   2332  4383				  -	      ror
   2333  4383				  -	      sta	playfield-132,x
   2334  4383					      else
   2335  4383		       36 a1		      rol	playfield-3,x
   2336  4385		       76 a2		      ror	playfield-2,x
   2337  4387		       36 a3		      rol	playfield-1,x
   2338  4389		       76 a0		      ror	playfield-4,x
   2339  438b					      endif
   2340  438b		       8a		      txa
   2341  438c		       cb 04		      sbx	#4
   2342  438e		       d0 f0		      bne	rightloop
      0  4390					      RETURN
      1  4390				  -	      ifnconst	bankswitch
      2  4390				  -	      rts
      3  4390					      else
      4  4390		       4c dd ff 	      jmp	BS_return
      5  4393					      endif
   2344  4393
   2345  4393				   notright
   2346  4393		       4a		      lsr
   2347  4394		       90 4b		      bcc	notup
   2348  4396							;up
   2349  4396		       4a		      lsr
   2350  4397		       90 02		      bcc	onedecup
   2351  4399		       c6 ef		      dec	playfieldpos
   2352  439b				   onedecup
   2353  439b		       c6 ef		      dec	playfieldpos
   2354  439d		       f0 02		      beq	shiftdown
   2355  439f		       10 3d		      bpl	noshiftdown2
   2356  43a1				   shiftdown
   2357  43a1				  -	      ifconst	pfrowheight
   2358  43a1				  -	      lda	#pfrowheight
   2359  43a1					      else
   2360  43a1					      ifnconst	pfres
   2361  43a1		       a9 08		      lda	#8
   2362  43a3				  -	      else
   2363  43a3				  -	      lda	#(96/pfres)	; try to come close to the real size
   2364  43a3					      endif
   2365  43a3					      endif
   2366  43a3
   2367  43a3		       85 ef		      sta	playfieldpos
   2368  43a5		       a5 a7		      lda	playfield+3
   2369  43a7		       85 9f		      sta	temp4
   2370  43a9		       a5 a6		      lda	playfield+2
   2371  43ab		       85 9e		      sta	temp3
   2372  43ad		       a5 a5		      lda	playfield+1
   2373  43af		       85 9d		      sta	temp2
   2374  43b1		       a5 a4		      lda	playfield
   2375  43b3		       85 9c		      sta	temp1
   2376  43b5		       a2 00		      ldx	#0
   2377  43b7				   up2
   2378  43b7		       b5 a8		      lda	playfield+4,x
   2379  43b9				  -	      ifconst	superchip
   2380  43b9				  -	      sta	playfield-128,x
   2381  43b9				  -	      lda	playfield+5,x
   2382  43b9				  -	      sta	playfield-127,x
   2383  43b9				  -	      lda	playfield+6,x
   2384  43b9				  -	      sta	playfield-126,x
   2385  43b9				  -	      lda	playfield+7,x
   2386  43b9				  -	      sta	playfield-125,x
   2387  43b9					      else
   2388  43b9		       95 a4		      sta	playfield,x
   2389  43bb		       b5 a9		      lda	playfield+5,x
   2390  43bd		       95 a5		      sta	playfield+1,x
   2391  43bf		       b5 aa		      lda	playfield+6,x
   2392  43c1		       95 a6		      sta	playfield+2,x
   2393  43c3		       b5 ab		      lda	playfield+7,x
   2394  43c5		       95 a7		      sta	playfield+3,x
   2395  43c7					      endif
   2396  43c7		       8a		      txa
   2397  43c8		       cb fc		      sbx	#252
   2398  43ca				  -	      ifconst	pfres
   2399  43ca				  -	      cpx	#(pfres-1)*4
   2400  43ca					      else
   2401  43ca		       e0 2c		      cpx	#44
   2402  43cc					      endif
   2403  43cc		       d0 e9		      bne	up2
   2404  43ce
   2405  43ce		       a5 9f		      lda	temp4
   2406  43d0
   2407  43d0				  -	      ifconst	superchip
   2408  43d0				  -	      ifconst	pfres
   2409  43d0				  -	      sta	playfield+pfres*4-129
   2410  43d0				  -	      lda	temp3
   2411  43d0				  -	      sta	playfield+pfres*4-130
   2412  43d0				  -	      lda	temp2
   2413  43d0				  -	      sta	playfield+pfres*4-131
   2414  43d0				  -	      lda	temp1
   2415  43d0				  -	      sta	playfield+pfres*4-132
   2416  43d0				  -	      else
   2417  43d0				  -	      sta	playfield+47-128
   2418  43d0				  -	      lda	temp3
   2419  43d0				  -	      sta	playfield+46-128
   2420  43d0				  -	      lda	temp2
   2421  43d0				  -	      sta	playfield+45-128
   2422  43d0				  -	      lda	temp1
   2423  43d0				  -	      sta	playfield+44-128
   2424  43d0				  -	      endif
   2425  43d0					      else
   2426  43d0				  -	      ifconst	pfres
   2427  43d0				  -	      sta	playfield+pfres*4-1
   2428  43d0				  -	      lda	temp3
   2429  43d0				  -	      sta	playfield+pfres*4-2
   2430  43d0				  -	      lda	temp2
   2431  43d0				  -	      sta	playfield+pfres*4-3
   2432  43d0				  -	      lda	temp1
   2433  43d0				  -	      sta	playfield+pfres*4-4
   2434  43d0					      else
   2435  43d0		       85 d3		      sta	playfield+47
   2436  43d2		       a5 9e		      lda	temp3
   2437  43d4		       85 d2		      sta	playfield+46
   2438  43d6		       a5 9d		      lda	temp2
   2439  43d8		       85 d1		      sta	playfield+45
   2440  43da		       a5 9c		      lda	temp1
   2441  43dc		       85 d0		      sta	playfield+44
   2442  43de					      endif
   2443  43de					      endif
   2444  43de				   noshiftdown2
      0  43de					      RETURN
      1  43de				  -	      ifnconst	bankswitch
      2  43de				  -	      rts
      3  43de					      else
      4  43de		       4c dd ff 	      jmp	BS_return
      5  43e1					      endif
   2446  43e1
   2447  43e1
   2448  43e1				   notup
   2449  43e1							;down
   2450  43e1		       4a		      lsr
   2451  43e2		       b0 02		      bcs	oneincup
   2452  43e4		       e6 ef		      inc	playfieldpos
   2453  43e6				   oneincup
   2454  43e6		       e6 ef		      inc	playfieldpos
   2455  43e8		       a5 ef		      lda	playfieldpos
   2456  43ea
   2457  43ea				  -	      ifconst	pfrowheight
   2458  43ea				  -	      cmp	#pfrowheight+1
   2459  43ea					      else
   2460  43ea					      ifnconst	pfres
   2461  43ea		       c9 09		      cmp	#9
   2462  43ec				  -	      else
   2463  43ec				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   2464  43ec					      endif
   2465  43ec					      endif
   2466  43ec
   2467  43ec		       90 3b		      bcc	noshiftdown
   2468  43ee		       a9 01		      lda	#1
   2469  43f0		       85 ef		      sta	playfieldpos
   2470  43f2
   2471  43f2				  -	      ifconst	pfres
   2472  43f2				  -	      lda	playfield+pfres*4-1
   2473  43f2				  -	      sta	temp4
   2474  43f2				  -	      lda	playfield+pfres*4-2
   2475  43f2				  -	      sta	temp3
   2476  43f2				  -	      lda	playfield+pfres*4-3
   2477  43f2				  -	      sta	temp2
   2478  43f2				  -	      lda	playfield+pfres*4-4
   2479  43f2					      else
   2480  43f2		       a5 d3		      lda	playfield+47
   2481  43f4		       85 9f		      sta	temp4
   2482  43f6		       a5 d2		      lda	playfield+46
   2483  43f8		       85 9e		      sta	temp3
   2484  43fa		       a5 d1		      lda	playfield+45
   2485  43fc		       85 9d		      sta	temp2
   2486  43fe		       a5 d0		      lda	playfield+44
   2487  4400					      endif
   2488  4400
   2489  4400		       85 9c		      sta	temp1
   2490  4402
   2491  4402				  -	      ifconst	pfres
   2492  4402				  -	      ldx	#(pfres-1)*4
   2493  4402					      else
   2494  4402		       a2 2c		      ldx	#44
   2495  4404					      endif
   2496  4404				   down2
   2497  4404		       b5 a3		      lda	playfield-1,x
   2498  4406				  -	      ifconst	superchip
   2499  4406				  -	      sta	playfield-125,x
   2500  4406				  -	      lda	playfield-2,x
   2501  4406				  -	      sta	playfield-126,x
   2502  4406				  -	      lda	playfield-3,x
   2503  4406				  -	      sta	playfield-127,x
   2504  4406				  -	      lda	playfield-4,x
   2505  4406				  -	      sta	playfield-128,x
   2506  4406					      else
   2507  4406		       95 a7		      sta	playfield+3,x
   2508  4408		       b5 a2		      lda	playfield-2,x
   2509  440a		       95 a6		      sta	playfield+2,x
   2510  440c		       b5 a1		      lda	playfield-3,x
   2511  440e		       95 a5		      sta	playfield+1,x
   2512  4410		       b5 a0		      lda	playfield-4,x
   2513  4412		       95 a4		      sta	playfield,x
   2514  4414					      endif
   2515  4414		       8a		      txa
   2516  4415		       cb 04		      sbx	#4
   2517  4417		       d0 eb		      bne	down2
   2518  4419
   2519  4419		       a5 9f		      lda	temp4
   2520  441b				  -	      ifconst	superchip
   2521  441b				  -	      sta	playfield-125
   2522  441b				  -	      lda	temp3
   2523  441b				  -	      sta	playfield-126
   2524  441b				  -	      lda	temp2
   2525  441b				  -	      sta	playfield-127
   2526  441b				  -	      lda	temp1
   2527  441b				  -	      sta	playfield-128
   2528  441b					      else
   2529  441b		       85 a7		      sta	playfield+3
   2530  441d		       a5 9e		      lda	temp3
   2531  441f		       85 a6		      sta	playfield+2
   2532  4421		       a5 9d		      lda	temp2
   2533  4423		       85 a5		      sta	playfield+1
   2534  4425		       a5 9c		      lda	temp1
   2535  4427		       85 a4		      sta	playfield
   2536  4429					      endif
   2537  4429				   noshiftdown
      0  4429					      RETURN
      1  4429				  -	      ifnconst	bankswitch
      2  4429				  -	      rts
      3  4429					      else
      4  4429		       4c dd ff 	      jmp	BS_return
      5  442c					      endif
   2539  442c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2540  442c
   2541  442c							;standard routines needed for pretty much all games
   2542  442c							; just the random number generator is left - maybe we should remove this asm file altogether?
   2543  442c							; repositioning code and score pointer setup moved to overscan
   2544  442c							; read switches, joysticks now compiler generated (more efficient)
   2545  442c
   2546  442c				   randomize
   2547  442c		       a5 a2		      lda	rand
   2548  442e		       4a		      lsr
   2549  442f					      ifconst	rand16
   2550  442f		       26 e1		      rol	rand16
   2551  4431					      endif
   2552  4431		       90 02		      bcc	noeor
   2553  4433		       49 b4		      eor	#$B4
   2554  4435				   noeor
   2555  4435		       85 a2		      sta	rand
   2556  4437					      ifconst	rand16
   2557  4437		       45 e1		      eor	rand16
   2558  4439					      endif
      0  4439					      RETURN
      1  4439				  -	      ifnconst	bankswitch
      2  4439				  -	      rts
      3  4439					      else
      4  4439		       4c dd ff 	      jmp	BS_return
      5  443c					      endif
   2560  443c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2561  443c
   2562  443c				   drawscreen
   2563  443c				  -	      ifconst	debugscore
   2564  443c				  -	      ldx	#14
   2565  443c				  -	      lda	INTIM	; display # cycles left in the score
   2566  443c				  -
   2567  443c				  -	      ifconst	mincycles
   2568  443c				  -	      lda	mincycles
   2569  443c				  -	      cmp	INTIM
   2570  443c				  -	      lda	mincycles
   2571  443c				  -	      bcc	nochange
   2572  443c				  -	      lda	INTIM
   2573  443c				  -	      sta	mincycles
   2574  443c				  -nochange
   2575  443c				  -	      endif
   2576  443c				  -
   2577  443c				  -			; cmp #$2B
   2578  443c				  -			; bcs no_cycles_left
   2579  443c				  -	      bmi	cycles_left
   2580  443c				  -	      ldx	#64
   2581  443c				  -	      eor	#$ff	;make negative
   2582  443c				  -cycles_left
   2583  443c				  -	      stx	scorecolor
   2584  443c				  -	      and	#$7f	; clear sign bit
   2585  443c				  -	      tax
   2586  443c				  -	      lda	scorebcd,x
   2587  443c				  -	      sta	score+2
   2588  443c				  -	      lda	scorebcd1,x
   2589  443c				  -	      sta	score+1
   2590  443c				  -	      jmp	done_debugscore
   2591  443c				  -scorebcd
   2592  443c				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2593  443c				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2594  443c				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2595  443c				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2596  443c				  -scorebcd1
   2597  443c				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2598  443c				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2599  443c				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2600  443c				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2601  443c				  -done_debugscore
   2602  443c					      endif
   2603  443c
   2604  443c				  -	      ifconst	debugcycles
   2605  443c				  -	      lda	INTIM	; if we go over, it mucks up the background color
   2606  443c				  -			; cmp #$2B
   2607  443c				  -			; BCC overscan
   2608  443c				  -	      bmi	overscan
   2609  443c				  -	      sta	COLUBK
   2610  443c				  -	      bcs	doneoverscan
   2611  443c					      endif
   2612  443c
   2613  443c				   overscan
   2614  443c				  -	      ifconst	interlaced
   2615  443c				  -	      PHP
   2616  443c				  -	      PLA
   2617  443c				  -	      EOR	#4	; flip interrupt bit
   2618  443c				  -	      PHA
   2619  443c				  -	      PLP
   2620  443c				  -	      AND	#4	; isolate the interrupt bit
   2621  443c				  -	      TAX		; save it for later
   2622  443c					      endif
   2623  443c
   2624  443c				   overscanloop
   2625  443c		       ad 84 02 	      lda	INTIM	;wait for sync
   2626  443f		       30 fb		      bmi	overscanloop
   2627  4441				   doneoverscan
   2628  4441
   2629  4441							;do VSYNC
   2630  4441
   2631  4441				  -	      ifconst	interlaced
   2632  4441				  -	      CPX	#4
   2633  4441				  -	      BNE	oddframevsync
   2634  4441					      endif
   2635  4441
   2636  4441		       a9 02		      lda	#2
   2637  4443		       85 02		      sta	WSYNC
   2638  4445		       85 00		      sta	VSYNC
   2639  4447		       85 02		      STA	WSYNC
   2640  4449		       85 02		      STA	WSYNC
   2641  444b		       4a		      lsr
   2642  444c		       85 02		      STA	WSYNC
   2643  444e		       85 00		      STA	VSYNC
   2644  4450		       85 01		      sta	VBLANK
   2645  4452				  -	      ifnconst	overscan_time
   2646  4452				  -	      lda	#37+128
   2647  4452					      else
   2648  4452		       a9 d2		      lda	#overscan_time+128
   2649  4454					      endif
   2650  4454		       8d 96 02 	      sta	TIM64T
   2651  4457
   2652  4457				  -	      ifconst	interlaced
   2653  4457				  -	      jmp	postsync
   2654  4457				  -
   2655  4457				  -oddframevsync
   2656  4457				  -	      sta	WSYNC
   2657  4457				  -
   2658  4457				  -	      LDA	($80,X)	; 11 waste
   2659  4457				  -	      LDA	($80,X)	; 11 waste
   2660  4457				  -	      LDA	($80,X)	; 11 waste
   2661  4457				  -
   2662  4457				  -	      lda	#2
   2663  4457				  -	      sta	VSYNC
   2664  4457				  -	      sta	WSYNC
   2665  4457				  -	      sta	WSYNC
   2666  4457				  -	      sta	WSYNC
   2667  4457				  -
   2668  4457				  -	      LDA	($80,X)	; 11 waste
   2669  4457				  -	      LDA	($80,X)	; 11 waste
   2670  4457				  -	      LDA	($80,X)	; 11 waste
   2671  4457				  -
   2672  4457				  -	      lda	#0
   2673  4457				  -	      sta	VSYNC
   2674  4457				  -	      sta	VBLANK
   2675  4457				  -	      ifnconst	overscan_time
   2676  4457				  -	      lda	#37+128
   2677  4457				  -	      else
   2678  4457				  -	      lda	#overscan_time+128
   2679  4457				  -	      endif
   2680  4457				  -	      sta	TIM64T
   2681  4457				  -
   2682  4457				  -postsync
   2683  4457					      endif
   2684  4457
   2685  4457				  -	      ifconst	legacy
   2686  4457				  -	      if	legacy < 100
   2687  4457				  -	      ldx	#4
   2688  4457				  -adjustloop
   2689  4457				  -	      lda	player0x,x
   2690  4457				  -	      sec
   2691  4457				  -	      sbc	#14	;?
   2692  4457				  -	      sta	player0x,x
   2693  4457				  -	      dex
   2694  4457				  -	      bpl	adjustloop
   2695  4457				  -	      endif
   2696  4457					      endif
   2697  4457				  -	      if	((<*)>$e9)&&((<*)<$fa)
   2698  4457				  -	      repeat	($fa-(<*))
   2699  4457				  -	      nop
   2700  4457				  -	      repend
   2701  4457					      endif
   2702  4457		       85 02		      sta	WSYNC
   2703  4459		       a2 04		      ldx	#4
      0  445b					      SLEEP	3
      1  445b				   .CYCLES    SET	3
      2  445b
      3  445b				  -	      IF	.CYCLES < 2
      4  445b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  445b				  -	      ERR
      6  445b					      ENDIF
      7  445b
      8  445b					      IF	.CYCLES & 1
      9  445b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  445b		       04 00		      nop	0
     11  445d				  -	      ELSE
     12  445d				  -	      bit	VSYNC
     13  445d					      ENDIF
     14  445d				   .CYCLES    SET	.CYCLES - 3
     15  445d					      ENDIF
     16  445d
     17  445d				  -	      REPEAT	.CYCLES / 2
     18  445d				  -	      nop
     19  445d					      REPEND
   2705  445d				   HorPosLoop		; 5
   2706  445d		       b5 80		      lda	player0x,X	;+4 9
   2707  445f		       38		      sec		;+2 11
   2708  4460				   DivideLoop
   2709  4460		       e9 0f		      sbc	#15
   2710  4462		       b0 fc		      bcs	DivideLoop	;+4 15
   2711  4464		       95 9c		      sta	temp1,X	;+4 19
   2712  4466		       95 10		      sta	RESP0,X	;+4 23
   2713  4468		       85 02		      sta	WSYNC
   2714  446a		       ca		      dex
   2715  446b		       10 f0		      bpl	HorPosLoop	;+5 5
   2716  446d							; 4
   2717  446d
   2718  446d		       a2 04		      ldx	#4
   2719  446f		       b4 9c		      ldy	temp1,X
   2720  4471		       b9 cd f3 	      lda	repostable-256,Y
   2721  4474		       95 20		      sta	HMP0,X	;+14 18
   2722  4476
   2723  4476		       ca		      dex
   2724  4477		       b4 9c		      ldy	temp1,X
   2725  4479		       b9 cd f3 	      lda	repostable-256,Y
   2726  447c		       95 20		      sta	HMP0,X	;+14 32
   2727  447e
   2728  447e		       ca		      dex
   2729  447f		       b4 9c		      ldy	temp1,X
   2730  4481		       b9 cd f3 	      lda	repostable-256,Y
   2731  4484		       95 20		      sta	HMP0,X	;+14 46
   2732  4486
   2733  4486		       ca		      dex
   2734  4487		       b4 9c		      ldy	temp1,X
   2735  4489		       b9 cd f3 	      lda	repostable-256,Y
   2736  448c		       95 20		      sta	HMP0,X	;+14 60
   2737  448e
   2738  448e		       ca		      dex
   2739  448f		       b4 9c		      ldy	temp1,X
   2740  4491		       b9 cd f3 	      lda	repostable-256,Y
   2741  4494		       95 20		      sta	HMP0,X	;+14 74
   2742  4496
   2743  4496		       85 02		      sta	WSYNC
   2744  4498
   2745  4498		       85 2a		      sta	HMOVE	;+3 3
   2746  449a
   2747  449a
   2748  449a				  -	      ifconst	legacy
   2749  449a				  -	      if	legacy < 100
   2750  449a				  -	      ldx	#4
   2751  449a				  -adjustloop2
   2752  449a				  -	      lda	player0x,x
   2753  449a				  -	      clc
   2754  449a				  -	      adc	#14	;?
   2755  449a				  -	      sta	player0x,x
   2756  449a				  -	      dex
   2757  449a				  -	      bpl	adjustloop2
   2758  449a				  -	      endif
   2759  449a					      endif
   2760  449a
   2761  449a
   2762  449a
   2763  449a
   2764  449a							;set score pointers
   2765  449a		       a7 95		      lax	score+2
   2766  449c		       20 cd f4 	      jsr	scorepointerset
   2767  449f		       84 9b		      sty	scorepointers+5
   2768  44a1		       86 98		      stx	scorepointers+2
   2769  44a3		       a7 94		      lax	score+1
   2770  44a5		       20 cd f4 	      jsr	scorepointerset
   2771  44a8		       84 9a		      sty	scorepointers+4
   2772  44aa		       86 97		      stx	scorepointers+1
   2773  44ac		       a7 93		      lax	score
   2774  44ae		       20 cd f4 	      jsr	scorepointerset
   2775  44b1		       84 99		      sty	scorepointers+3
   2776  44b3		       86 96		      stx	scorepointers
   2777  44b5
   2778  44b5				   vblk
   2779  44b5							; run possible vblank bB code
   2780  44b5				  -	      ifconst	vblank_bB_code
   2781  44b5				  -	      jsr	vblank_bB_code
   2782  44b5					      endif
   2783  44b5				   vblk2
   2784  44b5		       ad 84 02 	      LDA	INTIM
   2785  44b8		       30 fb		      bmi	vblk2
   2786  44ba		       4c 00 f0 	      jmp	kernel
   2787  44bd
   2788  44bd
   2789  44bd		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   2790  44c6		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   2791  44cd				   repostable
   2792  44cd
   2793  44cd				   scorepointerset
   2794  44cd		       29 0f		      and	#$0F
   2795  44cf		       0a		      asl
   2796  44d0		       0a		      asl
   2797  44d1		       0a		      asl
   2798  44d2		       69 74		      adc	#<scoretable
   2799  44d4		       a8		      tay
   2800  44d5		       8a		      txa
   2801  44d6							; and #$F0
   2802  44d6							; lsr
   2803  44d6		       4b f0		      asr	#$F0
   2804  44d8		       69 74		      adc	#<scoretable
   2805  44da		       aa		      tax
   2806  44db		       60		      rts
   2807  44dc							;bB.asm
   2808  44dc							; bB.asm file is split here
   2809  44dc				  -	      ifconst	pfres
   2810  44dc				  -	      if	(<*) > (254-pfres*pfwidth)
   2811  44dc				  -	      align	256
   2812  44dc				  -	      endif
   2813  44dc				  -	      if	(<*) < (136-pfres*pfwidth)
   2814  44dc				  -	      repeat	((136-pfres*pfwidth)-(<*))
   2815  44dc				  -	      .byte	0
   2816  44dc				  -	      repend
   2817  44dc				  -	      endif
   2818  44dc					      else
   2819  44dc					      if	(<*) > 206
   2820  4500		       00 00 00 00*	      align	256
   2821  4500					      endif
   2822  4500					      if	(<*) < 88
   2823  4500					      repeat	(88-(<*))
   2824  4500		       00		      .byte.b	0
   2823  4500					      repend
   2824  4501		       00		      .byte.b	0
   2823  4501					      repend
   2824  4502		       00		      .byte.b	0
   2823  4502					      repend
   2824  4503		       00		      .byte.b	0
   2823  4503					      repend
   2824  4504		       00		      .byte.b	0
   2823  4504					      repend
   2824  4505		       00		      .byte.b	0
   2823  4505					      repend
   2824  4506		       00		      .byte.b	0
   2823  4506					      repend
   2824  4507		       00		      .byte.b	0
   2823  4507					      repend
   2824  4508		       00		      .byte.b	0
   2823  4508					      repend
   2824  4509		       00		      .byte.b	0
   2823  4509					      repend
   2824  450a		       00		      .byte.b	0
   2823  450a					      repend
   2824  450b		       00		      .byte.b	0
   2823  450b					      repend
   2824  450c		       00		      .byte.b	0
   2823  450c					      repend
   2824  450d		       00		      .byte.b	0
   2823  450d					      repend
   2824  450e		       00		      .byte.b	0
   2823  450e					      repend
   2824  450f		       00		      .byte.b	0
   2823  450f					      repend
   2824  4510		       00		      .byte.b	0
   2823  4510					      repend
   2824  4511		       00		      .byte.b	0
   2823  4511					      repend
   2824  4512		       00		      .byte.b	0
   2823  4512					      repend
   2824  4513		       00		      .byte.b	0
   2823  4513					      repend
   2824  4514		       00		      .byte.b	0
   2823  4514					      repend
   2824  4515		       00		      .byte.b	0
   2823  4515					      repend
   2824  4516		       00		      .byte.b	0
   2823  4516					      repend
   2824  4517		       00		      .byte.b	0
   2823  4517					      repend
   2824  4518		       00		      .byte.b	0
   2823  4518					      repend
   2824  4519		       00		      .byte.b	0
   2823  4519					      repend
   2824  451a		       00		      .byte.b	0
   2823  451a					      repend
   2824  451b		       00		      .byte.b	0
   2823  451b					      repend
   2824  451c		       00		      .byte.b	0
   2823  451c					      repend
   2824  451d		       00		      .byte.b	0
   2823  451d					      repend
   2824  451e		       00		      .byte.b	0
   2823  451e					      repend
   2824  451f		       00		      .byte.b	0
   2823  451f					      repend
   2824  4520		       00		      .byte.b	0
   2823  4520					      repend
   2824  4521		       00		      .byte.b	0
   2823  4521					      repend
   2824  4522		       00		      .byte.b	0
   2823  4522					      repend
   2824  4523		       00		      .byte.b	0
   2823  4523					      repend
   2824  4524		       00		      .byte.b	0
   2823  4524					      repend
   2824  4525		       00		      .byte.b	0
   2823  4525					      repend
   2824  4526		       00		      .byte.b	0
   2823  4526					      repend
   2824  4527		       00		      .byte.b	0
   2823  4527					      repend
   2824  4528		       00		      .byte.b	0
   2823  4528					      repend
   2824  4529		       00		      .byte.b	0
   2823  4529					      repend
   2824  452a		       00		      .byte.b	0
   2823  452a					      repend
   2824  452b		       00		      .byte.b	0
   2823  452b					      repend
   2824  452c		       00		      .byte.b	0
   2823  452c					      repend
   2824  452d		       00		      .byte.b	0
   2823  452d					      repend
   2824  452e		       00		      .byte.b	0
   2823  452e					      repend
   2824  452f		       00		      .byte.b	0
   2823  452f					      repend
   2824  4530		       00		      .byte.b	0
   2823  4530					      repend
   2824  4531		       00		      .byte.b	0
   2823  4531					      repend
   2824  4532		       00		      .byte.b	0
   2823  4532					      repend
   2824  4533		       00		      .byte.b	0
   2823  4533					      repend
   2824  4534		       00		      .byte.b	0
   2823  4534					      repend
   2824  4535		       00		      .byte.b	0
   2823  4535					      repend
   2824  4536		       00		      .byte.b	0
   2823  4536					      repend
   2824  4537		       00		      .byte.b	0
   2823  4537					      repend
   2824  4538		       00		      .byte.b	0
   2823  4538					      repend
   2824  4539		       00		      .byte.b	0
   2823  4539					      repend
   2824  453a		       00		      .byte.b	0
   2823  453a					      repend
   2824  453b		       00		      .byte.b	0
   2823  453b					      repend
   2824  453c		       00		      .byte.b	0
   2823  453c					      repend
   2824  453d		       00		      .byte.b	0
   2823  453d					      repend
   2824  453e		       00		      .byte.b	0
   2823  453e					      repend
   2824  453f		       00		      .byte.b	0
   2823  453f					      repend
   2824  4540		       00		      .byte.b	0
   2823  4540					      repend
   2824  4541		       00		      .byte.b	0
   2823  4541					      repend
   2824  4542		       00		      .byte.b	0
   2823  4542					      repend
   2824  4543		       00		      .byte.b	0
   2823  4543					      repend
   2824  4544		       00		      .byte.b	0
   2823  4544					      repend
   2824  4545		       00		      .byte.b	0
   2823  4545					      repend
   2824  4546		       00		      .byte.b	0
   2823  4546					      repend
   2824  4547		       00		      .byte.b	0
   2823  4547					      repend
   2824  4548		       00		      .byte.b	0
   2823  4548					      repend
   2824  4549		       00		      .byte.b	0
   2823  4549					      repend
   2824  454a		       00		      .byte.b	0
   2823  454a					      repend
   2824  454b		       00		      .byte.b	0
   2823  454b					      repend
   2824  454c		       00		      .byte.b	0
   2823  454c					      repend
   2824  454d		       00		      .byte.b	0
   2823  454d					      repend
   2824  454e		       00		      .byte.b	0
   2823  454e					      repend
   2824  454f		       00		      .byte.b	0
   2823  454f					      repend
   2824  4550		       00		      .byte.b	0
   2823  4550					      repend
   2824  4551		       00		      .byte.b	0
   2823  4551					      repend
   2824  4552		       00		      .byte.b	0
   2823  4552					      repend
   2824  4553		       00		      .byte.b	0
   2823  4553					      repend
   2824  4554		       00		      .byte.b	0
   2823  4554					      repend
   2824  4555		       00		      .byte.b	0
   2823  4555					      repend
   2824  4556		       00		      .byte.b	0
   2823  4556					      repend
   2824  4557		       00		      .byte.b	0
   2825  4558					      repend
   2826  4558					      endif
   2827  4558					      endif
   2828  4558				   pfcolorlabel13
   2829  4558		       9a 00 00 00	      .byte.b	$9A ,0,0,0
   2830  455c		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2831  4560		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2832  4564		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2833  4568		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2834  456c		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2835  4570		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2836  4574		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2837  4578		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2838  457c		       9a 00 00 00	      .byte.b	$9A,0,0,0
   2839  4580				  -	      if	(<*) > (<(*+9))
   2840  4580				  -	      repeat	($100-<*)
   2841  4580				  -	      .byte	0
   2842  4580				  -	      repend
   2843  4580					      endif
   2844  4580				   playerL044_0
   2845  4580		       42		      .byte.b	%01000010
   2846  4581		       64		      .byte.b	%01100100
   2847  4582		       1c		      .byte.b	%00011100
   2848  4583		       3c		      .byte.b	%00111100
   2849  4584		       1c		      .byte.b	%00011100
   2850  4585		       18		      .byte.b	%00011000
   2851  4586		       0c		      .byte.b	%00001100
   2852  4587		       0c		      .byte.b	%00001100
   2853  4588		       0c		      .byte.b	%00001100
   2854  4589		       00		      .byte.b	%00000000
   2855  458a				  -	      if	(<*) > (<(*+7))
   2856  458a				  -	      repeat	($100-<*)
   2857  458a				  -	      .byte	0
   2858  458a				  -	      repend
   2859  458a					      endif
   2860  458a				   playerL045_1
   2861  458a		       fc		      .byte.b	%11111100
   2862  458b		       ff		      .byte.b	%11111111
   2863  458c		       fd		      .byte.b	%11111101
   2864  458d		       fd		      .byte.b	%11111101
   2865  458e		       ff		      .byte.b	%11111111
   2866  458f		       fc		      .byte.b	%11111100
   2867  4590		       fc		      .byte.b	%11111100
   2868  4591		       fc		      .byte.b	%11111100
   2869  4592				  -	      if	(<*) > (<(*+7))
   2870  4592				  -	      repeat	($100-<*)
   2871  4592				  -	      .byte	0
   2872  4592				  -	      repend
   2873  4592					      endif
   2874  4592				   playercolorL046_1
   2875  4592		       2c		      .byte.b	$2C	;
   2876  4593		       2c		      .byte.b	$2C	;
   2877  4594		       2c		      .byte.b	$2C	;
   2878  4595		       2c		      .byte.b	$2C	;
   2879  4596		       2c		      .byte.b	$2C	;
   2880  4597		       2c		      .byte.b	$2C	;
   2881  4598		       0e		      .byte.b	$0E	;
   2882  4599		       0e		      .byte.b	$0E	;
   2883  459a				  -	      if	(<*) > (<(*+9))
   2884  459a				  -	      repeat	($100-<*)
   2885  459a				  -	      .byte	0
   2886  459a				  -	      repend
   2887  459a					      endif
   2888  459a				   player2then_0
   2889  459a		       06		      .byte.b	%00000110
   2890  459b		       64		      .byte.b	%01100100
   2891  459c		       1c		      .byte.b	%00011100
   2892  459d		       5a		      .byte.b	%01011010
   2893  459e		       3c		      .byte.b	%00111100
   2894  459f		       18		      .byte.b	%00011000
   2895  45a0		       0c		      .byte.b	%00001100
   2896  45a1		       0c		      .byte.b	%00001100
   2897  45a2		       0c		      .byte.b	%00001100
   2898  45a3		       00		      .byte.b	%00000000
   2899  45a4				  -	      if	(<*) > (<(*+9))
   2900  45a4				  -	      repeat	($100-<*)
   2901  45a4				  -	      .byte	0
   2902  45a4				  -	      repend
   2903  45a4					      endif
   2904  45a4				   playercolor3then_0
   2905  45a4		       b4		      .byte.b	$B4	;
   2906  45a5		       b4		      .byte.b	$B4	;
   2907  45a6		       b4		      .byte.b	$B4	;
   2908  45a7		       34		      .byte.b	$34	;
   2909  45a8		       34		      .byte.b	$34	;
   2910  45a9		       34		      .byte.b	$34	;
   2911  45aa		       4e		      .byte.b	$4E	;
   2912  45ab		       4e		      .byte.b	$4E	;
   2913  45ac		       4e		      .byte.b	$4E	;
   2914  45ad		       4e		      .byte.b	$4E	;
   2915  45ae				  -	      if	(<*) > (<(*+9))
   2916  45ae				  -	      repeat	($100-<*)
   2917  45ae				  -	      .byte	0
   2918  45ae				  -	      repend
   2919  45ae					      endif
   2920  45ae				   player4then_0
   2921  45ae		       18		      .byte.b	%00011000
   2922  45af		       38		      .byte.b	%00111000
   2923  45b0		       18		      .byte.b	%00011000
   2924  45b1		       18		      .byte.b	%00011000
   2925  45b2		       18		      .byte.b	%00011000
   2926  45b3		       18		      .byte.b	%00011000
   2927  45b4		       0c		      .byte.b	%00001100
   2928  45b5		       0c		      .byte.b	%00001100
   2929  45b6		       0c		      .byte.b	%00001100
   2930  45b7		       00		      .byte.b	%00000000
   2931  45b8				  -	      if	(<*) > (<(*+9))
   2932  45b8				  -	      repeat	($100-<*)
   2933  45b8				  -	      .byte	0
   2934  45b8				  -	      repend
   2935  45b8					      endif
   2936  45b8				   playercolor5then_0
   2937  45b8		       b4		      .byte.b	$B4	;
   2938  45b9		       b4		      .byte.b	$B4	;
   2939  45ba		       b4		      .byte.b	$B4	;
   2940  45bb		       34		      .byte.b	$34	;
   2941  45bc		       34		      .byte.b	$34	;
   2942  45bd		       34		      .byte.b	$34	;
   2943  45be		       4e		      .byte.b	$4E	;
   2944  45bf		       4e		      .byte.b	$4E	;
   2945  45c0		       4e		      .byte.b	$4E	;
   2946  45c1		       4e		      .byte.b	$4E	;
   2947  45c2				  -	      if	(<*) > (<(*+9))
   2948  45c2				  -	      repeat	($100-<*)
   2949  45c2				  -	      .byte	0
   2950  45c2				  -	      repend
   2951  45c2					      endif
   2952  45c2				   player6then_0
   2953  45c2		       40		      .byte.b	%01000000
   2954  45c3		       50		      .byte.b	%01010000
   2955  45c4		       48		      .byte.b	%01001000
   2956  45c5		       38		      .byte.b	%00111000
   2957  45c6		       78		      .byte.b	%01111000
   2958  45c7		       38		      .byte.b	%00111000
   2959  45c8		       30		      .byte.b	%00110000
   2960  45c9		       18		      .byte.b	%00011000
   2961  45ca		       18		      .byte.b	%00011000
   2962  45cb		       18		      .byte.b	%00011000
   2963  45cc					      if	ECHOFIRST
      2472 bytes of ROM space left in bank 4
   2964  45cc					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 4")
   2965  45cc					      endif
   2966  45cc		       00 01	   ECHOFIRST  =	1
   2967  45cc
   2968  45cc
   2969  45cc							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2970  45cc
   2971  45cc							; feel free to modify the score graphics - just keep each digit 8 high
   2972  45cc							; and keep the conditional compilation stuff intact
   2973  45cc				  -	      ifconst	ROM2k
   2974  45cc				  -	      ORG	$F7AC-8
   2975  45cc					      else
   2976  45cc					      ifconst	bankswitch
   2977  45cc				  -	      if	bankswitch == 8
   2978  45cc				  -	      ORG	$2F94-bscode_length
   2979  45cc				  -	      RORG	$FF94-bscode_length
   2980  45cc					      endif
   2981  45cc					      if	bankswitch == 16
   2982  4f74					      ORG	$4F94-bscode_length
   2983  4f74					      RORG	$FF94-bscode_length
   2984  4f74					      endif
   2985  4f74				  -	      if	bankswitch == 32
   2986  4f74				  -	      ORG	$8F94-bscode_length
   2987  4f74				  -	      RORG	$FF94-bscode_length
   2988  4f74					      endif
   2989  4f74				  -	      if	bankswitch == 64
   2990  4f74				  -	      ORG	$10F80-bscode_length
   2991  4f74				  -	      RORG	$1FF80-bscode_length
   2992  4f74					      endif
   2993  4f74				  -	      else
   2994  4f74				  -	      ORG	$FF9C
   2995  4f74					      endif
   2996  4f74					      endif
   2997  4f74
   2998  4f74							; font equates
   2999  4f74		       00 01	   .21stcentury =	1
   3000  4f74		       00 02	   alarmclock =	2
   3001  4f74		       00 03	   handwritten =	3
   3002  4f74		       00 04	   interrupted =	4
   3003  4f74		       00 05	   retroputer =	5
   3004  4f74		       00 06	   whimsey    =	6
   3005  4f74		       00 07	   tiny       =	7
   3006  4f74		       00 08	   hex	      =	8
   3007  4f74
   3008  4f74				  -	      ifconst	font
   3009  4f74				  -	      if	font == hex
   3010  4f74				  -	      ORG	. - 48
   3011  4f74				  -	      endif
   3012  4f74					      endif
   3013  4f74
   3014  4f74				   scoretable
   3015  4f74
   3016  4f74				  -	      ifconst	font
   3017  4f74				  -	      if	font == .21stcentury
   3018  4f74				  -	      include	"score_graphics.asm.21stcentury"
   3019  4f74				  -	      endif
   3020  4f74				  -	      if	font == alarmclock
   3021  4f74				  -	      include	"score_graphics.asm.alarmclock"
   3022  4f74				  -	      endif
   3023  4f74				  -	      if	font == handwritten
   3024  4f74				  -	      include	"score_graphics.asm.handwritten"
   3025  4f74				  -	      endif
   3026  4f74				  -	      if	font == interrupted
   3027  4f74				  -	      include	"score_graphics.asm.interrupted"
   3028  4f74				  -	      endif
   3029  4f74				  -	      if	font == retroputer
   3030  4f74				  -	      include	"score_graphics.asm.retroputer"
   3031  4f74				  -	      endif
   3032  4f74				  -	      if	font == whimsey
   3033  4f74				  -	      include	"score_graphics.asm.whimsey"
   3034  4f74				  -	      endif
   3035  4f74				  -	      if	font == tiny
   3036  4f74				  -	      include	"score_graphics.asm.tiny"
   3037  4f74				  -	      endif
   3038  4f74				  -	      if	font == hex
   3039  4f74				  -	      include	"score_graphics.asm.hex"
   3040  4f74				  -	      endif
   3041  4f74					      else		; default font
   3042  4f74
   3043  4f74		       3c		      .byte.b	%00111100
   3044  4f75		       66		      .byte.b	%01100110
   3045  4f76		       66		      .byte.b	%01100110
   3046  4f77		       66		      .byte.b	%01100110
   3047  4f78		       66		      .byte.b	%01100110
   3048  4f79		       66		      .byte.b	%01100110
   3049  4f7a		       66		      .byte.b	%01100110
   3050  4f7b		       3c		      .byte.b	%00111100
   3051  4f7c
   3052  4f7c		       7e		      .byte.b	%01111110
   3053  4f7d		       18		      .byte.b	%00011000
   3054  4f7e		       18		      .byte.b	%00011000
   3055  4f7f		       18		      .byte.b	%00011000
   3056  4f80		       18		      .byte.b	%00011000
   3057  4f81		       38		      .byte.b	%00111000
   3058  4f82		       18		      .byte.b	%00011000
   3059  4f83		       08		      .byte.b	%00001000
   3060  4f84
   3061  4f84		       7e		      .byte.b	%01111110
   3062  4f85		       60		      .byte.b	%01100000
   3063  4f86		       60		      .byte.b	%01100000
   3064  4f87		       3c		      .byte.b	%00111100
   3065  4f88		       06		      .byte.b	%00000110
   3066  4f89		       06		      .byte.b	%00000110
   3067  4f8a		       46		      .byte.b	%01000110
   3068  4f8b		       3c		      .byte.b	%00111100
   3069  4f8c
   3070  4f8c		       3c		      .byte.b	%00111100
   3071  4f8d		       46		      .byte.b	%01000110
   3072  4f8e		       06		      .byte.b	%00000110
   3073  4f8f		       06		      .byte.b	%00000110
   3074  4f90		       1c		      .byte.b	%00011100
   3075  4f91		       06		      .byte.b	%00000110
   3076  4f92		       46		      .byte.b	%01000110
   3077  4f93		       3c		      .byte.b	%00111100
   3078  4f94
   3079  4f94		       0c		      .byte.b	%00001100
   3080  4f95		       0c		      .byte.b	%00001100
   3081  4f96		       7e		      .byte.b	%01111110
   3082  4f97		       4c		      .byte.b	%01001100
   3083  4f98		       4c		      .byte.b	%01001100
   3084  4f99		       2c		      .byte.b	%00101100
   3085  4f9a		       1c		      .byte.b	%00011100
   3086  4f9b		       0c		      .byte.b	%00001100
   3087  4f9c
   3088  4f9c		       3c		      .byte.b	%00111100
   3089  4f9d		       46		      .byte.b	%01000110
   3090  4f9e		       06		      .byte.b	%00000110
   3091  4f9f		       06		      .byte.b	%00000110
   3092  4fa0		       3c		      .byte.b	%00111100
   3093  4fa1		       60		      .byte.b	%01100000
   3094  4fa2		       60		      .byte.b	%01100000
   3095  4fa3		       7e		      .byte.b	%01111110
   3096  4fa4
   3097  4fa4		       3c		      .byte.b	%00111100
   3098  4fa5		       66		      .byte.b	%01100110
   3099  4fa6		       66		      .byte.b	%01100110
   3100  4fa7		       66		      .byte.b	%01100110
   3101  4fa8		       7c		      .byte.b	%01111100
   3102  4fa9		       60		      .byte.b	%01100000
   3103  4faa		       62		      .byte.b	%01100010
   3104  4fab		       3c		      .byte.b	%00111100
   3105  4fac
   3106  4fac		       30		      .byte.b	%00110000
   3107  4fad		       30		      .byte.b	%00110000
   3108  4fae		       30		      .byte.b	%00110000
   3109  4faf		       18		      .byte.b	%00011000
   3110  4fb0		       0c		      .byte.b	%00001100
   3111  4fb1		       06		      .byte.b	%00000110
   3112  4fb2		       42		      .byte.b	%01000010
   3113  4fb3		       3e		      .byte.b	%00111110
   3114  4fb4
   3115  4fb4		       3c		      .byte.b	%00111100
   3116  4fb5		       66		      .byte.b	%01100110
   3117  4fb6		       66		      .byte.b	%01100110
   3118  4fb7		       66		      .byte.b	%01100110
   3119  4fb8		       3c		      .byte.b	%00111100
   3120  4fb9		       66		      .byte.b	%01100110
   3121  4fba		       66		      .byte.b	%01100110
   3122  4fbb		       3c		      .byte.b	%00111100
   3123  4fbc
   3124  4fbc		       3c		      .byte.b	%00111100
   3125  4fbd		       46		      .byte.b	%01000110
   3126  4fbe		       06		      .byte.b	%00000110
   3127  4fbf		       3e		      .byte.b	%00111110
   3128  4fc0		       66		      .byte.b	%01100110
   3129  4fc1		       66		      .byte.b	%01100110
   3130  4fc2		       66		      .byte.b	%01100110
   3131  4fc3		       3c		      .byte.b	%00111100
   3132  4fc4
   3133  4fc4					      ifnconst	DPC_kernel_options
   3134  4fc4
   3135  4fc4		       00		      .byte.b	%00000000
   3136  4fc5		       00		      .byte.b	%00000000
   3137  4fc6		       00		      .byte.b	%00000000
   3138  4fc7		       00		      .byte.b	%00000000
   3139  4fc8		       00		      .byte.b	%00000000
   3140  4fc9		       00		      .byte.b	%00000000
   3141  4fca		       00		      .byte.b	%00000000
   3142  4fcb		       00		      .byte.b	%00000000
   3143  4fcc
   3144  4fcc					      endif
   3145  4fcc
   3146  4fcc					      endif
   3147  4fcc
   3148  4fcc				  -	      ifconst	ROM2k
   3149  4fcc				  -	      ORG	$F7FC
   3150  4fcc					      else
   3151  4fcc					      ifconst	bankswitch
   3152  4fcc				  -	      if	bankswitch == 8
   3153  4fcc				  -	      ORG	$2FF4-bscode_length
   3154  4fcc				  -	      RORG	$FFF4-bscode_length
   3155  4fcc					      endif
   3156  4fcc					      if	bankswitch == 16
   3157  4fd4					      ORG	$4FF4-bscode_length
   3158  4fd4					      RORG	$FFF4-bscode_length
   3159  4fd4					      endif
   3160  4fd4				  -	      if	bankswitch == 32
   3161  4fd4				  -	      ORG	$8FF4-bscode_length
   3162  4fd4				  -	      RORG	$FFF4-bscode_length
   3163  4fd4					      endif
   3164  4fd4				  -	      if	bankswitch == 64
   3165  4fd4				  -	      ORG	$10FE0-bscode_length
   3166  4fd4				  -	      RORG	$1FFE0-bscode_length
   3167  4fd4					      endif
   3168  4fd4				  -	      else
   3169  4fd4				  -	      ORG	$FFFC
   3170  4fd4					      endif
   3171  4fd4					      endif
   3172  4fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3173  4fd4
   3174  4fd4							; every bank has this stuff at the same place
   3175  4fd4							; this code can switch to/from any bank at any entry point
   3176  4fd4							; and can preserve register values
   3177  4fd4							; note: lines not starting with a space are not placed in all banks
   3178  4fd4							;
   3179  4fd4							; line below tells the compiler how long this is - do not remove
   3180  4fd4							;size=32
   3181  4fd4
   3182  4fd4				   begin_bscode
   3183  4fd4		       a2 ff		      ldx	#$ff
   3184  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3185  4fd6				  -	      stx	FASTFETCH
   3186  4fd6					      endif
   3187  4fd6		       9a		      txs
   3188  4fd7				  -	      if	bankswitch == 64
   3189  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3190  4fd7					      else
   3191  4fd7		       a9 f2		      lda	#>(start-1)
   3192  4fd9					      endif
   3193  4fd9		       48		      pha
   3194  4fda		       a9 51		      lda	#<(start-1)
   3195  4fdc		       48		      pha
   3196  4fdd
   3197  4fdd				   BS_return
   3198  4fdd		       48		      pha
   3199  4fde		       8a		      txa
   3200  4fdf		       48		      pha
   3201  4fe0		       ba		      tsx
   3202  4fe1
   3203  4fe1					      if	bankswitch != 64
   3204  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   3205  4fe3
   3206  4fe3		       2a		      rol
   3207  4fe4		       2a		      rol
   3208  4fe5		       2a		      rol
   3209  4fe6		       2a		      rol
   3210  4fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3211  4fe9		       aa		      tax
   3212  4fea		       e8		      inx
   3213  4feb				  -	      else
   3214  4feb				  -	      lda	4,x	; get high byte of return address
   3215  4feb				  -	      tay
   3216  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3217  4feb				  -	      sta	4,x
   3218  4feb				  -	      tya
   3219  4feb				  -	      lsr
   3220  4feb				  -	      lsr
   3221  4feb				  -	      lsr
   3222  4feb				  -	      lsr
   3223  4feb				  -	      tax
   3224  4feb				  -	      inx
   3225  4feb					      endif
   3226  4feb
   3227  4feb				   BS_jsr
   3228  4feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3229  4fee		       68		      pla
   3230  4fef		       aa		      tax
   3231  4ff0		       68		      pla
   3232  4ff1		       60		      rts
   3233  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3234  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3235  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3236  4ff2					      endif
   3237  4ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3238  4ff2
   3239  4ff2					      ifconst	bankswitch
   3240  4ff2				  -	      if	bankswitch == 8
   3241  4ff2				  -	      ORG	$2FFC
   3242  4ff2				  -	      RORG	$FFFC
   3243  4ff2					      endif
   3244  4ff2					      if	bankswitch == 16
   3245  4ffc					      ORG	$4FFC
   3246  4ffc					      RORG	$FFFC
   3247  4ffc					      endif
   3248  4ffc				  -	      if	bankswitch == 32
   3249  4ffc				  -	      ORG	$8FFC
   3250  4ffc				  -	      RORG	$FFFC
   3251  4ffc					      endif
   3252  4ffc				  -	      if	bankswitch == 64
   3253  4ffc				  -	      ORG	$10FF0
   3254  4ffc				  -	      RORG	$1FFF0
   3255  4ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3256  4ffc				  -	      ORG	$10FF8
   3257  4ffc				  -	      RORG	$1FFF8
   3258  4ffc				  -	      ifconst	superchip
   3259  4ffc				  -	      .byte	"E","F","S","C"
   3260  4ffc				  -	      else
   3261  4ffc				  -	      .byte	"E","F","E","F"
   3262  4ffc				  -	      endif
   3263  4ffc				  -	      ORG	$10FFC
   3264  4ffc				  -	      RORG	$1FFFC
   3265  4ffc					      endif
   3266  4ffc				  -	      else
   3267  4ffc				  -	      ifconst	ROM2k
   3268  4ffc				  -	      ORG	$F7FC
   3269  4ffc				  -	      else
   3270  4ffc				  -	      ORG	$FFFC
   3271  4ffc				  -	      endif
   3272  4ffc					      endif
   3273  4ffc		       52 f2		      .word.w	(start & $ffff)
   3274  4ffe		       52 f2		      .word.w	(start & $ffff)
